{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"HyperBinder SDK","text":"<p>A Python SDK for HyperBinder: a neurosymbolic database and reasoning substrate. It introduces a knew category of engineering for modern AI applications that sits between the data and the AI/application layers, that we call the knowledge layer.</p>"},{"location":"#the-knowledge-layer","title":"The Knowledge Layer","text":"<p>Modern AI applications need structured knowledge, but data lives in fragmented systems. HyperBinder is the Knowledge Layer.</p> <p>Most agent applications dump various markdown files into the context window and call that \"knowledge\" or \"memory.\" and expect the LLM to make sense of it. But knowledge should have articulated structure. It should be possible to pipe different facts together and seamlessly swap between different encoding types, such as semantic, exact, or numeric, and model a true cognitive architecture for your agent.</p> <p>Dumping prompts and hoping for the best isn't engineering. What's needed is a real cognitive architecture for your agent.</p> <p>With HyperBinder, you model your domain instead of your plumbing:</p> <pre><code>flowchart TB\n    A[\"LLMs \u00b7 Agents \u00b7 RAG\"]\n    K[\"&lt;b&gt;KNOWLEDGE DESIGN LAYER&lt;/b&gt;&lt;br/&gt;&lt;i&gt;Compounds \u00b7 Intersections \u00b7 Unified Queries&lt;/i&gt;\"]\n    D[\"Your Data Sources\"]\n\n    A &lt;--&gt;|\"Declarative API\"| K\n    K &lt;--&gt;|\"Ingestion\"| D\n\n    style K fill:#4a5568,stroke:#a0aec0,stroke-width:2px,color:#fff</code></pre> Layer Traditional Stack With HyperBinder Application Custom orchestration across systems Declarative queries Knowledge (missing - you build it yourself) Compounds + Intersections Data PostgreSQL + Elasticsearch + Neo4j + ... Any data source"},{"location":"#what-makes-hyperbinder-different","title":"What Makes HyperBinder Different?","text":"<p>HyperBinder unifies many concepts from different database traditions, including vector, graph and relational, reducing infrastructure burden considerably. Although it has the bones of a database, it's something more too. It introduces a new mathematical framework for working with embeddings that provides the means to compose rich \"mental models\" of domains for your agent to work with.</p> <p>Traditional vector databases treat embeddings as opaque black boxes:</p> <ul> <li>Data goes in \u2192 embedding comes out</li> <li>Query by similarity only</li> <li>No structural understanding</li> </ul> <p>HyperBinder uses Hyperdimensional Computing (HDC) to enable:</p> Capability Traditional Vector DB HyperBinder Similarity search Yes Yes Structural decomposition No Yes - extract components from composed structures Analogical reasoning No Yes - A:B :: C:? queries Schema-aware queries No Yes - query by slot (subject, predicate, object) Multi-hop traversal Limited Yes - semantic graph walking <p>When you specify a schema in HyperBinder, you define a compositional structure that represents the shape of the knowledge you want it to represent. These connected concepts are both human and machine readable, providing an essential interpretability bridge between developers and AI.</p> <p>If that sounds complicated, don't worry. You don't need to understand the math to use the SDK. This high level API is designed to be intuitive. It encourages you to think in your domain, whether it be the your business's org chart, the layout of a codebase, or the structure of a scientific problem. HyperBinder scaffolds your agent's mental model in terms of the natural logical entities and relationships that constitute it. The low level mathematical details are abstracted away.</p> <p>Is your data shaped liked a Hierarchy, such as an organization? Use the Hierarchy compound. Need to connect a set of facts in a sequence for a particular workflow? Use Sequence. Need to connect the the relevant parts of two documents to each other for faster, reliable lookup? Use Documents and specify an intersection between them. The agent will follow the pathways you define for it (or that you allow it to define for itself).</p>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from hybi import HyperBinder\nfrom hybi.compose import Triple, Field, Encoding\n\n# Client mode (connects to server)\nhb = HyperBinder(\"http://localhost:8000\")\n# Or local mode (embedded, no Docker needed)\n# hb = HyperBinder(local=True)\n\n# Define a knowledge graph schema\nschema = Triple(\n    subject=Field(\"entity\", encoding=Encoding.SEMANTIC),\n    predicate=Field(\"relation\", encoding=Encoding.EXACT),\n    object=Field(\"target\", encoding=Encoding.SEMANTIC),\n)\n\n# Ingest with schema\nhb.ingest(knowledge_df, collection=\"facts\", schema=schema)\n\n# Query by structure - find what Einstein is related to\nq = hb.query(\"facts\", schema=schema)\nresults = q.find(subject=\"Einstein\")\n\n# Analogical reasoning - Einstein:Relativity :: Darwin:?\nresults = hb.analogy(\"Einstein\", \"Relativity\", \"Darwin\",\n                     field_name=\"subject\", collection=\"facts\")\n</code></pre>"},{"location":"#the-compose-system","title":"The Compose System","text":"<p>HyperBinder's power comes from its Compose system, a schema language that defines how your data is structured and queried.</p> <pre><code>flowchart LR\n    subgraph molecules [MOLECULES]\n        m[\"Pair, Triple, Bundle,&lt;br/&gt;Sequence, Tree, Graph\"]\n    end\n\n    subgraph compounds [COMPOUNDS]\n        c[\"KnowledgeGraph, Catalog, TimeSeries,&lt;br/&gt;Hierarchy, Document, Network\"]\n    end\n\n    molecules --&gt; compounds</code></pre> <ul> <li>Molecules: Composable structures you define schemas with</li> <li>Compounds: Pre-configured molecules for common domains</li> </ul> <p>These various primitives each are good for different things, some semantic search, others graph traversal, others table lookup. You can specify intersections to pipe connections between them to seamlessly blend these operations together.</p> <p>(Note: a lower-level layer, atoms, exists, that presents the low level mathematical operators. Currently, atoms operate internally. We plan to expose this layer in future releases so users can define their own molecules and compounds.)</p> <p>Learn more about the Compose system \u2192</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install hybi\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - First queries in 5 minutes</li> <li>Concepts - Understand the architecture</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to HyperBinder!</p> <p>See the full CONTRIBUTING.md for detailed guidelines.</p>"},{"location":"contributing/#quick-start","title":"Quick Start","text":"<pre><code># Clone and install\ngit clone &lt;repository-url&gt;\ncd sdk\npip install -e \".[dev]\"\n\n# Run tests\npytest tests/\n\n# Check code style\nruff check .\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<pre><code># Install docs dependencies\npip install -e \".[docs]\"\n\n# Preview docs locally\nmkdocs serve\n\n# Build static site\nmkdocs build\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide introduces HyperBinder's core concepts and gets you running queries in minutes.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>pip install hybi\n</code></pre>"},{"location":"getting-started/#core-concepts","title":"Core Concepts","text":"<p>Before diving into code, understand these key ideas:</p>"},{"location":"getting-started/#1-neurosymbolic-semantic-symbolic","title":"1. Neurosymbolic = Semantic + Symbolic","text":"<p>HyperBinder combines three query paradigms:</p> Paradigm What it does Example Semantic Similarity-based matching \"Find companies like Apple\" Symbolic Exact/structured matching <code>WHERE revenue &gt; 1000000</code> Traversal Relationship discovery \"x -&gt; y -&gt; z\" <p>Most queries blend all three - semantic search with symbolic filters between relationships.</p> <p>While Hyperbinder works just fine on its own, it's tailor made for AI applications that require a clearly specified knowledge layer, such as a RAG architecture or LLM agent.</p>"},{"location":"getting-started/#2-collections-hold-your-data","title":"2. Collections Hold Your Data","text":"<p>A collection is like a database table. You ingest data into collections, then query them:</p> <pre><code>hb.ingest(\"customers.csv\", collection=\"customers\")\nresults = hb.search(\"enterprise AI\", collection=\"customers\")\n</code></pre>"},{"location":"getting-started/#3-compositional-schemas-define-structure-recommended-usage-pattern","title":"3. Compositional Schemas Define Structure (Recommended Usage Pattern)","text":"<p>For simple use cases, HyperBinder works without schemas. But schemas unlock:</p> <ul> <li>Slot-specific queries: Search only in \"subject\" field</li> <li>Structural decomposition: Extract components from composed data</li> <li>Relationship traversal: Follow paths through knowledge graphs</li> </ul> <pre><code>from hybi.compose import Triple, Field, Encoding\n\n# This schema encodes: Subject -[Predicate]-&gt; Object\nschema = Triple(\n    subject=Field(\"entity\"),\n    predicate=Field(\"relation\", encoding=Encoding.EXACT),\n    object=Field(\"target\"),\n)\n</code></pre>"},{"location":"getting-started/#your-first-queries","title":"Your First Queries","text":""},{"location":"getting-started/#connect-to-hyperbinder","title":"Connect to HyperBinder","text":"<pre><code>from hybi import HyperBinder\n\n# Client mode: Connect to server (uses HYPERBINDER_URL env var if not specified)\nhb = HyperBinder(\"http://localhost:8000\")\n\n# Local mode: Embedded client (no Docker required, needs 'hyperbinder' package)\nhb = HyperBinder(local=True)\n# Optional: specify database path\nhb = HyperBinder(local=True, db_path=\"./my_db\")\n\n# Check connection\nprint(hb.ping())  # {'status': 'ok'}\n</code></pre>"},{"location":"getting-started/#ingest-data","title":"Ingest Data","text":"<pre><code># From CSV\nhb.ingest(\"customers.csv\", collection=\"customers\")\n\n# From pandas DataFrame\nimport pandas as pd\ndf = pd.DataFrame({\n    \"name\": [\"Alice\", \"Bob\", \"Carol\"],\n    \"role\": [\"Engineer\", \"Manager\", \"Designer\"],\n    \"department\": [\"Engineering\", \"Engineering\", \"Design\"]\n})\nhb.ingest(df, collection=\"employees\")\n</code></pre>"},{"location":"getting-started/#semantic-search","title":"Semantic Search","text":"<p>Find similar items using natural language:</p> <pre><code>results = hb.search(\"machine learning experts\", collection=\"employees\")\n\nfor r in results:\n    print(f\"{r['name']}: {r.score:.2f}\")\n# Alice: 0.87\n# Bob: 0.72\n</code></pre>"},{"location":"getting-started/#sql-like-queries","title":"SQL-like Queries","text":"<p>Filter with exact conditions:</p> <pre><code># SELECT with conditions\nresult = hb.select(\n    collection=\"employees\",\n    where=[(\"department\", \"=\", \"Engineering\")]\n)\n\n# Aggregation\nresult = hb.aggregate(\n    collection=\"employees\",\n    group_by=[\"department\"],\n    aggregations=[(\"name\", \"count\", \"count\")]\n)\n</code></pre>"},{"location":"getting-started/#multi-hop-queries","title":"Multi-hop Queries","text":"<p>Traverse relationships:</p> <pre><code># Find: Alice -&gt; manager -&gt; department\nresults = hb.multihop(\n    start_value=\"Alice\",\n    path=[\"manager\", \"department\"],\n    collection=\"employees\"\n)\n</code></pre>"},{"location":"getting-started/#schema-aware-queries-compose","title":"Schema-Aware Queries (Compose)","text":"<p>In HyperBinder, schemas specify how you want vectors to compose together. They define a pattern for queries to follow.</p> <p>With HyperBinder, the developer's primary task is knowledge representation, describing the mental model of the problem domain using template units called molecules and compounds.</p> <p>Schemas transform raw data into structured knowledge. By defining a schema, you tell HyperBinder how your data relates and unlock powerful queries:</p> <pre><code>from hybi.compose import Triple, Field, Encoding\n\n# Define a relationship schema\nschema = Triple(\n    subject=Field(\"person\"),\n    predicate=Field(\"relation\", encoding=Encoding.EXACT),\n    object=Field(\"company\"),\n)\n\n# Ingest with schema\nfacts = pd.DataFrame({\n    \"person\": [\"Einstein\", \"Curie\", \"Darwin\"],\n    \"relation\": [\"worked_at\", \"worked_at\", \"studied\"],\n    \"company\": [\"Princeton\", \"Sorbonne\", \"Cambridge\"]\n})\nhb.ingest(facts, collection=\"facts\", schema=schema)\n\n# Query by slot\nq = hb.query(\"facts\", schema=schema)\nresults = q.find(person=\"Einstein\")  # Find all facts about Einstein\nresults = q.find(relation=\"worked_at\")  # Find all \"worked_at\" relations\n</code></pre>"},{"location":"getting-started/#cross-collection-queries-intersections","title":"Cross-Collection Queries (Intersections)","text":"<p>Collections are isolated by default. Intersections declare relationships between them, enabling cross-collection joins:</p> <pre><code># Two collections: employees and expertise\nhb.ingest(employees_df, collection=\"employees\")\nhb.ingest(expertise_df, collection=\"expertise\")\n\n# Declare how they connect\nhb.intersect(\"employees.employee_id\", \"expertise.subject\")\n\n# Now query across both\nresults = (\n    hb.query(\"employees\")\n    .search(\"senior engineer\")\n    .join(\"expertise\")\n)\n\nfor r in results:\n    if r.is_matched:\n        print(f\"{r.source['name']} knows {r.target['skill']}\")\n</code></pre>"},{"location":"getting-started/#relation-types","title":"Relation Types","text":"Type Matching Use Case <code>identity</code> Exact equality IDs, foreign keys <code>semantic</code> Embedding similarity Text content, fuzzy matching <code>link</code> Explicit mappings Cross-encoding fields (flexible mode) <pre><code># Exact matching (default for EXACT-encoded fields)\nhb.intersect(\"orders.customer_id\", \"customers.id\")\n\n# Semantic matching for text fields\nhb.intersect(\n    \"emails.content\",\n    \"projects.description\",\n    relation=\"semantic\",\n    threshold=0.7\n)\n\n# Flexible mode: cross-encoding intersections via explicit links\nix = hb.intersect_flexible(\"employees.employee_id\", \"expertise.topic\")\nhb.populate_links(ix, links_df, \"emp_id\", \"topic\")\n</code></pre> <p>The idea is to compose together when you need structured, unstructured, or semi-structured behavior, and then chain those together to traverse multiple collections in one query. Need some knowledge graph here? Specify a KnowledgeGraph compound? Need it validate these off a structured schema: use Table. Vector search can be used when needed to handle vagueness and semantics.</p>"},{"location":"getting-started/#chaining-joins","title":"Chaining Joins","text":"<p>Traverse multiple collections in one query:</p> <pre><code>results = (\n    hb.query(\"employees\")\n    .search(\"ML engineer\")\n    .join(\"expertise\")      # employees \u2192 expertise\n    .join(\"projects\")       # expertise \u2192 projects\n    .join(\"budgets\")        # projects \u2192 budgets\n)\n</code></pre> <p>See Intersections API for full documentation.</p>"},{"location":"getting-started/#rag-retrieval-augmented-generation","title":"RAG (Retrieval-Augmented Generation)","text":"<p>Build context for LLMs:</p> <pre><code># Get relevant context\ncontext = hb.get_context(\n    \"What were the Q3 results?\",\n    collection=\"reports\",\n    max_chunks=5,\n    max_tokens=2000\n)\nprint(f\"Retrieved {context.token_count} tokens\")\n\n# Or get a complete answer\nanswer = hb.ask(\n    \"Summarize the quarterly performance\",\n    collection=\"reports\"\n)\nprint(answer.text)\n</code></pre>"},{"location":"getting-started/#using-the-collection-api","title":"Using the Collection API","text":"<p>For fluent, collection-focused operations:</p> <pre><code>employees = hb.collection(\"employees\")\n\n# Check collection\nprint(employees.stats())  # employees: 3 rows, 3 columns\n\n# Query methods chain from collection\nresults = employees.search(\"senior engineers\", top_k=10)\n</code></pre>"},{"location":"getting-started/#async-client","title":"Async Client","text":"<p>For high-throughput applications:</p> <pre><code>from hybi import AsyncHyperBinder\nimport asyncio\n\nasync def main():\n    async with AsyncHyperBinder() as hb:\n        results = await hb.search(\"query\", collection=\"data\")\n        for r in results:\n            print(r['name'])\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/#error-handling","title":"Error Handling","text":"<pre><code>from hybi import (\n    HyperBinderError,\n    CollectionNotFoundError,\n    AuthenticationError,\n)\n\ntry:\n    results = hb.search(\"query\", collection=\"missing\")\nexcept CollectionNotFoundError as e:\n    print(f\"Collection not found: {e}\")\n    print(f\"Suggestion: {e.suggestion}\")\nexcept HyperBinderError as e:\n    print(f\"Error [{e.error_code}]: {e}\")\n</code></pre>"},{"location":"getting-started/#running-the-quickstart-example","title":"Running the Quickstart Example","text":"<p>A complete working example is available in the SDK:</p> <pre><code># Navigate to the SDK directory\ncd sdk\n\n# Run the quickstart example\npython examples/01_quickstart.py\n</code></pre> <p>The quickstart example demonstrates:</p> <ul> <li>Initializing a HyperBinder client</li> <li>Ingesting data from CSV and DataFrames</li> <li>Semantic search queries</li> <li>SQL-like filtering and aggregation</li> <li>Multi-hop traversals</li> </ul> <p>See <code>examples/01_quickstart.py</code> for the full code.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Compose Concepts - Deep dive into the schema system</li> <li>Intersections - Cross-collection query patterns</li> <li>Examples - Complete runnable examples</li> <li>API Reference - Full method documentation</li> </ul>"},{"location":"observability/","title":"Observability","text":"<p>HyperBinder includes built-in observability that you can enable with a single line. When tracing is on, every operation automatically emits events and records timing data. No manual wiring of event buses, subscribers, or trace contexts required.</p> <pre><code>hb.tracing = True\nhb.unbind([1, 2], [\"subject\"], collection=\"knowledge_graph\")\n\nfor event in hb.event_history:\n    print(event.event_type.value, event.data.get(\"duration_ms\"))\n</code></pre>"},{"location":"observability/#enabling-tracing","title":"Enabling Tracing","text":"<p>Tracing is off by default and has zero overhead when disabled. Enable it on any client instance:</p> <pre><code>from hybi import HyperBinder\n\nhb = HyperBinder(url=\"http://localhost:8000\", api_key=\"...\")\n\n# Property setter\nhb.tracing = True\n\n# Or use methods\nhb.enable_tracing()\nhb.disable_tracing()\n</code></pre> <p>Each client has its own tracing state. Enabling tracing on one client does not affect any other.</p> <pre><code>hb1 = HyperBinder(url=\"http://localhost:8000\", api_key=\"...\")\nhb2 = HyperBinder(url=\"http://localhost:8000\", api_key=\"...\")\n\nhb1.tracing = True\nprint(hb2.tracing)  # False\n</code></pre>"},{"location":"observability/#event-history","title":"Event History","text":"<p>When tracing is enabled, the client records up to 1,000 recent events. Each event includes a type, timestamp, and operation-specific data.</p> <pre><code>hb.tracing = True\nhb.unbind([1, 2], [\"subject\"], collection=\"kg\")\n\nfor event in hb.event_history:\n    dur = event.data.get(\"duration_ms\")\n    extra = f\"  ({dur:.1f} ms)\" if dur else \"\"\n    print(f\"{event.event_type.value}{extra}\")\n</code></pre> <p>Output:</p> <pre><code>unbind.started\nunbind.completed  (12.3 ms)\n</code></pre> <p>Every instrumented operation emits a pair of events:</p> Operation Started Event Completed Event Failed Event <code>unbind</code> <code>unbind.started</code> <code>unbind.completed</code> <code>unbind.failed</code> <code>extract</code> <code>extract.started</code> <code>extract.completed</code> <code>extract.failed</code> <code>traverse_fuzzy</code> <code>traverse.started</code> <code>traverse.completed</code> <code>traverse.failed</code> <code>analogy</code> <code>analogy.started</code> <code>analogy.completed</code> <code>analogy.failed</code> <p>Completed events include <code>duration_ms</code> and <code>result_count</code>. Failed events include <code>error</code> and <code>error_type</code>.</p>"},{"location":"observability/#scoped-traces","title":"Scoped Traces","text":"<p>Use <code>hb.trace()</code> to group a sequence of operations into a single trace with nested spans and timing. Tracing is automatically enabled for the duration of the block and restored to its previous state afterwards.</p> <pre><code>with hb.trace(\"find_collaborators\") as t:\n    results = hb.unbind([1], [\"subject\"], collection=\"kg\")\n    neighbors = hb.traverse_fuzzy(\n        \"Einstein\", \"subject\", [\"student_of\"], collection=\"kg\",\n    )\n    analogies = hb.analogy(\"Einstein\", \"Relativity\", \"Darwin\", collection=\"kg\")\n\n# Inspect the span tree\nfor span in t.get_spans():\n    dur = f\"{span.duration_ms:.1f} ms\" if span.duration_ms else \"\"\n    print(f\"  {span.name}  {dur}\")\n</code></pre> <p>Output:</p> <pre><code>  find_collaborators  45.2 ms\n    unbind  8.1 ms\n    traverse_fuzzy  22.4 ms\n    analogy  14.3 ms\n</code></pre> <p>The trace is also stored on the client for later retrieval:</p> <pre><code>print(hb.last_trace.trace_id)\nprint(hb.last_trace.to_dict())  # full serializable representation\n</code></pre>"},{"location":"observability/#nested-traces","title":"Nested Traces","text":"<p>Traces can be nested. Each <code>hb.trace()</code> block creates an independent trace context:</p> <pre><code>with hb.trace(\"outer\") as outer:\n    hb.unbind([1], [\"subject\"], collection=\"kg\")\n    with hb.trace(\"inner\") as inner:\n        hb.unbind([2], [\"object\"], collection=\"kg\")\n\n# Each trace has its own span tree\nprint(len(outer.get_spans()))  # includes outer root + unbind + inner root + unbind\nprint(len(inner.get_spans()))  # includes inner root + unbind\n</code></pre>"},{"location":"observability/#event-callbacks","title":"Event Callbacks","text":"<p>Register a callback to react to events in real time. This is how you connect HyperBinder tracing to external monitoring systems.</p> <pre><code>hb.tracing = True\n\n# Register a callback \u2014 returns an unsubscribe function\nunsub = hb.on_event(lambda e: print(f\"[{e.event_type.value}]\"))\n\nhb.unbind([1], [\"subject\"], collection=\"kg\")\n# prints: [unbind.started]\n# prints: [unbind.completed]\n\n# Stop receiving events\nunsub()\n</code></pre>"},{"location":"observability/#monitoring-failures","title":"Monitoring Failures","text":"<pre><code>failures = []\n\ndef on_failure(event):\n    if \"failed\" in event.event_type.value:\n        failures.append(event)\n\nhb.on_event(on_failure)\n</code></pre>"},{"location":"observability/#logging-integration","title":"Logging Integration","text":"<pre><code>import logging\n\nlog = logging.getLogger(\"hyperbinder.trace\")\n\ndef log_events(event):\n    dur = event.data.get(\"duration_ms\")\n    if dur and dur &gt; 100:\n        log.warning(\"Slow operation: %s (%.0f ms)\", event.event_type.value, dur)\n    elif \"failed\" in event.event_type.value:\n        log.error(\"Operation failed: %s \u2014 %s\", event.event_type.value, event.data.get(\"error\"))\n\nhb.on_event(log_events)\n</code></pre>"},{"location":"observability/#schema-visualization","title":"Schema Visualization","text":"<p>The graph export utilities convert molecule schemas into visual representations. These are standalone functions that work independently of client tracing.</p> <pre><code>from hybi.compose import Triple, Pair, Field, Encoding\nfrom hybi.observe.graph import molecule_to_graph, to_mermaid\n\nschema = Triple(\n    subject=Pair(\n        left=Field(\"entity_type\", encoding=Encoding.EXACT),\n        right=Field(\"entity_name\"),\n    ),\n    predicate=Field(\"relation\", encoding=Encoding.EXACT),\n    object=Field(\"target\"),\n)\n\ngraph = molecule_to_graph(schema)\nprint(to_mermaid(graph))\n</code></pre> <p>The output is a valid Mermaid diagram that you can paste into mermaid.live or render directly in mkdocs:</p> <pre><code>flowchart TB\n    root[\"Triple\"]\n    pair_subject[\"Pair\"]\n    field_entity_type((\"entity_type (EXACT)\"))\n    field_entity_name((\"entity_name (SEMANTIC)\"))\n    field_relation((\"relation (EXACT)\"))\n    field_target((\"target (SEMANTIC)\"))\n    root --&gt;|subject| pair_subject\n    pair_subject --&gt;|left| field_entity_type\n    pair_subject --&gt;|right| field_entity_name\n    root --&gt;|predicate| field_relation\n    root --&gt;|object| field_target</code></pre>"},{"location":"observability/#export-formats","title":"Export Formats","text":"Function Output Use Case <code>to_mermaid()</code> Mermaid flowchart Documentation, markdown rendering <code>to_dot()</code> GraphViz DOT High-quality PDF/SVG via <code>dot</code> CLI <code>to_json_graph()</code> JSON Graph Format (JGF) Programmatic consumption, web UIs"},{"location":"observability/#intersection-registry-graphs","title":"Intersection Registry Graphs","text":"<p>You can also visualize collection relationships from an intersection registry:</p> <pre><code>from hybi.compose.intersections import IntersectionRegistry, Intersection\nfrom hybi.observe.graph import registry_to_graph, to_mermaid\n\nregistry = IntersectionRegistry()\nregistry.add(Intersection(\"users.id\", \"orders.user_id\"))\nregistry.add(Intersection(\"orders.product_id\", \"products.id\"))\n\ngraph = registry_to_graph(registry)\nprint(to_mermaid(graph))\n</code></pre>"},{"location":"observability/#api-reference","title":"API Reference","text":""},{"location":"observability/#client-properties-and-methods","title":"Client Properties and Methods","text":"Member Type Description <code>hb.tracing</code> <code>bool</code> Get or set whether tracing is active <code>hb.enable_tracing()</code> method Enable event emission <code>hb.disable_tracing()</code> method Disable event emission <code>hb.event_history</code> <code>list</code> Most recent events (up to 1,000) <code>hb.on_event(fn)</code> method Register a callback; returns unsubscribe function <code>hb.trace(name)</code> context mgr Scoped trace with nested spans <code>hb.last_trace</code> <code>TraceContext</code> or <code>None</code> Most recent completed trace"},{"location":"observability/#event-object","title":"Event Object","text":"Field Type Description <code>event_type</code> <code>EventType</code> The type of event (enum) <code>timestamp</code> <code>float</code> Unix timestamp <code>trace_id</code> <code>str</code> or <code>None</code> Trace correlation ID <code>data</code> <code>dict</code> Operation-specific metadata"},{"location":"observability/#tracecontext-object","title":"TraceContext Object","text":"Member Type Description <code>trace_id</code> <code>str</code> Unique trace identifier <code>get_spans()</code> method Returns list of <code>TraceSpan</code> objects <code>to_dict()</code> method Serializable dict representation"},{"location":"observability/#graph-export-functions","title":"Graph Export Functions","text":"Function Input Output <code>molecule_to_graph()</code> Molecule schema Graph dict <code>traversal_to_graph()</code> <code>TraversalTrace</code> Graph dict <code>registry_to_graph()</code> <code>IntersectionRegistry</code> Graph dict <code>to_dot(graph)</code> Graph dict DOT string <code>to_mermaid(graph)</code> Graph dict Mermaid string <code>to_json_graph(graph)</code> Graph dict JGF JSON string"},{"location":"observability/#runnable-demo","title":"Runnable Demo","text":"<p>A complete working demo is available at <code>examples/observability_demo.py</code>. It covers all features described on this page and runs without a server using stubbed HTTP responses.</p> <pre><code>python examples/observability_demo.py\n</code></pre>"},{"location":"api/","title":"API Reference","text":"<p>Complete reference for the HyperBinder Python SDK.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>The SDK is organized into these areas:</p> Module Purpose Client Main entry points (<code>HyperBinder</code>, <code>AsyncHyperBinder</code>) Collection Fluent API for collection operations Compose Schema system (Molecules, Compounds, Fields) Models Result types (<code>SearchResult</code>, <code>Context</code>, etc.) Exceptions Error handling"},{"location":"api/#quick-links","title":"Quick Links","text":""},{"location":"api/#client","title":"Client","text":"<ul> <li>HyperBinder - Synchronous client</li> <li>AsyncHyperBinder - Async client</li> <li>Collection - Collection fluent API</li> </ul>"},{"location":"api/#compose-schema-system","title":"Compose (Schema System)","text":"<ul> <li>Molecules - Pair, Triple, Bundle, etc.</li> <li>Compounds - KnowledgeGraph, Catalog, etc.</li> <li>Fields &amp; Encoding - Field configuration</li> <li>Query Builder - ComposeQuery methods</li> </ul>"},{"location":"api/#results-errors","title":"Results &amp; Errors","text":"<ul> <li>Models - SearchResult, Context, Answer, etc.</li> <li>Exceptions - Error handling</li> </ul>"},{"location":"api/#import-patterns","title":"Import Patterns","text":"<pre><code># Main client\nfrom hybi import HyperBinder, AsyncHyperBinder\n\n# Result types\nfrom hybi import SearchResult, Context, Answer\n\n# Compose schemas\nfrom hybi.compose import Triple, Field, Encoding\nfrom hybi.compose import KnowledgeGraph, Catalog\n\n# Exceptions\nfrom hybi import HyperBinderError, CollectionNotFoundError\n</code></pre>"},{"location":"api/aggregate/","title":"<code>POST /aggregate/</code>","text":"<p>Executes a SQL-style GROUP BY + aggregation query against an ingested namespace. Supports SUM, AVG, COUNT, MIN, MAX, STDDEV, and VARIANCE with HAVING and ORDER BY.</p>"},{"location":"api/aggregate/#request","title":"Request","text":"<p>Query Parameters:</p> Parameter Description <code>db_name</code> Name of the database <code>namespace</code> Namespace to query <p>Body:</p> Parameter Type Required Default Description <code>filters</code> object \u274c <code>{}</code> Pre-aggregation exact-match filters. Map of field \u2192 value <code>group_by</code> list of string \u274c \u2014 Fields to group by <code>aggregations</code> list of agg \u2705 \u2014 Aggregation operations to compute <code>having</code> list of having \u274c \u2014 Post-aggregation filters on computed fields <code>order_by</code> list of string \u274c \u2014 Fields to sort results by. Prefix with <code>-</code> for descending <code>limit</code> int \u274c \u2014 Max groups to return <p>Aggregation object:</p> Field Type Required Description <code>field</code> string \u2705 Column to aggregate <code>operation</code> string \u2705 One of: <code>count</code>, <code>sum</code>, <code>avg</code>, <code>min</code>, <code>max</code>, <code>stddev</code>, <code>variance</code> <code>alias</code> string \u2705 Output field name for the computed value <p>HAVING condition object:</p> Field Type Description <code>field</code> string Alias from aggregations to filter on <code>operator</code> string One of: <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>=</code>, <code>!=</code> <code>value</code> float Threshold value"},{"location":"api/aggregate/#behavior","title":"Behavior","text":"<p>Filters are applied before grouping. Aggregations are computed per group. HAVING filters are applied after aggregation. Results can be sorted by any output field using <code>order_by</code> (prefix with <code>-</code> for descending). Non-numeric values are excluded from numeric aggregations silently.</p>"},{"location":"api/aggregate/#responses","title":"Responses","text":""},{"location":"api/aggregate/#200-ok","title":"200 OK","text":"<pre><code>{\n  \"total_groups\": 3,\n  \"execution_time_ms\": 18.2,\n  \"groups\": [\n    { \"department\": \"Engineering\", \"headcount\": 4, \"avg_salary\": 103750.0, \"total_salary\": 415000.0 },\n    { \"department\": \"Finance\",     \"headcount\": 2, \"avg_salary\": 95000.0,  \"total_salary\": 190000.0 },\n    { \"department\": \"Legal\",       \"headcount\": 2, \"avg_salary\": 125000.0, \"total_salary\": 250000.0 }\n  ]\n}\n</code></pre> Field Description <code>total_groups</code> Number of groups returned <code>execution_time_ms</code> Query execution time <code>groups</code> Array of group objects containing group-by fields and computed aggregation values"},{"location":"api/aggregate/#error-responses","title":"Error Responses","text":"Status Condition <code>404</code> Namespace not found <code>500</code> Unexpected internal error"},{"location":"api/aggregate/#notes","title":"Notes","text":"<ul> <li><code>filters</code> uses exact string matching \u2014 it does not support operators.</li> <li>Numeric aggregations (<code>sum</code>, <code>avg</code>, <code>min</code>, <code>max</code>, <code>stddev</code>, <code>variance</code>) silently skip non-numeric values.</li> <li><code>count</code> counts all rows in the group regardless of value type.</li> <li>Use <code>-field</code> prefix in <code>order_by</code> for descending sort (e.g. <code>\"-avg_salary\"</code>).</li> </ul>"},{"location":"api/aggregate/#example","title":"Example","text":"<pre><code>import requests\n\nSERVER_URL = \"http://hbserver:8000\"\nAPI_KEY    = \"yourapitoken\"\n\ndef aggregate(db_name: str, namespace: str, query: dict) -&gt; dict:\n    response = requests.post(\n        f\"{SERVER_URL}/aggregate/\",\n        headers={\"X-API-Key\": API_KEY},\n        params={\"db_name\": db_name, \"namespace\": namespace},\n        json=query,\n    )\n    response.raise_for_status()\n    return response.json()\n\n\nresult = aggregate(\"my_db\", \"employees\", {\n    \"group_by\": [\"department\"],\n    \"aggregations\": [\n        {\"field\": \"id\",     \"operation\": \"count\", \"alias\": \"headcount\"},\n        {\"field\": \"salary\", \"operation\": \"avg\",   \"alias\": \"avg_salary\"},\n        {\"field\": \"salary\", \"operation\": \"sum\",   \"alias\": \"total_salary\"},\n    ],\n    \"having\": [{\"field\": \"headcount\", \"operator\": \"&gt;\", \"value\": 1}],\n    \"order_by\": [\"-avg_salary\"],\n})\nprint(result)\n</code></pre> <p>Expected output:</p> <pre><code>{\n  \"total_groups\": 4,\n  \"execution_time_ms\": 14.3,\n  \"groups\": [\n    { \"department\": \"Legal\",       \"headcount\": 2, \"avg_salary\": 125000.0, \"total_salary\": 250000.0 },\n    { \"department\": \"Engineering\", \"headcount\": 4, \"avg_salary\": 103750.0, \"total_salary\": 415000.0 },\n    { \"department\": \"Finance\",     \"headcount\": 2, \"avg_salary\": 95000.0,  \"total_salary\": 190000.0 },\n    { \"department\": \"HR\",          \"headcount\": 2, \"avg_salary\": 82500.0,  \"total_salary\": 165000.0 }\n  ]\n}\n</code></pre>"},{"location":"api/client/","title":"Client API","text":"<p>The main entry points for interacting with HyperBinder.</p>"},{"location":"api/client/#hyperbinder","title":"HyperBinder","text":"<p>Factory function that returns either a RemoteHyperBinder (client mode) or LocalHyperBinder (local mode).</p> <pre><code>from hybi import HyperBinder\n\n# Client mode: Connect to HyperBinder server\nhb = HyperBinder(\n    url=\"http://localhost:8000\",\n    api_key=\"your-api-key\",  # Or set HYPERBINDER_API_KEY\n    timeout=30.0,\n)\n\n# Local mode: Embedded client (no Docker required)\nhb = HyperBinder(\n    local=True,\n    db_path=\"./my_db\",  # Optional: custom database path\n)\n\n# Use as context manager\nwith HyperBinder() as hb:\n    results = hb.search(\"query\", collection=\"data\")\n</code></pre> <p>Parameters:</p> <ul> <li><code>url</code> (str, optional): URL of the server (e.g., \"http://localhost:8000\"). Defaults to http://localhost:8000 if not local.</li> <li><code>api_key</code> (str, optional): API key for server authentication.</li> <li><code>local</code> (bool): If True, uses embedded LocalHyperBinder (requires 'hyperbinder' pip package).</li> <li><code>**kwargs</code>: Additional arguments passed to the specific client (e.g., db_path for local mode).</li> </ul> <p>Returns: Either a LocalHyperBinder or RemoteHyperBinder instance.</p>"},{"location":"api/client/#remotehyperbinder","title":"RemoteHyperBinder","text":"<p>Direct access to the HTTP client (same as <code>HyperBinder(url=...)</code>).</p> <pre><code>from hybi import RemoteHyperBinder\n\nhb = RemoteHyperBinder(\n    url=\"http://localhost:8000\",\n    api_key=\"your-api-key\",\n)\n</code></pre>"},{"location":"api/client/#localhyperbinder","title":"LocalHyperBinder","text":"<p>Direct access to the embedded client (same as <code>HyperBinder(local=True)</code>).</p> <pre><code>from hybi import LocalHyperBinder\n\nhb = LocalHyperBinder(db_path=\"./my_db\")\n</code></pre> <p>Requirements: Requires the <code>hyperbinder</code> pip package to be installed.</p>"},{"location":"api/client/#hybi.HyperBinder","title":"<code>hybi.HyperBinder(url=None, api_key=None, local=False, **kwargs)</code>","text":"<p>Initialize a HyperBinder client.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Optional[str]</code> <p>URL of the server (e.g., \"http://localhost:8000\").  Defaults to http://localhost:8000 if not local.</p> <code>None</code> <code>api_key</code> <code>Optional[str]</code> <p>Optional API key for server authentication.</p> <code>None</code> <code>local</code> <code>bool</code> <p>If True, uses the embedded LocalHyperBinder (no Docker required).    Requires 'hyperbinder' pip package installed.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the specific client        (e.g., db_path for local mode).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[LocalHyperBinder, HyperBinder]</code> <p>Either a LocalHyperBinder or a RemoteHyperBinder instance.</p>"},{"location":"api/client/#asynchyperbinder","title":"AsyncHyperBinder","text":"<p>Asynchronous client for high-throughput applications.</p> <pre><code>from hybi import AsyncHyperBinder\nimport asyncio\n\nasync def main():\n    async with AsyncHyperBinder() as hb:\n        results = await hb.search(\"query\", collection=\"data\")\n        for r in results:\n            print(r['name'])\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/client/#hybi.AsyncHyperBinder","title":"<code>hybi.AsyncHyperBinder</code>","text":"<p>               Bases: <code>AsyncObserveMixin</code>, <code>AsyncComposeMixin</code>, <code>BaseHyperBinder</code></p> <p>Async HyperBinder client for high-throughput applications.</p> <p>Compose operations (unbind, extract, bundle_search, etc.) are provided by AsyncComposeMixin.</p> <p>Observability operations (traced versions of compose methods, recovery points) are provided by AsyncObserveMixin.</p> Example <p>async with AsyncHyperBinder(\"http://localhost:8000\") as hb:     await hb.ingest(\"data.csv\", collection=\"customers\")     results = await hb.search(\"enterprise AI\", collection=\"customers\")</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.__init__","title":"<code>__init__(url='http://localhost:8000', api_key=None, timeout=30.0, default_collection=None, default_top_k=10, verify_ssl=True, warn_insecure=True, max_retries=3, retry_delay=0.5, join_config=None)</code>","text":"<p>Initialize async HyperBinder client.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Server URL (use https:// in production)</p> <code>'http://localhost:8000'</code> <code>api_key</code> <code>Optional[str]</code> <p>API key for authentication. Can also be set via      HYPERBINDER_API_KEY environment variable.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>Request timeout in seconds</p> <code>30.0</code> <code>default_collection</code> <code>Optional[str]</code> <p>Default collection for operations</p> <code>None</code> <code>default_top_k</code> <code>int</code> <p>Default number of results to return</p> <code>10</code> <code>verify_ssl</code> <code>bool</code> <p>Whether to verify SSL certificates (default True)</p> <code>True</code> <code>warn_insecure</code> <code>bool</code> <p>Warn if using HTTP instead of HTTPS (default True)</p> <code>True</code> <code>max_retries</code> <code>int</code> <p>Maximum retry attempts for transient errors (default 3)</p> <code>3</code> <code>retry_delay</code> <code>float</code> <p>Initial delay between retries in seconds (default 0.5)</p> <code>0.5</code> <code>join_config</code> <code>Optional[JoinConfig]</code> <p>Configuration for join operations (cycle limits, dedup). Defaults to JoinConfig() with sensible production defaults.</p> <code>None</code>"},{"location":"api/client/#hybi.AsyncHyperBinder.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the async HTTP client.</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.ping","title":"<code>ping()</code>  <code>async</code>","text":"<p>Check server health.</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.is_ready","title":"<code>is_ready()</code>  <code>async</code>","text":"<p>Check if server is ready to handle requests.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if server responds with ready status, False otherwise.</p> Note <p>Connection errors return False (server unreachable). Other errors (auth, server errors) are re-raised.</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.collection","title":"<code>collection(name)</code>","text":"<p>Get an async collection object for fluent API access.</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.list_collections","title":"<code>list_collections()</code>  <code>async</code>","text":"<p>List all collections.</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.get_collection_info","title":"<code>get_collection_info(collection=None)</code>  <code>async</code>","text":"<p>Get detailed information about a collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>Optional[str]</code> <p>Collection name (uses default if not specified)</p> <code>None</code> <p>Returns:</p> Type Description <code>CollectionInfo</code> <p>CollectionInfo with type, columns, and capabilities</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.get_collection_stats","title":"<code>get_collection_stats(collection=None, *, use_cache=True)</code>  <code>async</code>","text":"<p>Get detailed statistics about a collection.</p> <p>Returns more detailed information than get_collection_info(), including vector configuration (dimension, seed) and source file metadata.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>Optional[str]</code> <p>Collection name (uses default if not specified)</p> <code>None</code> <code>use_cache</code> <code>bool</code> <p>Whether to use cached stats if available (default True)</p> <code>True</code> <p>Returns:</p> Type Description <code>CollectionStats</code> <p>CollectionStats with full collection details</p> Example <p>stats = await hb.get_collection_stats(\"customers\") print(stats)  # \"customers: 1,000 rows, 5 columns (structured)\" print(f\"Vector dimension: {stats.dimension}\")</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.delete_collection","title":"<code>delete_collection(collection=None)</code>  <code>async</code>","text":"<p>Delete a collection.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>Optional[str]</code> <p>Collection name (uses default if not specified)</p> <code>None</code> <p>Raises:</p> Type Description <code>CollectionNotFoundError</code> <p>If collection doesn't exist</p> <code>HyperBinderError</code> <p>If deletion fails</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.ingest","title":"<code>ingest(source, *, collection=None, dim=1024, seed=42, depth=3, schema=None, vector_col=None, warn_schema_evolution=True)</code>  <code>async</code>","text":"<p>Ingest data into a collection.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[str, Path, DataFrame, List[str]]</code> <p>File path, list of paths, or pandas DataFrame</p> required <code>collection</code> <code>Optional[str]</code> <p>Target collection name</p> <code>None</code> <code>dim</code> <code>int</code> <p>Vector dimension for embeddings (default 512)</p> <code>1024</code> <code>seed</code> <code>int</code> <p>Random seed for reproducibility (default 42)</p> <code>42</code> <code>depth</code> <code>int</code> <p>Hierarchy depth (default 3)</p> <code>3</code> <code>schema</code> <code>Optional[BaseMolecule]</code> <p>Optional Compose schema (Pair, Triple, Record) defining    how data should be encoded. If provided, validates that    the data matches the schema and stores the schema with    the collection for schema-aware queries.</p> <code>None</code> <code>warn_schema_evolution</code> <code>bool</code> <p>Whether to emit SchemaEvolutionWarning    warnings during ingest (default True). Set False to    suppress adaptive-mode schema evolution warning noise.</p> <code>True</code> <p>Returns:</p> Type Description <code>IngestResult</code> <p>IngestResult with ingestion details</p> Example"},{"location":"api/client/#hybi.AsyncHyperBinder.ingest--ingest-with-explicit-triple-schema","title":"Ingest with explicit Triple schema","text":"<p>from hyperbinder.compose import Triple, Field, Encoding</p> <p>schema = Triple(     subject=Field(\"entity\"),     predicate=Field(\"relation\", encoding=Encoding.EXACT),     object=Field(\"target\"), ) await hb.ingest(df, collection=\"knowledge\", schema=schema)</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.search","title":"<code>search(query, *, collection=None, top_k=None, mode=None, filters=None, role=None, slot_filters=None)</code>  <code>async</code>","text":"<p>Universal async search across any collection type.</p> <p>Automatically detects collection type and uses the best search method, or use <code>mode</code> to explicitly choose.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Union[str, Dict[str, Any]]</code> <p>Search query (string for text search, dict for field matching)</p> required <code>collection</code> <code>Optional[str]</code> <p>Collection to search</p> <code>None</code> <code>top_k</code> <code>Optional[int]</code> <p>Number of results to return</p> <code>None</code> <code>mode</code> <code>Optional[str]</code> <p>Search mode - \"auto\" (default), \"structured\", \"semantic\", or \"hybrid\"</p> <code>None</code> <code>filters</code> <code>Optional[List[tuple]]</code> <p>Hard filters as list of (field, op, value) tuples (structured mode)</p> <code>None</code> <code>role</code> <code>Optional[str]</code> <p>Filter by document role e.g. \"paragraph\" (semantic mode)</p> <code>None</code> <code>slot_filters</code> <code>Optional[Dict[str, Any]]</code> <p>Slot value filters e.g. {\"category\": \"Electronics\"} (hybrid mode)</p> <code>None</code> <p>Returns:</p> Type Description <code>List[SearchResult]</code> <p>List of SearchResult objects</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.select","title":"<code>select(collection=None, columns=None, where=None, order_by=None, limit=None, offset=0, distinct=False)</code>  <code>async</code>","text":"<p>Async SQL-like SELECT query.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>Optional[str]</code> <p>Collection to query</p> <code>None</code> <code>columns</code> <code>Optional[List[str]]</code> <p>Columns to select (None = all)</p> <code>None</code> <code>where</code> <code>Optional[List[tuple]]</code> <p>Filter conditions as list of (field, operator, value)</p> <code>None</code> <code>order_by</code> <code>Optional[List[tuple]]</code> <p>Sort order as list of (field, descending)</p> <code>None</code> <code>limit</code> <code>Optional[int]</code> <p>Maximum rows to return</p> <code>None</code> <code>offset</code> <code>int</code> <p>Number of rows to skip</p> <code>0</code> <code>distinct</code> <code>bool</code> <p>Return distinct rows only</p> <code>False</code> <p>Returns:</p> Type Description <code>SelectResult</code> <p>SelectResult with rows</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.aggregate","title":"<code>aggregate(collection=None, group_by=None, aggregations=None, where=None, having=None, order_by=None, limit=None)</code>  <code>async</code>","text":"<p>Async SQL-like AGGREGATE query with GROUP BY.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>Optional[str]</code> <p>Collection to query</p> <code>None</code> <code>group_by</code> <code>Optional[List[str]]</code> <p>Fields to group by</p> <code>None</code> <code>aggregations</code> <code>Optional[List[tuple]]</code> <p>List of (field, operation, alias) tuples          Operations: \"sum\", \"avg\", \"count\", \"min\", \"max\"</p> <code>None</code> <code>where</code> <code>Optional[List[tuple]]</code> <p>Filter conditions before grouping</p> <code>None</code> <code>having</code> <code>Optional[List[tuple]]</code> <p>Filter conditions after grouping</p> <code>None</code> <code>order_by</code> <code>Optional[List[tuple]]</code> <p>Sort order as list of (field, descending) tuples</p> <code>None</code> <code>limit</code> <code>Optional[int]</code> <p>Maximum groups to return</p> <code>None</code> <p>Returns:</p> Type Description <code>AggregateResult</code> <p>AggregateResult with groups</p> Example <p>results = await hb.aggregate(     collection=\"orders\",     group_by=[\"category\"],     aggregations=[(\"amount\", \"sum\", \"total\")],     order_by=[(\"total\", True)],  # Sort by total descending )</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.join","title":"<code>join(left, right, on, join_type='inner', columns=None, limit=None)</code>  <code>async</code>","text":"<p>Async SQL-like JOIN across collections.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>str</code> <p>Left collection name</p> required <code>right</code> <code>str</code> <p>Right collection name</p> required <code>on</code> <code>List[tuple]</code> <p>Join conditions as list of (left_field, operator, right_field)</p> required <code>join_type</code> <code>str</code> <p>Type of join (\"inner\", \"left\", \"right\", \"outer\")</p> <code>'inner'</code> <code>columns</code> <code>Optional[List[str]]</code> <p>Columns to select from result</p> <code>None</code> <code>limit</code> <code>Optional[int]</code> <p>Maximum rows to return</p> <code>None</code> <p>Returns:</p> Type Description <code>JoinResult</code> <p>JoinResult with joined rows</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.multihop","title":"<code>multihop(collection=None, start=None, hops=None, top_k=None)</code>  <code>async</code>","text":"<p>Async multi-hop reasoning query.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>Optional[str]</code> <p>Collection to query</p> <code>None</code> <code>start</code> <code>Optional[Dict[str, Any]]</code> <p>Starting query as field:value dict</p> <code>None</code> <code>hops</code> <code>Optional[List[tuple]]</code> <p>List of (field, value) tuples defining the path</p> <code>None</code> <code>top_k</code> <code>Optional[int]</code> <p>Number of results to return</p> <code>None</code> <p>Returns:</p> Type Description <code>List[MultihopResult]</code> <p>List of MultihopResult with reasoning paths</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.get_context","title":"<code>get_context(query, collection=None, max_chunks=5, max_tokens=2000, auto_detect=True, expand=None, *, expand_reasoning=False, reasoning_hops=2, include_proofs=False)</code>  <code>async</code>","text":"<p>Async get relevant context for LLM consumption.</p> <p>Automatically routes to the appropriate search method: - String query + document collection \u2192 semantic search - String query + structured collection \u2192 structured search - Dict query \u2192 structured field search</p> <p>When <code>expand</code> is provided, the context is enriched with related data from other collections using declared intersections (via hb.intersect()).</p> <p>When <code>expand_reasoning</code> is provided, the context is enriched with inferred relationships discovered via MHV compositional reasoning (requires paid tier).</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Union[str, Dict[str, Any]]</code> <p>The question or query (string for text search, dict for structured queries)</p> required <code>collection</code> <code>Optional[str]</code> <p>Collection to search</p> <code>None</code> <code>max_chunks</code> <code>int</code> <p>Maximum number of chunks to retrieve</p> <code>5</code> <code>max_tokens</code> <code>int</code> <p>Approximate maximum tokens in context</p> <code>2000</code> <code>auto_detect</code> <code>bool</code> <p>If True, detect collection type and use appropriate search</p> <code>True</code> <code>expand</code> <code>Optional[List[Union[str, Dict[str, Any]]]]</code> <p>Optional list of collections to expand into. Each element can be: - A string: collection name (e.g., \"expertise\") - A dict with options: {\"collection\": \"expertise\", \"fields\": [\"skill\"]}</p> <code>None</code> <code>expand_reasoning</code> <code>bool</code> <p>If True, expand context with MHV reasoning inferences</p> <code>False</code> <code>reasoning_hops</code> <code>int</code> <p>Maximum reasoning chain length (default 2)</p> <code>2</code> <code>include_proofs</code> <code>bool</code> <p>Include proof traces for inferred relationships</p> <code>False</code> <p>Returns:</p> Type Description <code>Context</code> <p>Context object with formatted text and source chunks.</p> <code>Context</code> <p>If expand_reasoning=True, context may include inferred relationships.</p> Example"},{"location":"api/client/#hybi.AsyncHyperBinder.get_context--basic-context-retrieval","title":"Basic context retrieval","text":"<p>context = await hb.get_context(\"Alice's team\", collection=\"org\")</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.get_context--with-reasoning-expansion","title":"With reasoning expansion","text":"<p>context = await hb.get_context( ...     \"Alice's team\", ...     collection=\"org\", ...     expand_reasoning=True, ...     reasoning_hops=3, ... )</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.get_context--context-now-includes-inferred-relationships-like","title":"Context now includes inferred relationships like:","text":""},{"location":"api/client/#hybi.AsyncHyperBinder.get_context--alice-reports_toreports_to-bob-2-hop-inference","title":"\"Alice reports_to\u2192reports_to Bob\" (2-hop inference)","text":""},{"location":"api/client/#hybi.AsyncHyperBinder.ask","title":"<code>ask(question, collection=None, top_k=5, role_filter=None)</code>  <code>async</code>","text":"<p>Async end-to-end RAG: retrieve context and generate answer.</p> <p>Note: The LLM model is configured server-side.</p> <p>Parameters:</p> Name Type Description Default <code>question</code> <code>str</code> <p>The question to answer</p> required <code>collection</code> <code>Optional[str]</code> <p>Collection to search</p> <code>None</code> <code>top_k</code> <code>int</code> <p>Number of chunks to retrieve</p> <code>5</code> <code>role_filter</code> <code>Optional[str]</code> <p>Only search in specific role (e.g., \"paragraph\")</p> <code>None</code> <p>Returns:</p> Type Description <code>Answer</code> <p>Answer object with generated text and sources</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.query","title":"<code>query(collection=None, schema=None)</code>","text":"<p>Get a schema-aware async query builder for a collection.</p> <p>AsyncComposeQuery provides a fluent interface for building queries that leverage the collection's schema (if available) for type-safe, slot-based operations.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>Optional[str]</code> <p>Collection name (uses default if not specified)</p> <code>None</code> <code>schema</code> <code>Optional[BaseMolecule]</code> <p>Optional molecule schema for validation. If not provided,    queries will work but without schema validation.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncComposeQuery</code> <p>AsyncComposeQuery builder for the collection</p> Example"},{"location":"api/client/#hybi.AsyncHyperBinder.query--basic-query","title":"Basic query","text":"<p>q = hb.query(\"facts\") results = await q.search(\"enterprise software\")</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.query--with-schema-for-type-safe-slot-access","title":"With schema for type-safe slot access","text":"<p>from hyperbinder.compose import Triple, Field schema = Triple(subject=Field(\"entity\"), ...) q = hb.query(\"facts\", schema=schema) results = await q.find(subject=\"Alice\")</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.populate_links","title":"<code>populate_links(intersection, df, source_column, target_column, *, weight_column=None)</code>  <code>async</code>","text":"<p>Populate a flexible intersection with link data.</p> <p>Links map source field values to target field values, enabling cross-encoding joins. This method replaces any existing links for the intersection.</p> <p>Parameters:</p> Name Type Description Default <code>intersection</code> <code>Intersection</code> <p>The flexible intersection to populate (from intersect_flexible())</p> required <code>df</code> <code>DataFrame</code> <p>DataFrame containing link pairs</p> required <code>source_column</code> <code>str</code> <p>Column name for source values</p> required <code>target_column</code> <code>str</code> <p>Column name for target values</p> required <code>weight_column</code> <code>Optional[str]</code> <p>Optional column for link weights (default 1.0)</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict with ingestion stats: {\"links_created\": int, \"link_collection\": str}</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If intersection is not in FLEXIBLE mode</p> Example"},{"location":"api/client/#hybi.AsyncHyperBinder.populate_links--create-link-data","title":"Create link data","text":"<p>links_df = pd.DataFrame({ ...     \"emp_id\": [\"EMP001\", \"EMP002\", \"EMP003\"], ...     \"topic\": [\"machine learning\", \"databases\", \"cloud computing\"] ... })</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.populate_links--populate-the-intersection","title":"Populate the intersection","text":"<p>result = await hb.populate_links(ix, links_df, \"emp_id\", \"topic\") print(f\"Created {result['links_created']} links\")</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.get_link_bindings","title":"<code>get_link_bindings(link_collection, source_values)</code>  <code>async</code>","text":"<p>Retrieve link mappings for join operations.</p> <p>Internal method used by join() to look up target values for source values.</p> <p>Parameters:</p> Name Type Description Default <code>link_collection</code> <code>str</code> <p>Name of the link collection</p> required <code>source_values</code> <code>List[str]</code> <p>List of source values to look up</p> required <p>Returns:</p> Type Description <code>Dict[str, List[str]]</code> <p>Dict mapping source_value -&gt; [target_values]</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.insert_row","title":"<code>insert_row(collection, *, row, schema)</code>  <code>async</code>","text":"<p>Insert a single row using Row molecule encoding (chain binding).</p> <p>This method uses the dedicated /row/insert/ endpoint which provides: - Chain binding encoding for lossless field extraction - Primary key duplicate detection (raises DuplicateKeyError if exists) - Proper indexing for O(1) PK lookups</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>Collection name</p> required <code>row</code> <code>Dict[str, Any]</code> <p>Row data including primary key</p> required <code>schema</code> <code>BaseMolecule</code> <p>RelationalTable schema (required)</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict with insert status and pk info</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If schema is not RelationalTable or row missing PK</p> <code>DuplicateKeyError</code> <p>If row with same PK already exists</p> Example <p>await hb.insert_row( ...     \"users\", ...     row={\"user_id\": \"U001\", \"email\": \"alice@test.com\", \"name\": \"Alice\"}, ...     schema=users_schema, ... )</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.get_row","title":"<code>get_row(collection, *, pk_field, pk_value)</code>  <code>async</code>","text":"<p>Get a row by primary key (O(1) lookup).</p> <p>Used by RelationalTable for deterministic PK lookups.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>Collection name</p> required <code>pk_field</code> <code>str</code> <p>Name of the primary key field</p> required <code>pk_value</code> <code>Any</code> <p>Value to look up</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Row data dict if found, None if not found</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If multiple rows found (PK must be unique)</p> <code>CollectionNotFoundError</code> <p>If collection doesn't exist</p> Example <p>row = await hb.get_row(\"users\", pk_field=\"user_id\", pk_value=\"U001\") if row: ...     print(row[\"email\"])</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.update","title":"<code>update(collection, *, where, set, schema=None)</code>  <code>async</code>","text":"<p>Atomically update a row matching the where clause.</p> <p>This method performs an atomic update - all fields are updated together in a single operation. For RelationalTable schemas, the row is re-encoded with chain binding to preserve encoding integrity.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>Collection name</p> required <code>where</code> <code>Dict[str, Any]</code> <p>Primary key condition, e.g. {\"user_id\": \"U001\"}</p> required <code>set</code> <code>Dict[str, Any]</code> <p>Fields to update, e.g. {\"email\": \"new@test.com\"}</p> required <code>schema</code> <code>Optional[BaseMolecule]</code> <p>Optional RelationalTable schema for validation and re-encoding</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict with update status and info including old/new values</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If trying to update primary key or missing PK in where</p> <code>CollectionNotFoundError</code> <p>If row not found</p> Example <p>await hb.update( ...     \"users\", ...     where={\"user_id\": \"U001\"}, ...     set={\"email\": \"new@example.com\", \"name\": \"Alice Smith\"}, ...     schema=users_schema, ... )</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.delete","title":"<code>delete(collection, *, where, schema=None)</code>  <code>async</code>","text":"<p>Delete a row matching the where clause.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>Collection name</p> required <code>where</code> <code>Dict[str, Any]</code> <p>Primary key condition, e.g. {\"user_id\": \"U001\"}</p> required <code>schema</code> <code>Optional[BaseMolecule]</code> <p>Optional RelationalTable schema for validation</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict with delete status and info</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If missing PK in where</p> <code>CollectionNotFoundError</code> <p>If row not found</p> Example <p>await hb.delete_row(\"users\", where={\"user_id\": \"U001\"})</p>"},{"location":"api/client/#hybi.AsyncHyperBinder.upsert","title":"<code>upsert(collection, *, row, schema)</code>  <code>async</code>","text":"<p>Insert or update a row.</p> <p>If a row with matching primary key exists, update it. Otherwise, insert as new row.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str</code> <p>Collection name</p> required <code>row</code> <code>Dict[str, Any]</code> <p>Row data including primary key</p> required <code>schema</code> <code>BaseMolecule</code> <p>RelationalTable schema (required for PK info)</p> required <p>Returns:</p> Type Description <code>UpsertResult</code> <p>UpsertResult indicating whether inserted or updated</p> Example <p>await hb.upsert( ...     \"users\", ...     row={\"user_id\": \"U001\", \"email\": \"new@example.com\", \"name\": \"Alice\"}, ...     schema=users_schema, ... )</p>"},{"location":"api/client/#method-categories","title":"Method Categories","text":""},{"location":"api/client/#health-status","title":"Health &amp; Status","text":"Method Description <code>ping()</code> Check server connectivity <code>is_ready()</code> Check if server is ready <code>auth_status()</code> Get authentication status"},{"location":"api/client/#collection-management","title":"Collection Management","text":"Method Description <code>collection(name)</code> Get Collection fluent API <code>list_collections()</code> List all collections with metadata <code>list_collection_names()</code> List collection names only (convenience) <code>get_collection_info(name)</code> Get collection metadata <code>get_collection_stats(name)</code> Get detailed statistics <code>delete_collection(name)</code> Delete a collection"},{"location":"api/client/#data-ingestion","title":"Data Ingestion","text":"Method Description <code>ingest(source, collection, schema)</code> Ingest CSV, DataFrame, or documents"},{"location":"api/client/#search-operations","title":"Search Operations","text":"Method Description <code>search(query, collection)</code> Semantic similarity search <code>bundle_search(values, field, collection)</code> Search similar to any example <code>search_prototype(examples, collection)</code> Search using examples as a prototype <code>analogy(a, b, c, field, collection)</code> Analogical reasoning (A:B :: C:?)"},{"location":"api/client/#sql-like-operations","title":"SQL-like Operations","text":"Method Description <code>select(conditions, collection)</code> Filter with conditions <code>aggregate(group_by, field, function)</code> GROUP BY aggregation <code>join(collection, target, on)</code> Cross-collection JOIN"},{"location":"api/client/#graph-operations","title":"Graph Operations","text":"Method Description <code>multihop(start, path, collection)</code> Multi-hop traversal"},{"location":"api/client/#rag-operations","title":"RAG Operations","text":"Method Description <code>get_context(query, collection)</code> Retrieve context for LLM <code>ask(query, collection)</code> End-to-end RAG query"},{"location":"api/client/#compose-operations","title":"Compose Operations","text":"Method Description <code>query(collection, schema)</code> Get ComposeQuery builder <code>intersect(source, target)</code> Define cross-collection relationship (strict mode) <code>intersect_flexible(source, target)</code> Define cross-encoding relationship (flexible mode) <code>populate_links(intersection, df, ...)</code> Populate links for flexible intersection"},{"location":"api/client/#crud-operations-relationaltable","title":"CRUD Operations (RelationalTable)","text":"<p>These methods provide SQL-like row operations for RelationalTable schemas.</p> Method Description <code>insert_row(collection, row, schema)</code> Insert a single row <code>get_row(collection, pk_field, pk_value)</code> Get row by primary key <code>update(collection, where, set, schema)</code> Update row atomically <code>delete(collection, where, schema)</code> Delete row by primary key <code>upsert(collection, row, schema)</code> Insert or update row <p>Example:</p> <pre><code>from hybi.compose import RelationalTable, Field, Encoding\n\nschema = RelationalTable(\n    columns={\n        \"user_id\": Field(encoding=Encoding.EXACT),\n        \"email\": Field(encoding=Encoding.EXACT),\n        \"name\": Field(encoding=Encoding.SEMANTIC),\n    },\n    primary_key=\"user_id\",\n)\n\n# Insert\nhb.insert_row(\"users\", row={\"user_id\": \"U001\", \"email\": \"a@test.com\", \"name\": \"Alice\"}, schema=schema)\n\n# Get\nrow = hb.get_row(\"users\", pk_field=\"user_id\", pk_value=\"U001\")\n\n# Update\nhb.update(\"users\", where={\"user_id\": \"U001\"}, set={\"email\": \"new@test.com\"}, schema=schema)\n\n# Delete\nhb.delete(\"users\", where={\"user_id\": \"U001\"}, schema=schema)\n\n# Upsert (insert or update)\nhb.upsert(\"users\", row={\"user_id\": \"U001\", \"email\": \"upsert@test.com\", \"name\": \"Alice\"}, schema=schema)\n</code></pre> <p>See RelationalTable for more details on schema definition.</p>"},{"location":"api/collection/","title":"Collection API","text":"<p>Fluent API for collection-focused operations.</p>"},{"location":"api/collection/#collection","title":"Collection","text":"<p>The <code>Collection</code> class provides a fluent interface for working with a specific collection.</p> <pre><code>employees = hb.collection(\"employees\")\n\n# Check status\nprint(employees.stats())\n\n# Query methods\nresults = employees.search(\"senior engineers\")\n</code></pre>"},{"location":"api/collection/#hybi.Collection","title":"<code>hybi.Collection</code>","text":"<p>Fluent API for collection operations.</p> Example <p>customers = hb.collection(\"customers\") customers.ingest(\"data.csv\") results = customers.search(\"enterprise AI\")</p>"},{"location":"api/collection/#hybi.Collection.__init__","title":"<code>__init__(client, name)</code>","text":""},{"location":"api/collection/#hybi.Collection.stats","title":"<code>stats()</code>","text":"<p>Get detailed statistics about this collection.</p> <p>Returns comprehensive information including row count, columns, vector configuration (dimension, seed), and metadata.</p> Example <p>stats = hb.collection(\"customers\").stats() print(stats)  # \"customers: 1,000 rows, 5 columns (structured)\" print(f\"Dimension: {stats.dimension}, Seed: {stats.seed}\")</p>"},{"location":"api/collection/#hybi.Collection.count","title":"<code>count()</code>","text":"<p>Get number of rows in collection.</p>"},{"location":"api/collection/#hybi.Collection.exists","title":"<code>exists()</code>","text":"<p>Check if collection exists.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if collection exists, False if not found.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If server is unreachable.</p> Note <p>Unlike returning False for connection errors, this method raises ConnectionError so you can distinguish between \"collection doesn't exist\" and \"server unreachable\".</p>"},{"location":"api/collection/#hybi.Collection.delete","title":"<code>delete()</code>","text":"<p>Delete this collection.</p> <p>Raises:</p> Type Description <code>HyperBinderError</code> <p>If deletion fails.</p>"},{"location":"api/collection/#hybi.Collection.ingest","title":"<code>ingest(source, **kwargs)</code>","text":"<p>Ingest data into this collection.</p>"},{"location":"api/collection/#hybi.Collection.search","title":"<code>search(query, top_k=None, *, mode=None, filters=None, role=None, slot_filters=None)</code>","text":"<p>Universal search on this collection.</p> <p>Automatically detects collection type and uses the best search method, or use <code>mode</code> to explicitly choose.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Union[str, Dict[str, Any]]</code> <p>Search query (string for text search, dict for field matching)</p> required <code>top_k</code> <code>Optional[int]</code> <p>Number of results to return</p> <code>None</code> <code>mode</code> <code>Optional[str]</code> <p>Search mode - \"auto\" (default), \"structured\", \"semantic\", or \"hybrid\"</p> <code>None</code> <code>filters</code> <code>Optional[List[tuple]]</code> <p>Hard filters for structured mode</p> <code>None</code> <code>role</code> <code>Optional[str]</code> <p>Filter by document role (semantic mode)</p> <code>None</code> <code>slot_filters</code> <code>Optional[Dict[str, Any]]</code> <p>Slot value filters (hybrid mode)</p> <code>None</code> <p>Examples:</p>"},{"location":"api/collection/#hybi.Collection.search--auto-detect-recommended","title":"Auto-detect (recommended)","text":"<p>results = collection.search(\"machine learning\")</p>"},{"location":"api/collection/#hybi.Collection.search--explicit-mode","title":"Explicit mode","text":"<p>results = collection.search(\"AI papers\", mode=\"semantic\")</p>"},{"location":"api/collection/#hybi.Collection.select","title":"<code>select(columns=None, where=None, order_by=None, limit=None, offset=0, distinct=False)</code>","text":"<p>SQL-like SELECT on this collection.</p>"},{"location":"api/collection/#hybi.Collection.aggregate","title":"<code>aggregate(group_by=None, aggregations=None, where=None, having=None, order_by=None, limit=None)</code>","text":"<p>SQL-like AGGREGATE on this collection.</p>"},{"location":"api/collection/#hybi.Collection.join","title":"<code>join(right, on, join_type='inner', columns=None, limit=None)</code>","text":"<p>JOIN this collection with another.</p>"},{"location":"api/collection/#hybi.Collection.multihop","title":"<code>multihop(start=None, hops=None, top_k=None)</code>","text":"<p>Multi-hop reasoning on this collection.</p>"},{"location":"api/collection/#hybi.Collection.get_context","title":"<code>get_context(query, max_chunks=5, max_tokens=2000, auto_detect=True)</code>","text":"<p>Get LLM-ready context from this collection.</p> <p>Automatically routes to the appropriate search: - String query + document collection \u2192 semantic search - Dict query \u2192 structured field search</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Union[str, Dict[str, Any]]</code> <p>Question or query (string for text, dict for structured)</p> required <code>max_chunks</code> <code>int</code> <p>Maximum chunks to retrieve</p> <code>5</code> <code>max_tokens</code> <code>int</code> <p>Approximate maximum tokens</p> <code>2000</code> <code>auto_detect</code> <code>bool</code> <p>If True, detect collection type and use appropriate search</p> <code>True</code>"},{"location":"api/collection/#hybi.Collection.ask","title":"<code>ask(question, top_k=5, role_filter=None)</code>","text":"<p>End-to-end RAG on this collection.</p>"},{"location":"api/collection/#hybi.Collection.query","title":"<code>query(schema=None)</code>","text":"<p>Get a schema-aware query builder for this collection.</p> <p>ComposeQuery provides a fluent interface for building queries that leverage the collection's schema (if available) for type-safe, slot-based operations.</p> <p>If no schema is provided, attempts to load the schema from the collection's stored metadata (set during ingest).</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Optional[BaseMolecule]</code> <p>Optional molecule schema for validation. If not provided,    will try to load from collection stats.</p> <code>None</code> <p>Returns:</p> Type Description <code>ComposeQuery</code> <p>ComposeQuery builder for this collection</p> Example"},{"location":"api/collection/#hybi.Collection.query--auto-loads-schema-if-collection-was-ingested-with-one","title":"Auto-loads schema if collection was ingested with one","text":"<p>q = hb.collection(\"facts\").query() results = q.search(\"enterprise software\")</p>"},{"location":"api/collection/#hybi.Collection.query--explicit-schema-for-type-safe-slot-access","title":"Explicit schema for type-safe slot access","text":"<p>from hyperbinder.compose import Triple, Field schema = Triple(subject=Field(\"entity\"), ...) results = hb.collection(\"facts\").query(schema).find(subject=\"Alice\")</p>"},{"location":"api/collection/#hybi.Collection.get_schema","title":"<code>get_schema()</code>","text":"<p>Get the Compose schema stored with this collection.</p> <p>Returns the schema that was passed during ingest, deserialized back into a molecule object (Triple, Record, etc.).</p> <p>Returns:</p> Type Description <code>Optional[BaseMolecule]</code> <p>BaseMolecule instance or None if no schema was stored.</p> Example <p>schema = hb.collection(\"facts\").get_schema() if schema:     print(f\"Schema: {schema.molecule_type}\")     print(f\"Slots: {schema.slots()}\")</p>"},{"location":"api/collection/#asynccollection","title":"AsyncCollection","text":"<p>Async version of the Collection API.</p>"},{"location":"api/collection/#hybi.AsyncCollection","title":"<code>hybi.AsyncCollection</code>","text":"<p>Async fluent API for collection operations.</p> Example <p>async with AsyncHyperBinder() as hb:     customers = hb.collection(\"customers\")     await customers.ingest(\"data.csv\")     results = await customers.search(\"enterprise AI\")</p>"},{"location":"api/collection/#hybi.AsyncCollection.info","title":"<code>info()</code>  <code>async</code>","text":"<p>Get collection information.</p>"},{"location":"api/collection/#hybi.AsyncCollection.stats","title":"<code>stats()</code>  <code>async</code>","text":"<p>Get detailed statistics about this collection.</p> <p>Returns comprehensive information including row count, columns, vector configuration (dimension, seed), and metadata.</p> Example <p>stats = await hb.collection(\"customers\").stats() print(stats)  # \"customers: 1,000 rows, 5 columns (structured)\" print(f\"Dimension: {stats.dimension}, Seed: {stats.seed}\")</p>"},{"location":"api/collection/#hybi.AsyncCollection.get_schema","title":"<code>get_schema()</code>  <code>async</code>","text":"<p>Get the Compose schema stored with this collection.</p> <p>Returns the schema that was passed during ingest, deserialized back into a molecule object (Triple, Record, etc.).</p> <p>Returns:</p> Type Description <code>Optional[BaseMolecule]</code> <p>BaseMolecule instance or None if no schema was stored.</p> Example <p>schema = await hb.collection(\"facts\").get_schema() if schema:     print(f\"Schema: {schema.molecule_type}\")     print(f\"Slots: {schema.slots()}\")</p>"},{"location":"api/collection/#hybi.AsyncCollection.count","title":"<code>count()</code>  <code>async</code>","text":"<p>Get number of rows in collection.</p>"},{"location":"api/collection/#hybi.AsyncCollection.exists","title":"<code>exists()</code>  <code>async</code>","text":"<p>Check if collection exists.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if collection exists, False if not found.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If server is unreachable.</p> Note <p>Unlike returning False for connection errors, this method raises ConnectionError so you can distinguish between \"collection doesn't exist\" and \"server unreachable\".</p>"},{"location":"api/collection/#hybi.AsyncCollection.delete","title":"<code>delete()</code>  <code>async</code>","text":"<p>Delete this collection.</p> <p>Raises:</p> Type Description <code>HyperBinderError</code> <p>If deletion fails.</p>"},{"location":"api/collection/#hybi.AsyncCollection.ingest","title":"<code>ingest(source, **kwargs)</code>  <code>async</code>","text":"<p>Ingest data into this collection.</p>"},{"location":"api/collection/#hybi.AsyncCollection.search","title":"<code>search(query, top_k=None, *, mode=None, filters=None, role=None, slot_filters=None)</code>  <code>async</code>","text":"<p>Universal async search on this collection.</p> <p>Automatically detects collection type and uses the best search method, or use <code>mode</code> to explicitly choose.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Union[str, Dict[str, Any]]</code> <p>Search query (string for text search, dict for field matching)</p> required <code>top_k</code> <code>Optional[int]</code> <p>Number of results to return</p> <code>None</code> <code>mode</code> <code>Optional[str]</code> <p>Search mode - \"auto\" (default), \"structured\", \"semantic\", or \"hybrid\"</p> <code>None</code> <code>filters</code> <code>Optional[List[tuple]]</code> <p>Hard filters for structured mode</p> <code>None</code> <code>role</code> <code>Optional[str]</code> <p>Filter by document role (semantic mode)</p> <code>None</code> <code>slot_filters</code> <code>Optional[Dict[str, Any]]</code> <p>Slot value filters (hybrid mode)</p> <code>None</code>"},{"location":"api/collection/#hybi.AsyncCollection.select","title":"<code>select(columns=None, where=None, order_by=None, limit=None, offset=0, distinct=False)</code>  <code>async</code>","text":"<p>SQL-like SELECT on this collection.</p>"},{"location":"api/collection/#hybi.AsyncCollection.aggregate","title":"<code>aggregate(group_by=None, aggregations=None, where=None, having=None, order_by=None, limit=None)</code>  <code>async</code>","text":"<p>SQL-like AGGREGATE on this collection.</p>"},{"location":"api/collection/#hybi.AsyncCollection.multihop","title":"<code>multihop(start=None, hops=None, top_k=None)</code>  <code>async</code>","text":"<p>Multi-hop reasoning on this collection.</p>"},{"location":"api/collection/#hybi.AsyncCollection.join","title":"<code>join(right, on, join_type='inner', columns=None, limit=None)</code>  <code>async</code>","text":"<p>JOIN this collection with another.</p>"},{"location":"api/collection/#hybi.AsyncCollection.get_context","title":"<code>get_context(query, max_chunks=5, max_tokens=2000, auto_detect=True)</code>  <code>async</code>","text":"<p>Get LLM-ready context from this collection.</p> <p>Automatically routes to the appropriate search: - String query + document collection \u2192 semantic search - Dict query \u2192 structured field search</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Union[str, Dict[str, Any]]</code> <p>Question or query (string for text, dict for structured)</p> required <code>max_chunks</code> <code>int</code> <p>Maximum chunks to retrieve</p> <code>5</code> <code>max_tokens</code> <code>int</code> <p>Approximate maximum tokens</p> <code>2000</code> <code>auto_detect</code> <code>bool</code> <p>If True, detect collection type and use appropriate search</p> <code>True</code>"},{"location":"api/collection/#hybi.AsyncCollection.ask","title":"<code>ask(question, top_k=5, role_filter=None)</code>  <code>async</code>","text":"<p>End-to-end RAG on this collection.</p>"},{"location":"api/collection/#hybi.AsyncCollection.query","title":"<code>query(schema=None)</code>  <code>async</code>","text":"<p>Get a schema-aware async query builder for this collection.</p> <p>AsyncComposeQuery provides a fluent interface for building queries that leverage the collection's schema (if available) for type-safe, slot-based operations.</p> <p>If no schema is provided, attempts to load the schema from the collection's stored metadata (set during ingest).</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Optional[BaseMolecule]</code> <p>Optional molecule schema for validation. If not provided,    will try to load from collection stats.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncComposeQuery</code> <p>AsyncComposeQuery builder for this collection</p> Example"},{"location":"api/collection/#hybi.AsyncCollection.query--auto-loads-schema-if-collection-was-ingested-with-one","title":"Auto-loads schema if collection was ingested with one","text":"<p>q = await hb.collection(\"facts\").query() results = await q.search(\"enterprise software\")</p>"},{"location":"api/collection/#hybi.AsyncCollection.query--explicit-schema-for-type-safe-slot-access","title":"Explicit schema for type-safe slot access","text":"<p>from hyperbinder.compose import Triple, Field schema = Triple(subject=Field(\"entity\"), ...) q = await hb.collection(\"facts\").query(schema) results = await q.find(subject=\"Alice\")</p>"},{"location":"api/exceptions/","title":"Exceptions","text":"<p>Error classes for handling HyperBinder API errors.</p> <p>All exceptions include:</p> <ul> <li><code>error_code</code>: A unique identifier (e.g., \"HB-E001\")</li> <li><code>suggestion</code>: Actionable fix recommendation</li> <li><code>details</code>: Additional context (optional)</li> </ul>"},{"location":"api/exceptions/#base-exception","title":"Base Exception","text":""},{"location":"api/exceptions/#hyperbindererror","title":"HyperBinderError","text":""},{"location":"api/exceptions/#hybi.HyperBinderError","title":"<code>hybi.HyperBinderError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all HyperBinder errors.</p> <p>Attributes:</p> Name Type Description <code>message</code> <p>Human-readable error description</p> <code>error_code</code> <code>str</code> <p>Machine-readable error code (e.g., \"HB-E001\")</p> <code>details</code> <p>Additional structured error information</p> <code>suggestion</code> <p>Actionable fix suggestion (if available)</p>"},{"location":"api/exceptions/#connection-errors","title":"Connection Errors","text":""},{"location":"api/exceptions/#connectionerror","title":"ConnectionError","text":""},{"location":"api/exceptions/#hybi.ConnectionError","title":"<code>hybi.ConnectionError</code>","text":"<p>               Bases: <code>HyperBinderError</code></p> <p>Failed to connect to HyperBinder server.</p>"},{"location":"api/exceptions/#authentication-errors","title":"Authentication Errors","text":""},{"location":"api/exceptions/#authenticationerror","title":"AuthenticationError","text":""},{"location":"api/exceptions/#hybi.AuthenticationError","title":"<code>hybi.AuthenticationError</code>","text":"<p>               Bases: <code>HyperBinderError</code></p> <p>Authentication failed.</p>"},{"location":"api/exceptions/#collection-errors","title":"Collection Errors","text":""},{"location":"api/exceptions/#collectionnotfounderror","title":"CollectionNotFoundError","text":""},{"location":"api/exceptions/#hybi.CollectionNotFoundError","title":"<code>hybi.CollectionNotFoundError</code>","text":"<p>               Bases: <code>HyperBinderError</code></p> <p>Requested collection does not exist.</p>"},{"location":"api/exceptions/#data-errors","title":"Data Errors","text":""},{"location":"api/exceptions/#ingestionerror","title":"IngestionError","text":""},{"location":"api/exceptions/#hybi.IngestionError","title":"<code>hybi.IngestionError</code>","text":"<p>               Bases: <code>HyperBinderError</code></p> <p>Error during data ingestion.</p>"},{"location":"api/exceptions/#validationerror","title":"ValidationError","text":""},{"location":"api/exceptions/#hybi.ValidationError","title":"<code>hybi.ValidationError</code>","text":"<p>               Bases: <code>HyperBinderError</code></p> <p>Invalid input parameters.</p>"},{"location":"api/exceptions/#query-errors","title":"Query Errors","text":""},{"location":"api/exceptions/#queryerror","title":"QueryError","text":""},{"location":"api/exceptions/#hybi.QueryError","title":"<code>hybi.QueryError</code>","text":"<p>               Bases: <code>HyperBinderError</code></p> <p>Error executing a query.</p>"},{"location":"api/exceptions/#schema-errors","title":"Schema Errors","text":""},{"location":"api/exceptions/#schemaerror","title":"SchemaError","text":"<p>Raised when a query operation is not supported by the schema type.</p>"},{"location":"api/exceptions/#hybi.compose.SchemaError","title":"<code>hybi.compose.SchemaError</code>","text":"<p>               Bases: <code>HyperBinderError</code></p> <p>Operation not supported by schema type.</p>"},{"location":"api/exceptions/#sloterror","title":"SlotError","text":"<p>Raised when an invalid field name is used in a query.</p> <pre><code>from hybi.compose.errors import SlotError\n\n# Raised when querying with invalid field name\ntry:\n    results = q.find(nonexistent_field=\"value\")\nexcept SlotError as e:\n    print(f\"Invalid field: {e.slot}\")\n    print(f\"Valid fields: {e.valid_slots}\")\n</code></pre>"},{"location":"api/exceptions/#hybi.compose.SlotError","title":"<code>hybi.compose.SlotError</code>","text":"<p>               Bases: <code>HyperBinderError</code></p> <p>Invalid slot name for schema.</p>"},{"location":"api/exceptions/#ambiguousfielderror","title":"AmbiguousFieldError","text":"<p>Raised when a field name appears in multiple nested locations.</p> <pre><code>from hybi.compose.errors import AmbiguousFieldError\n\n# If schema has same column name in multiple places\ntry:\n    results = q.find(name=\"Alice\")  # \"name\" exists in both subject and object\nexcept AmbiguousFieldError as e:\n    print(f\"Ambiguous field: {e.field_name}\")\n    print(f\"Found at: {e.locations}\")  # [\"subject.right\", \"object.right\"]\n    print(f\"Use dot notation: q.find(**{{'subject.right': 'Alice'}})\")\n</code></pre>"},{"location":"api/exceptions/#hybi.compose.errors.AmbiguousFieldError","title":"<code>hybi.compose.errors.AmbiguousFieldError</code>","text":"<p>               Bases: <code>HyperBinderError</code></p> <p>Field name is ambiguous (appears in multiple nested paths).</p> <p>Raised when a column name appears in multiple nested structures and the query cannot determine which one to use.</p> Example <p>schema = Triple( ...     subject=Pair(left=Field(\"type\"), right=Field(\"name\")), ...     object=Pair(left=Field(\"type\"), right=Field(\"name\")),  # \"type\" appears twice! ... ) q.find(type=\"Person\")  # Ambiguous - which \"type\"? AmbiguousFieldError: Ambiguous field 'type' - appears in ['subject.left', 'object.left']</p>"},{"location":"api/exceptions/#compose-validation-errors","title":"Compose Validation Errors","text":""},{"location":"api/exceptions/#fieldvalidationerror","title":"FieldValidationError","text":"<p>Raised when field validation fails against data.</p> <pre><code>from hybi.compose.errors import FieldValidationError\n\ntry:\n    hb.ingest(df, collection=\"data\", schema=schema)\nexcept FieldValidationError as e:\n    print(f\"Field: {e.field}\")\n    print(f\"Severity: {e.severity}\")  # \"error\" or \"warning\"\n</code></pre>"},{"location":"api/exceptions/#hybi.compose.FieldValidationError","title":"<code>hybi.compose.FieldValidationError</code>","text":"<p>               Bases: <code>HyperBinderError</code></p> <p>Field validation failed against data.</p>"},{"location":"api/exceptions/#compositionerror","title":"CompositionError","text":"<p>Raised when attempting invalid molecule nesting.</p> <p>Terminal molecules (like Bundle) cannot be nested inside composable molecules because their encoding is not compatible with structured composition.</p> <pre><code>from hybi.compose.errors import CompositionError\n\n# Would be raised for invalid nesting:\n# Triple(subject=Bundle(...), ...)  # Bundle cannot be nested\n</code></pre>"},{"location":"api/exceptions/#hybi.compose.CompositionError","title":"<code>hybi.compose.CompositionError</code>","text":"<p>               Bases: <code>HyperBinderError</code></p> <p>Invalid molecule composition.</p> <p>Raised when attempting to nest terminal molecules (like Record) inside composable molecules (like Triple, Pair, etc.).</p> <p>Terminal molecules use bundle encoding which cannot be composed with chain-based molecules while preserving extraction fidelity.</p>"},{"location":"api/exceptions/#tablecrud-errors","title":"Table/CRUD Errors","text":"<p>These errors are raised by exact lookup operations (<code>get()</code>, <code>update()</code>, <code>delete()</code>).</p>"},{"location":"api/exceptions/#notfounderror","title":"NotFoundError","text":"<p>Raised when <code>get()</code> finds no matching row.</p> <pre><code>from hybi.compose.errors import NotFoundError\n\ntry:\n    user = hb.query(\"users\", schema).get(user_id=\"U999\")\nexcept NotFoundError as e:\n    print(f\"Conditions: {e.conditions}\")\n    print(f\"Collection: {e.collection}\")\n    print(f\"Suggestion: {e.suggestion}\")\n</code></pre>"},{"location":"api/exceptions/#hybi.compose.NotFoundError","title":"<code>hybi.compose.NotFoundError</code>","text":"<p>               Bases: <code>HyperBinderError</code></p> <p>No row matches exact lookup conditions.</p> <p>Raised by get() when the specified key/value combination does not exist in the collection.</p> Example <p>user = table.query(schema).get(user_id=\"U999\") NotFoundError: No row found matching {'user_id': 'U999'}</p>"},{"location":"api/exceptions/#multiplefounderror","title":"MultipleFoundError","text":"<p>Raised when <code>get()</code> finds multiple rows (violates uniqueness).</p> <pre><code>from hybi.compose.errors import MultipleFoundError\n\ntry:\n    user = hb.query(\"users\", schema).get(email=\"duplicate@example.com\")\nexcept MultipleFoundError as e:\n    print(f\"Found {e.count}+ rows matching {e.conditions}\")\n</code></pre>"},{"location":"api/exceptions/#hybi.compose.MultipleFoundError","title":"<code>hybi.compose.MultipleFoundError</code>","text":"<p>               Bases: <code>HyperBinderError</code></p> <p>Multiple rows match exact lookup (violates uniqueness).</p> <p>Raised by get() when more than one row matches the conditions, indicating a schema or data integrity issue.</p> Example <p>user = table.query(schema).get(email=\"alice@example.com\") MultipleFoundError: Multiple rows match {'email': 'alice@example.com'}</p>"},{"location":"api/exceptions/#encodingmismatcherror","title":"EncodingMismatchError","text":"<p>Raised when field encoding is incompatible with the operation.</p> <pre><code>from hybi.compose.errors import EncodingMismatchError\n\ntry:\n    # get() requires EXACT encoding for deterministic lookup\n    user = hb.query(\"users\", schema).get(bio=\"machine learning\")\nexcept EncodingMismatchError as e:\n    print(f\"Field '{e.field}' has {e.actual_encoding} encoding\")\n    print(f\"Required: {e.required_encoding}\")\n</code></pre>"},{"location":"api/exceptions/#hybi.compose.EncodingMismatchError","title":"<code>hybi.compose.EncodingMismatchError</code>","text":"<p>               Bases: <code>HyperBinderError</code></p> <p>Field encoding incompatible with operation.</p> <p>Raised by get() when a field doesn't have EXACT encoding, which is required for deterministic exact lookups.</p> Example <p>user = table.query(schema).get(bio=\"machine learning\") EncodingMismatchError: Field 'bio' has SEMANTIC encoding, get() requires EXACT</p>"},{"location":"api/exceptions/#slotsearchnotsupportederror","title":"SlotSearchNotSupportedError","text":"<p>Raised when slot-specific search is attempted on Table/Bundle schemas.</p> <pre><code>from hybi.compose.errors import SlotSearchNotSupportedError\n\ntry:\n    # Table uses search-optimized encoding - cannot isolate slots\n    results = hb.query(\"users\", schema).search(\"engineer\", slot=\"department\")\nexcept SlotSearchNotSupportedError as e:\n    print(f\"Schema type: {e.schema_type}\")\n    print(f\"Use search() without slot, or filter() for exact matches\")\n</code></pre>"},{"location":"api/exceptions/#hybi.compose.SlotSearchNotSupportedError","title":"<code>hybi.compose.SlotSearchNotSupportedError</code>","text":"<p>               Bases: <code>HyperBinderError</code></p> <p>Slot-specific search not supported for this schema type.</p> <p>Raised when attempting to use search(slot=...) on a Table or Record schema. These schemas use bundle encoding which combines all fields into a single vector, making it impossible to isolate individual slot contributions.</p> Example <p>table.query(schema).search(\"engineering\", slot=\"department\") SlotSearchNotSupportedError: Slot-specific search not supported for Table</p>"},{"location":"api/exceptions/#duplicatekeyerror","title":"DuplicateKeyError","text":"<p>Raised when primary key already exists during ingestion.</p> <pre><code>from hybi.compose.errors import DuplicateKeyError\n\ntry:\n    hb.ingest(df, collection=\"users\", schema=schema)\nexcept DuplicateKeyError as e:\n    print(f\"Duplicate key '{e.key_field}': {e.duplicate_values}\")\n</code></pre>"},{"location":"api/exceptions/#hybi.compose.DuplicateKeyError","title":"<code>hybi.compose.DuplicateKeyError</code>","text":"<p>               Bases: <code>HyperBinderError</code></p> <p>Primary key already exists in collection.</p> <p>Raised during ingestion when attempting to insert a row with a primary key value that already exists in the collection.</p> Example <p>hb.ingest(df_with_duplicate_pk, collection=\"users\", schema=schema) DuplicateKeyError: Duplicate primary key 'user_id': value 'U123' already exists</p>"},{"location":"api/exceptions/#intersection-errors","title":"Intersection Errors","text":"<p>These errors relate to cross-collection join operations.</p>"},{"location":"api/exceptions/#intersectionerror","title":"IntersectionError","text":"<p>Base exception for all intersection operations.</p> <pre><code>from hybi.compose.intersections import IntersectionError\n\ntry:\n    results = hb.query(\"employees\").join(\"projects\")\nexcept IntersectionError as e:\n    print(f\"Join failed: {e}\")\n</code></pre>"},{"location":"api/exceptions/#hybi.compose.intersections.IntersectionError","title":"<code>hybi.compose.intersections.IntersectionError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for intersection operations.</p>"},{"location":"api/exceptions/#nointersectionerror","title":"NoIntersectionError","text":"<p>Raised when no intersection is declared between collections.</p> <pre><code>from hybi.compose.intersections import NoIntersectionError\n\ntry:\n    results = hb.query(\"employees\").join(\"projects\")\nexcept NoIntersectionError as e:\n    print(f\"No intersection between '{e.source_collection}' and '{e.target_collection}'\")\n    print(f\"Collections connected to source: {e.existing_from_source}\")\n    # Fix: hb.intersect(\"employees.&lt;field&gt;\", \"projects.&lt;field&gt;\")\n</code></pre>"},{"location":"api/exceptions/#hybi.compose.intersections.NoIntersectionError","title":"<code>hybi.compose.intersections.NoIntersectionError</code>","text":"<p>               Bases: <code>IntersectionError</code></p> <p>Raised when no intersection is declared between two collections.</p>"},{"location":"api/exceptions/#invalidintersectionerror","title":"InvalidIntersectionError","text":"<p>Raised when an intersection declaration is invalid.</p> <pre><code>from hybi.compose.intersections import InvalidIntersectionError\n\ntry:\n    hb.intersect(\"invalid_format\", \"also_invalid\")\nexcept InvalidIntersectionError as e:\n    print(f\"Invalid intersection: {e}\")\n    print(f\"Field: {e.field}\")  # Which field caused the error\n</code></pre>"},{"location":"api/exceptions/#hybi.compose.intersections.InvalidIntersectionError","title":"<code>hybi.compose.intersections.InvalidIntersectionError</code>","text":"<p>               Bases: <code>IntersectionError</code></p> <p>Raised when an intersection declaration is invalid.</p>"},{"location":"api/exceptions/#ambiguousintersectionerror","title":"AmbiguousIntersectionError","text":"<p>Raised when multiple intersections exist between collections.</p> <pre><code>from hybi.compose.intersections import AmbiguousIntersectionError\n\ntry:\n    results = hb.query(\"employees\").join(\"projects\")\nexcept AmbiguousIntersectionError as e:\n    print(f\"Found {e.count} intersections\")\n    for ix in e.intersections:\n        print(f\"  {ix.source_field} -&gt; {ix.target_field}\")\n    # Fix: .join(\"projects\", on=(\"employee_id\", \"assigned_to\"))\n</code></pre>"},{"location":"api/exceptions/#hybi.compose.intersections.AmbiguousIntersectionError","title":"<code>hybi.compose.intersections.AmbiguousIntersectionError</code>","text":"<p>               Bases: <code>IntersectionError</code></p> <p>Raised when multiple intersections exist between collections.</p>"},{"location":"api/exceptions/#circularjoinerror","title":"CircularJoinError","text":"<p>Raised when a join chain would create a cycle.</p> <pre><code>from hybi.compose.intersections import CircularJoinError\n\ntry:\n    results = (\n        hb.query(\"A\")\n        .join(\"B\")\n        .join(\"C\")\n        .join(\"A\")  # Circular!\n    )\nexcept CircularJoinError as e:\n    print(f\"Circular join to '{e.collection}'\")\n    print(f\"Visited: {e.visited}\")  # ['A', 'B', 'C']\n</code></pre>"},{"location":"api/exceptions/#hybi.compose.intersections.CircularJoinError","title":"<code>hybi.compose.intersections.CircularJoinError</code>","text":"<p>               Bases: <code>IntersectionError</code></p> <p>Raised when a join chain would create a cycle.</p>"},{"location":"api/exceptions/#maxjoindeptherror","title":"MaxJoinDepthError","text":"<p>Raised when join chain exceeds maximum allowed depth.</p> <pre><code>from hybi.compose.intersections import MaxJoinDepthError, JoinConfig\n\ntry:\n    results = hb.query(\"A\").join(\"B\").join(\"C\").join(\"D\").join(\"E\").join(\"F\")\nexcept MaxJoinDepthError as e:\n    print(f\"Exceeded depth {e.max_depth}\")\n    print(f\"Current depth: {e.current_depth}\")\n    # Fix: Increase limit or simplify query\n    # hb = HyperBinder(join_config=JoinConfig(max_join_depth=10))\n</code></pre>"},{"location":"api/exceptions/#hybi.compose.intersections.MaxJoinDepthError","title":"<code>hybi.compose.intersections.MaxJoinDepthError</code>","text":"<p>               Bases: <code>IntersectionError</code></p> <p>Raised when join chain exceeds maximum allowed depth.</p>"},{"location":"api/exceptions/#querystateerror","title":"QueryStateError","text":"<p>Raised when a query operation is called in an invalid state.</p> <pre><code>from hybi.compose.intersections import QueryStateError\n\ntry:\n    # Invalid: search() after join() is not supported\n    results = hb.query(\"employees\").join(\"projects\").search(\"urgent\")\nexcept QueryStateError as e:\n    print(f\"Invalid query state: {e}\")\n</code></pre>"},{"location":"api/exceptions/#hybi.compose.intersections.QueryStateError","title":"<code>hybi.compose.intersections.QueryStateError</code>","text":"<p>               Bases: <code>IntersectionError</code></p> <p>Raised when a query operation is called in an invalid state.</p>"},{"location":"api/exceptions/#error-handling-example","title":"Error Handling Example","text":"<pre><code>from hybi import (\n    HyperBinder,\n    HyperBinderError,\n    CollectionNotFoundError,\n    AuthenticationError,\n)\nfrom hybi.compose.errors import (\n    SchemaError,\n    SlotError,\n    NotFoundError,\n)\nfrom hybi.compose.intersections import (\n    NoIntersectionError,\n    CircularJoinError,\n)\n\ntry:\n    hb = HyperBinder()\n\n    # Query operations\n    results = (\n        hb.query(\"employees\", schema)\n        .find(department=\"Engineering\")\n        .join(\"projects\")\n    )\n\nexcept CollectionNotFoundError as e:\n    print(f\"Collection not found: {e}\")\n    print(f\"Suggestion: {e.suggestion}\")\n\nexcept SlotError as e:\n    print(f\"Invalid field '{e.slot}'\")\n    print(f\"Valid fields: {e.valid_slots}\")\n\nexcept NoIntersectionError as e:\n    print(f\"No intersection declared\")\n    print(f\"Fix: hb.intersect('{e.source_collection}.&lt;field&gt;', '{e.target_collection}.&lt;field&gt;')\")\n\nexcept CircularJoinError as e:\n    print(f\"Circular join detected: {e.visited}\")\n\nexcept NotFoundError as e:\n    print(f\"No row found: {e.conditions}\")\n\nexcept AuthenticationError as e:\n    print(f\"Authentication failed: {e}\")\n\nexcept HyperBinderError as e:\n    print(f\"Error [{e.error_code}]: {e}\")\n    if e.details:\n        print(f\"Details: {e.details}\")\n</code></pre>"},{"location":"api/models/","title":"Data Models","text":"<p>Response types returned by HyperBinder API operations.</p>"},{"location":"api/models/#search-results","title":"Search Results","text":""},{"location":"api/models/#searchresult","title":"SearchResult","text":""},{"location":"api/models/#hybi.SearchResult","title":"<code>hybi.SearchResult</code>  <code>dataclass</code>","text":"<p>A single result from a search query.</p> <p>SearchResult provides dict-like access to row data along with a similarity score indicating match quality. Returned by search(), semantic search, and compose query operations.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Dict[str, Any]</code> <p>Row data as a dictionary mapping column names to values.</p> <code>score</code> <code>float</code> <p>Similarity score between 0.0 and 1.0. Higher values indicate better matches. Comparable across queries on the same collection.</p> <code>id</code> <code>int</code> <p>Internal row identifier. Used for updates and join operations.</p> Example <p>results = hb.search(\"enterprise AI\", collection=\"customers\") for r in results: ...     print(f\"{r['company_name']}: {r.score:.2f}\") ...     # Or access via data dict ...     print(r.data.get('industry', 'Unknown'))</p> See Also <p>MultihopResult: For graph traversal results with path information. ComposeResult: For schema-aware query results.</p>"},{"location":"api/models/#hybi.SearchResult.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Allow dict-like access: result['name']</p>"},{"location":"api/models/#hybi.SearchResult.get","title":"<code>get(key, default=None)</code>","text":"<p>Dict-like get with default.</p>"},{"location":"api/models/#multihopresult","title":"MultihopResult","text":""},{"location":"api/models/#hybi.MultihopResult","title":"<code>hybi.MultihopResult</code>  <code>dataclass</code>","text":"<p>A single result from a multi-hop graph traversal query.</p> <p>Extends SearchResult with path information showing how the result was reached through the graph.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Dict[str, Any]</code> <p>Row data as a dictionary mapping column names to values.</p> <code>score</code> <code>float</code> <p>Cumulative similarity score across all hops (0.0 to 1.0).</p> <code>id</code> <code>int</code> <p>Internal row identifier.</p> <code>path</code> <code>List[Dict[str, Any]]</code> <p>List of intermediate rows traversed to reach this result. Each entry is a dict with the row data at that hop.</p> <code>explanation</code> <code>Optional[PathTrace]</code> <p>Optional PathTrace with detailed execution information. Available when explain=True in the query.</p> Example <p>results = hb.multihop(\"Alice\", [\"manager\", \"department\"], \"employees\") for r in results: ...     print(f\"Found: {r['name']} (score: {r.score:.2f})\") ...     print(f\"  Path: {' -&gt; '.join(p.get('name', '?') for p in r.path)}\")</p> See Also <p>SearchResult: For simple search results without path information. PathTrace: For detailed execution trace.</p>"},{"location":"api/models/#hoptrace","title":"HopTrace","text":""},{"location":"api/models/#hybi.HopTrace","title":"<code>hybi.HopTrace</code>  <code>dataclass</code>","text":"<p>A single hop in a multihop query execution path.</p> <p>Records how many candidates existed before and after applying a filter at each step of a multi-hop traversal.</p> <p>Attributes:</p> Name Type Description <code>field</code> <code>str</code> <p>The column name used for this hop's filter.</p> <code>value</code> <code>Any</code> <p>The value matched or searched for.</p> <code>filter_type</code> <code>str</code> <p>Type of filter applied - \"vector\" for semantic similarity, \"exact\" for exact match, \"range\" for numeric ranges.</p> <code>candidates_before</code> <code>int</code> <p>Number of candidate rows before this filter.</p> <code>candidates_after</code> <code>int</code> <p>Number of rows remaining after this filter.</p> Example <p>result = hb.multihop(\"Alice\", [\"manager\", \"department\"], \"employees\") for hop in result.explanation.hops: ...     print(f\"{hop.field}: {hop.candidates_before} -&gt; {hop.candidates_after}\")</p>"},{"location":"api/models/#pathtrace","title":"PathTrace","text":""},{"location":"api/models/#hybi.PathTrace","title":"<code>hybi.PathTrace</code>  <code>dataclass</code>","text":"<p>Structured explanation of multihop query execution.</p> <p>Provides both machine-readable hop data and human-readable trace lines for debugging and understanding query execution paths.</p> <p>Attributes:</p> Name Type Description <code>initial_filters_matched</code> <code>int</code> <p>Rows matching the initial query before traversal.</p> <code>final_result_count</code> <code>int</code> <p>Number of results after all hops completed.</p> <code>hops</code> <code>List[HopTrace]</code> <p>List of HopTrace objects, one per traversal step.</p> <code>trace</code> <code>List[str]</code> <p>Pre-formatted human-readable explanation lines from the server.</p> Example <p>result = hb.multihop(\"Alice\", [\"manager\", \"department\"], \"employees\") print(result.explanation)  # Full trace print(result.explanation.summary())  # \"10 initial -&gt; 3 results via 2 hops\"</p>"},{"location":"api/models/#hybi.PathTrace.__str__","title":"<code>__str__()</code>","text":"<p>Print the full trace.</p>"},{"location":"api/models/#hybi.PathTrace.summary","title":"<code>summary()</code>","text":"<p>One-line summary of the path.</p>"},{"location":"api/models/#query-results","title":"Query Results","text":""},{"location":"api/models/#selectresult","title":"SelectResult","text":""},{"location":"api/models/#hybi.SelectResult","title":"<code>hybi.SelectResult</code>  <code>dataclass</code>","text":"<p>Result from a SQL-like SELECT query.</p> <p>Iterable collection of rows matching the query conditions. Supports len() and iteration.</p> <p>Attributes:</p> Name Type Description <code>rows</code> <code>List[Dict[str, Any]]</code> <p>List of row dictionaries. Each dict maps column names to values.</p> <code>total_rows</code> <code>int</code> <p>Total matching rows in the collection (may exceed len(rows) if LIMIT was applied).</p> <code>execution_time_ms</code> <code>float</code> <p>Query execution time in milliseconds.</p> Example <p>result = hb.select({\"status\": \"active\"}, collection=\"users\", limit=10) print(f\"Showing {len(result)} of {result.total_rows} total\") for row in result: ...     print(row['email'])</p> See Also <p>AggregateResult: For GROUP BY aggregation queries. JoinResult: For cross-collection JOIN queries.</p>"},{"location":"api/models/#aggregateresult","title":"AggregateResult","text":""},{"location":"api/models/#hybi.AggregateResult","title":"<code>hybi.AggregateResult</code>  <code>dataclass</code>","text":"<p>Result from a GROUP BY aggregation query.</p> <p>Iterable collection of aggregation groups with computed values.</p> <p>Attributes:</p> Name Type Description <code>groups</code> <code>List[Dict[str, Any]]</code> <p>List of group dictionaries. Each contains the group key(s) and aggregated value(s). Keys match the group_by fields; values are named by the aggregation function (e.g., \"count\", \"sum\").</p> <code>total_groups</code> <code>int</code> <p>Total number of distinct groups.</p> <code>execution_time_ms</code> <code>float</code> <p>Query execution time in milliseconds.</p> Example <p>result = hb.aggregate( ...     group_by=\"department\", ...     field=\"salary\", ...     function=\"avg\", ...     collection=\"employees\" ... ) for group in result: ...     print(f\"{group['department']}: ${group['avg']:.2f}\")</p> See Also <p>SelectResult: For filtering without aggregation.</p>"},{"location":"api/models/#joinresult","title":"JoinResult","text":""},{"location":"api/models/#hybi.JoinResult","title":"<code>hybi.JoinResult</code>  <code>dataclass</code>","text":"<p>Result from a cross-collection JOIN query.</p> <p>Contains merged rows from two collections based on matching criteria. Column names are prefixed with collection names to avoid conflicts.</p> <p>Attributes:</p> Name Type Description <code>rows</code> <code>List[Dict[str, Any]]</code> <p>List of joined row dictionaries. Keys are prefixed: \"left_collection.column\" and \"right_collection.column\".</p> <code>total_rows</code> <code>int</code> <p>Total matching joined rows.</p> <code>execution_time_ms</code> <code>float</code> <p>Query execution time in milliseconds.</p> Example <p>result = hb.join( ...     \"employees\", \"departments\", ...     on=(\"dept_id\", \"id\") ... ) for row in result: ...     print(f\"{row['employees.name']} in {row['departments.name']}\")</p> See Also <p>SelectResult: For single-collection queries. Intersection: For declaring joinable relationships.</p>"},{"location":"api/models/#rag-models","title":"RAG Models","text":""},{"location":"api/models/#context","title":"Context","text":""},{"location":"api/models/#hybi.Context","title":"<code>hybi.Context</code>  <code>dataclass</code>","text":"<p>Retrieved context ready for LLM consumption.</p> <p>Assembles relevant chunks into a single text block with token counting for context window management.</p> <p>Attributes:</p> Name Type Description <code>text</code> <code>str</code> <p>Concatenated chunk contents, formatted for LLM input. Use str(context) to get this value.</p> <code>chunks</code> <code>List[Chunk]</code> <p>Individual Chunk objects that comprise this context, ordered by relevance score (highest first).</p> <code>token_count</code> <code>int</code> <p>Estimated token count using tiktoken cl100k_base. Use for context window budgeting.</p> <code>query</code> <code>str</code> <p>The original query used to retrieve this context.</p> Example <p>context = hb.get_context(\"quarterly revenue\", collection=\"reports\") print(f\"Retrieved {len(context.chunks)} chunks ({context.token_count} tokens)\")</p> See Also <p>Chunk: Individual document segments within context. Answer: End-to-end RAG response with generated text.</p>"},{"location":"api/models/#hybi.Context--use-in-llm-prompt","title":"Use in LLM prompt","text":"<p>prompt = f\"Context:\\n{context}\\n\\nQuestion: {context.query}\"</p>"},{"location":"api/models/#answer","title":"Answer","text":""},{"location":"api/models/#hybi.Answer","title":"<code>hybi.Answer</code>  <code>dataclass</code>","text":"<p>Response from an end-to-end RAG query.</p> <p>Contains the generated answer text, source citations, and metadata about the generation process.</p> <p>Attributes:</p> Name Type Description <code>text</code> <code>str</code> <p>The generated answer text. Use str(answer) to get this.</p> <code>sources</code> <code>List[Source]</code> <p>List of Source objects citing the retrieved documents used to generate this answer, ordered by relevance.</p> <code>confidence</code> <code>float</code> <p>Model's confidence in the answer (0.0 to 1.0). Lower values may indicate insufficient context.</p> <code>model</code> <code>str</code> <p>Name of the LLM model used for generation.</p> <code>query</code> <code>str</code> <p>The original question asked.</p> Example <p>answer = hb.ask(\"Summarize the project status\", collection=\"docs\") print(answer) if answer.confidence &lt; 0.7: ...     print(\"Warning: Low confidence answer\") print(f\"\\nGenerated by: {answer.model}\")</p> See Also <p>Context: For retrieving context without generation. Source: Individual citation in the sources list.</p>"},{"location":"api/models/#chunk","title":"Chunk","text":""},{"location":"api/models/#hybi.Chunk","title":"<code>hybi.Chunk</code>  <code>dataclass</code>","text":"<p>A document chunk retrieved for RAG context.</p> <p>Represents a segment of a document that matched the query, with relevance score and source metadata.</p> <p>Attributes:</p> Name Type Description <code>content</code> <code>str</code> <p>The text content of this chunk.</p> <code>score</code> <code>float</code> <p>Relevance score between 0.0 and 1.0.</p> <code>metadata</code> <code>Dict[str, Any]</code> <p>Source information dict. Common keys include: - \"source\": Original filename or URL - \"page\": Page number (for PDFs) - \"section\": Section heading</p> <code>id</code> <code>Optional[int]</code> <p>Optional row identifier in the source collection.</p> Example <p>context = hb.get_context(\"What is RAG?\", collection=\"docs\") for chunk in context.chunks: ...     print(f\"[{chunk.score:.2f}] {chunk.content[:100]}...\") ...     print(f\"  Source: {chunk.metadata.get('source', 'unknown')}\")</p> See Also <p>Context: Assembled context containing multiple chunks. Source: Similar structure used in Answer citations.</p>"},{"location":"api/models/#source","title":"Source","text":""},{"location":"api/models/#hybi.Source","title":"<code>hybi.Source</code>  <code>dataclass</code>","text":"<p>A source reference in a RAG answer.</p> <p>Similar to Chunk but represents a citation in a generated answer, linking claims to their source documents.</p> <p>Attributes:</p> Name Type Description <code>content</code> <code>str</code> <p>The relevant text excerpt from the source.</p> <code>score</code> <code>float</code> <p>Relevance score used when selecting this source (0.0 to 1.0).</p> <code>metadata</code> <code>Dict[str, Any]</code> <p>Source information dict with keys like \"source\", \"page\".</p> Example <p>answer = hb.ask(\"What are the Q3 results?\", collection=\"reports\") print(answer.text) print(\"\\nSources:\") for src in answer.sources: ...     print(f\"  - {src.metadata.get('source')}: {src.content[:50]}...\")</p> See Also <p>Chunk: Similar structure used in Context retrieval. Answer: Contains list of Source citations.</p>"},{"location":"api/models/#collection-models","title":"Collection Models","text":""},{"location":"api/models/#collectioninfo","title":"CollectionInfo","text":""},{"location":"api/models/#hybi.CollectionInfo","title":"<code>hybi.CollectionInfo</code>  <code>dataclass</code>","text":"<p>Basic information about a collection.</p> <p>Lightweight metadata returned by list_collections() and collection checks. For detailed statistics, use CollectionStats via get_collection_stats().</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Collection name (unique identifier).</p> <code>rows</code> <code>int</code> <p>Number of rows in the collection.</p> <code>columns</code> <code>List[str]</code> <p>List of column names.</p> <code>has_semantic</code> <code>bool</code> <p>True if semantic (vector) search is enabled.</p> <code>has_symbolic</code> <code>bool</code> <p>True if symbolic (exact/SQL) queries are enabled.</p> <code>created_at</code> <code>Optional[str]</code> <p>ISO timestamp when collection was created, or None.</p> <code>type</code> <code>str</code> <p>Collection type - \"structured\" for tabular data, \"document\" for ingested documents (PDF, DOCX, etc.).</p> Example <p>collections = hb.list_collections() for c in collections: ...     search_type = \"semantic\" if c.has_semantic else \"symbolic\" ...     print(f\"{c.name}: {c.rows} rows ({search_type})\")</p> See Also <p>CollectionStats: For detailed collection statistics.</p>"},{"location":"api/models/#collectionstats","title":"CollectionStats","text":""},{"location":"api/models/#hybi.CollectionStats","title":"<code>hybi.CollectionStats</code>  <code>dataclass</code>","text":"<p>Detailed statistics about a collection.</p> Example <p>stats = hb.collection(\"customers\").stats() print(stats)  # \"customers: 1000 rows, 5 columns (structured)\" print(f\"Vector dimension: {stats.dimension}\")</p>"},{"location":"api/models/#hybi.CollectionStats--access-stored-compose-schema","title":"Access stored Compose schema","text":"<p>if stats.template_name:     schema = stats.get_schema()     print(f\"Schema type: {schema.molecule_type}\")</p>"},{"location":"api/models/#hybi.CollectionStats.schema_version","title":"<code>schema_version = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Version number for the schema, incremented on each change.</p>"},{"location":"api/models/#hybi.CollectionStats.evolution_mode","title":"<code>evolution_mode = 'adaptive'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Schema evolution mode: 'adaptive', 'strict', or 'locked'.</p>"},{"location":"api/models/#hybi.CollectionStats.reasoning_enabled","title":"<code>reasoning_enabled = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether MHV reasoning is enabled for this collection (paid feature).</p>"},{"location":"api/models/#hybi.CollectionStats.reasoning_config","title":"<code>reasoning_config = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Reasoning engine configuration (dim, size, relations, etc.).</p>"},{"location":"api/models/#hybi.CollectionStats.reasoning_model_version","title":"<code>reasoning_model_version = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Version identifier for the trained reasoning model.</p>"},{"location":"api/models/#hybi.CollectionStats.reasoning_trained_at","title":"<code>reasoning_trained_at = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>ISO timestamp when reasoning model was last trained.</p>"},{"location":"api/models/#hybi.CollectionStats.get_schema","title":"<code>get_schema()</code>","text":"<p>Deserialize stored schema to molecule object.</p> <p>Returns:</p> Type Description <code>Optional[BaseMolecule]</code> <p>BaseMolecule instance (Triple, Record, etc.) or None if no schema stored.</p> Example <p>stats = hb.collection(\"facts\").stats() schema = stats.get_schema() if schema:     print(f\"Schema: {schema.molecule_type}\")     print(f\"Slots: {schema.slots()}\")</p>"},{"location":"api/models/#hybi.CollectionStats.get_evolution_mode","title":"<code>get_evolution_mode()</code>","text":"<p>Get the schema evolution mode as an enum value.</p> <p>Returns:</p> Type Description <code>SchemaEvolution</code> <p>SchemaEvolution enum value</p>"},{"location":"api/models/#hybi.CollectionStats.get_reasoning_config","title":"<code>get_reasoning_config()</code>","text":"<p>Get the reasoning configuration if available.</p> <p>Returns:</p> Type Description <code>Optional[ReasoningConfig]</code> <p>ReasoningConfig instance or None if reasoning not configured.</p> Example <p>stats = hb.collection(\"org\").stats() if stats.reasoning_enabled:     config = stats.get_reasoning_config()     print(f\"Relations: {config.relations}\")</p>"},{"location":"api/models/#ingestresult","title":"IngestResult","text":""},{"location":"api/models/#hybi.IngestResult","title":"<code>hybi.IngestResult</code>  <code>dataclass</code>","text":"<p>Result from a data ingestion operation.</p> <p>Returned by ingest() to confirm successful data loading.</p> <p>Attributes:</p> Name Type Description <code>collection</code> <code>str</code> <p>Name of the collection data was ingested into.</p> <code>rows_ingested</code> <code>int</code> <p>Number of rows successfully ingested.</p> <code>status</code> <code>str</code> <p>Operation status - \"success\", \"partial\", or \"error\".</p> <code>columns</code> <code>List[str]</code> <p>List of column names in the ingested data. Empty list if ingesting documents.</p> <code>message</code> <code>Optional[str]</code> <p>Optional status message with details about the operation, especially useful for partial success or errors.</p> Example <p>result = hb.ingest(\"data.csv\", collection=\"customers\") print(f\"Ingested {result.rows_ingested} rows into {result.collection}\") if result.status != \"success\": ...     print(f\"Warning: {result.message}\")</p> See Also <p>CollectionStats: For checking collection state after ingestion.</p>"},{"location":"api/api-client/analogy/","title":"<code>POST /compose/analogy/{db_name}/{namespace}</code>","text":"<p>Performs analogical search using the parallelogram rule in hypervector space: A : B :: C : ? \u2014 given three known values, find the fourth that completes the analogy.</p>"},{"location":"api/api-client/analogy/#request","title":"Request","text":"<p>Content-Type: <code>application/json</code></p> <p>URL Parameters:</p> Parameter Description <code>db_name</code> Name of the database <code>namespace</code> Namespace within the database <p>Body:</p> Parameter Type Required Default Description <code>a</code> string \u2705 \u2014 First anchor value <code>b</code> string \u2705 \u2014 Second anchor value (relation source) <code>c</code> string \u2705 \u2014 Query value to apply the relation to <code>field_name</code> string \u274c <code>\"value\"</code> Field to search across <code>encoding</code> string \u274c <code>\"semantic\"</code> Encoding type (<code>\"semantic\"</code> recommended) <code>top_k</code> int \u274c <code>10</code> Number of results to return"},{"location":"api/api-client/analogy/#behavior","title":"Behavior","text":"<p>Parallelogram rule \u2014 The relation vector is computed as <code>B - A</code> in hypervector space. This relation is then applied to <code>C</code> to compute the expected answer: <code>D = C + (B - A)</code>. All stored rows are ranked by similarity to the resulting vector.</p> <p>Anchor resolution \u2014 Rows containing A, B, and C in <code>field_name</code> are located in the namespace. If any anchor value is not found, the endpoint returns an empty result with <code>strategy: \"anchor_not_found\"</code>.</p> <p>Deduplication \u2014 Results are deduplicated by field value, and the input values A, B, C are excluded from results.</p> <p>Confidence \u2014 A confidence score is computed from the margin between the top-ranked result and the second-best match. Higher margin = higher confidence.</p>"},{"location":"api/api-client/analogy/#responses","title":"Responses","text":""},{"location":"api/api-client/analogy/#200-ok","title":"200 OK","text":"<pre><code>{\n  \"status\": \"success\",\n  \"query_type\": \"analogy\",\n  \"analogy\": \"Einstein:Relativity :: Darwin:?\",\n  \"field\": \"value\",\n  \"strategy\": \"hypervector\",\n  \"confidence\": 0.842,\n  \"count\": 3,\n  \"results\": [\n    {\n      \"id\": 77,\n      \"score\": 0.913,\n      \"matched_value\": \"Evolution\",\n      \"data\": {\n        \"value\": \"Evolution\",\n        \"author\": \"Darwin\"\n      }\n    }\n  ]\n}\n</code></pre> Field Description <code>analogy</code> String representation of the analogy query <code>field</code> The field searched <code>strategy</code> <code>\"hypervector\"</code> on success, <code>\"anchor_not_found\"</code> if any anchor is missing, <code>\"no_data\"</code> if namespace is empty <code>confidence</code> Score confidence based on margin between top-1 and top-2 results (0.0\u20131.0) <code>count</code> Number of results returned <code>results</code> Array of matches with <code>id</code>, <code>score</code>, <code>matched_value</code>, and full <code>data</code>"},{"location":"api/api-client/analogy/#error-responses","title":"Error Responses","text":"Status Condition <code>404</code> Collection not found <code>500</code> Unexpected internal error"},{"location":"api/api-client/analogy/#notes","title":"Notes","text":"<ul> <li>All three anchor values (A, B, C) must exist as stored field values in the namespace. If any are missing, <code>strategy</code> will be <code>\"anchor_not_found\"</code> and results will be empty.</li> <li><code>\"semantic\"</code> encoding is strongly recommended \u2014 the parallelogram rule relies on meaningful geometric relationships in the embedding space.</li> <li>Low confidence scores suggest the analogy is ambiguous or the relation does not generalise well to C.</li> </ul>"},{"location":"api/api-client/analogy/#example","title":"Example","text":"<pre><code>import requests\n\nSERVER_URL = \"http://hbserver:8000\"\nAPI_KEY    = \"yourapitoken\"\n\ndef analogy_search(db_name: str, namespace: str, a: str, b: str, c: str, field_name: str = \"value\") -&gt; dict:\n    response = requests.post(\n        f\"{SERVER_URL}/compose/analogy/{db_name}/{namespace}\",\n        headers={\"X-API-Key\": API_KEY},\n        json={\n            \"a\":          a,\n            \"b\":          b,\n            \"c\":          c,\n            \"field_name\": field_name,\n            \"encoding\":   \"semantic\",\n            \"top_k\":      5,\n        },\n    )\n    response.raise_for_status()\n    return response.json()\n\n\nresult = analogy_search(\n    db_name=\"my_db\",\n    namespace=\"knowledge_base\",\n    a=\"Einstein\",\n    b=\"Relativity\",\n    c=\"Darwin\",\n)\nprint(result)\n</code></pre> <p>Expected output:</p> <pre><code>{\n  \"status\": \"success\",\n  \"query_type\": \"analogy\",\n  \"analogy\": \"Einstein:Relativity :: Darwin:?\",\n  \"field\": \"value\",\n  \"strategy\": \"hypervector\",\n  \"confidence\": 0.842,\n  \"count\": 1,\n  \"results\": [\n    {\n      \"id\": 77,\n      \"score\": 0.913,\n      \"matched_value\": \"Evolution\",\n      \"data\": { \"value\": \"Evolution\", \"author\": \"Darwin\" }\n    }\n  ]\n}\n</code></pre>"},{"location":"api/api-client/batch_match/","title":"<code>POST /compose/batch_match/{db_name}</code>","text":"<p>Performs cross-collection semantic matching. For each row in a source collection, finds the best matching rows in a target collection based on slot embedding similarity. Enables cross-collection joins via the HDC intersection layer.</p>"},{"location":"api/api-client/batch_match/#request","title":"Request","text":"<p>Content-Type: <code>application/json</code></p> <p>URL Parameters:</p> Parameter Description <code>db_name</code> Name of the database containing both collections <p>Body:</p> Parameter Type Required Default Description <code>source_collection</code> string \u2705 \u2014 Namespace of the source collection <code>source_slot</code> string \u2705 \u2014 Field in the source collection to match on <code>target_collection</code> string \u2705 \u2014 Namespace of the target collection <code>target_slot</code> string \u2705 \u2014 Field in the target collection to match against <code>top_k_per_source</code> int \u274c <code>2</code> Number of top target matches per source row <code>similarity_threshold</code> float \u274c <code>0.5</code> Minimum similarity score to consider a match <code>min_margin</code> float \u274c <code>0.05</code> Minimum score gap between top-1 and top-2 required for a confident match <code>source_row_ids</code> list of int \u274c <code>null</code> Specific source rows to match. If omitted, all rows are used <code>target_row_ids</code> list of int \u274c <code>null</code> Specific target rows to match against. If omitted, all rows are used"},{"location":"api/api-client/batch_match/#behavior","title":"Behavior","text":"<p>Similarity matrix \u2014 Neural embeddings are computed for all unique source and target slot values. A full similarity matrix is built using batch phase similarity, then the top-k matches per source row are extracted.</p> <p>Margin-based NULL detection \u2014 If the gap between the best and second-best match for a source row is below <code>min_margin</code>, the match is flagged as ambiguous. This avoids returning overconfident low-quality joins.</p> <p>Cross-field matching \u2014 Source and target slots can have different names and schemas. Matching is purely based on embedding similarity, enabling joins across heterogeneous collections.</p> <p>Timing \u2014 The response includes a <code>timing</code> object with millisecond breakdowns for embedding and matching phases.</p>"},{"location":"api/api-client/batch_match/#responses","title":"Responses","text":""},{"location":"api/api-client/batch_match/#200-ok","title":"200 OK","text":"<pre><code>{\n  \"status\": \"success\",\n  \"results\": [\n    {\n      \"source_id\": 0,\n      \"target_id\": 14,\n      \"score\": 0.912,\n      \"margin\": 0.143,\n      \"status\": \"matched\"\n    },\n    {\n      \"source_id\": 1,\n      \"target_id\": null,\n      \"score\": 0.431,\n      \"margin\": 0.012,\n      \"status\": \"ambiguous\"\n    }\n  ],\n  \"source_count\": 10,\n  \"target_count\": 50,\n  \"timing\": {\n    \"embed_ms\": 42.1,\n    \"match_ms\": 8.3,\n    \"total_ms\": 51.7\n  }\n}\n</code></pre> <p>Each result contains:</p> Field Description <code>source_id</code> Row ID from the source collection <code>target_id</code> Matched row ID from the target collection, or <code>null</code> if unmatched <code>score</code> Similarity score of the best match <code>margin</code> Score gap between top-1 and top-2 matches <code>status</code> <code>\"matched\"</code>, <code>\"ambiguous\"</code>, or <code>\"unmatched\"</code>"},{"location":"api/api-client/batch_match/#error-responses","title":"Error Responses","text":"Status Condition <code>404</code> Source or target collection not found <code>500</code> Unexpected internal error"},{"location":"api/api-client/batch_match/#notes","title":"Notes","text":"<ul> <li>Both collections must exist within the same <code>db_name</code>.</li> <li>Raise <code>similarity_threshold</code> to reduce false positives; raise <code>min_margin</code> to require more decisive matches.</li> <li><code>source_row_ids</code> and <code>target_row_ids</code> can be used to scope the match to a subset of rows, which significantly reduces compute for large collections.</li> </ul>"},{"location":"api/api-client/batch_match/#example","title":"Example","text":"<pre><code>import requests\n\nSERVER_URL = \"http://hbserver:8000\"\nAPI_KEY    = \"yourapitoken\"\n\ndef batch_match(db_name: str, source_collection: str, source_slot: str,\n                target_collection: str, target_slot: str) -&gt; dict:\n    response = requests.post(\n        f\"{SERVER_URL}/compose/batch_match/{db_name}\",\n        headers={\"X-API-Key\": API_KEY},\n        json={\n            \"source_collection\":  source_collection,\n            \"source_slot\":        source_slot,\n            \"target_collection\":  target_collection,\n            \"target_slot\":        target_slot,\n            \"top_k_per_source\":   2,\n            \"similarity_threshold\": 0.5,\n            \"min_margin\":         0.05,\n        },\n    )\n    response.raise_for_status()\n    return response.json()\n\n\nresult = batch_match(\n    db_name=\"my_db\",\n    source_collection=\"expertise\",\n    source_slot=\"subject\",\n    target_collection=\"employees\",\n    target_slot=\"name\",\n)\nprint(result)\n</code></pre> <p>Expected output:</p> <pre><code>{\n  \"status\": \"success\",\n  \"results\": [\n    { \"source_id\": 0, \"target_id\": 14, \"score\": 0.912, \"margin\": 0.143, \"status\": \"matched\" },\n    { \"source_id\": 1, \"target_id\": null, \"score\": 0.431, \"margin\": 0.012, \"status\": \"ambiguous\" }\n  ],\n  \"source_count\": 10,\n  \"target_count\": 50,\n  \"timing\": { \"embed_ms\": 42.1, \"match_ms\": 8.3, \"total_ms\": 51.7 }\n}\n</code></pre>"},{"location":"api/api-client/build_ingest_data/","title":"<code>POST /build_ingest_data/</code>","text":"<p>Builds a new vector database or appends data to an existing one. Requires sufficient storage quota.</p>"},{"location":"api/api-client/build_ingest_data/#request","title":"Request","text":"<p>Content-Type: <code>multipart/form-data</code></p> Parameter Type Required Default Description <code>file</code> file \u2705 \u2014 CSV file containing rows to ingest <code>dim</code> int \u2705 \u2014 Vector dimensionality (must be 128\u20138192 for new DBs) <code>seed</code> int \u2705 \u2014 Random seed for the HyperBinder index <code>depth</code> int \u2705 \u2014 Index depth parameter <code>db_name</code> string \u274c <code>\"fractal_db\"</code> Name of the database <code>namespace</code> string \u274c <code>\"default\"</code> Namespace within the database <code>vector_col</code> string \u274c <code>null</code> CSV column containing precomputed vectors (JSON arrays). Excluded from metadata fields. <code>dtype_config</code> string \u274c <code>null</code> Optional dtype configuration (currently unused in routing logic) <code>template_name</code> string \u274c <code>null</code> Name of the schema template to associate <code>template_schema</code> string \u274c <code>null</code> JSON string defining schema with <code>semantic_fields</code>. Auto-generated from column names if omitted."},{"location":"api/api-client/build_ingest_data/#behavior","title":"Behavior","text":"<p>Create vs. Append \u2014 If <code>db_name</code> + <code>namespace</code> already exists in the cache, rows are appended with IDs continuing from the last ingested row. If it's new, a fresh index is created.</p> <p>Dimension enforcement \u2014 On append, the <code>dim</code> parameter must match the stored dimension, or the request is rejected.</p> <p>Vector handling has three modes: - <code>generated</code> \u2014 <code>semantic_fields</code> are defined in the schema, so embeddings are computed automatically - <code>precomputed</code> \u2014 <code>vector_col</code> is provided and parsed from the CSV - <code>none</code> \u2014 neither is present</p> <p>Schema inference \u2014 If <code>template_schema</code> is not provided, one is auto-generated from the CSV column names via <code>auto_bundle_schema()</code>.</p>"},{"location":"api/api-client/build_ingest_data/#responses","title":"Responses","text":""},{"location":"api/api-client/build_ingest_data/#200-ok","title":"200 OK","text":"<pre><code>{\n  \"status\": \"success\",\n  \"mode\": \"Create\",\n  \"rows_added\": 150,\n  \"vector_source\": \"generated\",\n  \"namespace\": \"default\"\n}\n</code></pre> Field Description <code>status</code> Always <code>\"success\"</code> on a successful request <code>mode</code> <code>\"Create\"</code> for new DBs, <code>\"Append\"</code> for existing ones <code>rows_added</code> Number of rows ingested from the uploaded CSV <code>vector_source</code> <code>\"generated\"</code>, <code>\"precomputed\"</code>, or <code>\"none\"</code> <code>namespace</code> The namespace used for this ingest"},{"location":"api/api-client/build_ingest_data/#error-responses","title":"Error Responses","text":"Status Condition <code>400</code> Dimension mismatch on append, <code>dim</code> out of range [128, 8192], or malformed <code>vector_col</code> data <code>413</code> Uploaded file exceeds the maximum allowed size <code>500</code> Unexpected internal server error"},{"location":"api/api-client/build_ingest_data/#notes","title":"Notes","text":"<ul> <li><code>db_name</code> and <code>namespace</code> are sanitized via <code>_sanitize_identifier()</code> \u2014 avoid special characters.</li> <li>Row IDs are assigned sequentially and are not reset on append; they continue from the last known <code>next_row_id</code>.</li> <li>Storage usage is recorded after every successful ingest via <code>record_ingest()</code>.</li> </ul>"},{"location":"api/api-client/build_ingest_data/#example","title":"Example","text":"<pre><code>import requests\n\nSERVER_URL = \"http://hbserver:8000\"\nAPI_KEY    = \"yourapitoken\"\n\ndef ingest_csv(filepath: str) -&gt; dict:\n    with open(filepath, \"rb\") as f:\n        response = requests.post(\n            f\"{SERVER_URL}/build_ingest_data/\",\n            headers={\"X-API-Key\": API_KEY},\n            files={\n                \"file\": (filepath.split(\"/\")[-1], f, \"text/csv\")\n            },\n            data={\n                \"dim\":       512,\n                \"seed\":      42,\n                \"depth\":     3,\n                \"db_name\":   \"my_db\",    # optional, defaults to \"fractal_db\"\n                \"namespace\": \"default\",  # optional, defaults to \"default\"\n            },\n        )\n    response.raise_for_status()\n    return response.json()\n\n\nresult = ingest_csv(r\"yourfilepath.csv\")\nprint(result)\n</code></pre> <p>Expected output:</p> <pre><code>{\n  \"status\": \"success\",\n  \"mode\": \"Create\",\n  \"rows_added\": 42,\n  \"vector_source\": \"none\",\n  \"namespace\": \"default\"\n}\n</code></pre>"},{"location":"api/api-client/bundle_search/","title":"<code>POST /compose/bundle_search/{db_name}/{namespace}</code>","text":"<p>Searches using a bundled prototype vector created from multiple values. Returns rows similar to any of the provided values in a single query \u2014 a capability unique to HDC that would otherwise require multiple separate searches.</p>"},{"location":"api/api-client/bundle_search/#request","title":"Request","text":"<p>Content-Type: <code>application/json</code></p> <p>URL Parameters:</p> Parameter Description <code>db_name</code> Name of the database <code>namespace</code> Namespace within the database <p>Body:</p> Parameter Type Required Default Description <code>values</code> list of string \u2705 \u2014 Values to bundle into a prototype query vector <code>field_name</code> string \u274c <code>\"value\"</code> Field to search against <code>encoding</code> string \u274c <code>null</code> Encoding type: <code>\"semantic\"</code>, <code>\"exact\"</code>, or <code>\"numeric\"</code>. Auto-detected from schema if omitted <code>top_k</code> int \u274c <code>10</code> Number of results to return <code>schema_json_data</code> string \u274c <code>null</code> JSON string of the schema. Used for encoding detection if not stored in metadata"},{"location":"api/api-client/bundle_search/#behavior","title":"Behavior","text":"<p>All provided values are encoded and bundled (superimposed) into a single prototype hypervector. The search then finds rows most similar to that prototype \u2014 effectively matching rows that are similar to any of the input values simultaneously.</p> <p>If <code>encoding</code> is <code>\"semantic\"</code>, embeddings for all values are loaded into the cache before the Rust search call, enabling neural similarity matching.</p>"},{"location":"api/api-client/bundle_search/#responses","title":"Responses","text":""},{"location":"api/api-client/bundle_search/#200-ok","title":"200 OK","text":"<pre><code>{\n  \"status\": \"success\",\n  \"query_type\": \"bundle_search\",\n  \"values\": [\"Alice\", \"Bob\", \"Carol\"],\n  \"count\": 3,\n  \"results\": [\n    {\n      \"_id\": 0,\n      \"_score\": 0.923,\n      \"data\": {\n        \"name\": \"Alice\",\n        \"department\": \"Engineering\"\n      }\n    },\n    {\n      \"_id\": 5,\n      \"_score\": 0.871,\n      \"data\": {\n        \"name\": \"Bob\",\n        \"department\": \"Finance\"\n      }\n    }\n  ]\n}\n</code></pre> Field Description <code>values</code> The input values that were bundled <code>count</code> Number of results returned <code>results</code> Array of matches, each with <code>_id</code>, <code>_score</code>, and <code>data</code> fields"},{"location":"api/api-client/bundle_search/#error-responses","title":"Error Responses","text":"Status Condition <code>400</code> No values provided <code>404</code> Collection not found <code>500</code> Unexpected internal error"},{"location":"api/api-client/bundle_search/#notes","title":"Notes","text":"<ul> <li>Bundle search is equivalent to an OR query but operates in a single vector operation \u2014 no repeated queries needed.</li> <li>The more values bundled, the more diffuse the prototype becomes. For highly specific searches, prefer <code>/compose/search_slot</code> with a single query.</li> <li>If <code>encoding</code> and <code>schema_json_data</code> are both omitted and no schema is stored in metadata, encoding defaults to <code>\"semantic\"</code>.</li> </ul>"},{"location":"api/api-client/bundle_search/#example","title":"Example","text":"<pre><code>import requests\n\nSERVER_URL = \"http://hbserver:8000\"\nAPI_KEY    = \"yourapitoken\"\n\ndef bundle_search(db_name: str, namespace: str, values: list, field_name: str = \"value\", top_k: int = 10) -&gt; dict:\n    response = requests.post(\n        f\"{SERVER_URL}/compose/bundle_search/{db_name}/{namespace}\",\n        headers={\"X-API-Key\": API_KEY},\n        json={\n            \"values\":     values,\n            \"field_name\": field_name,\n            \"top_k\":      top_k,\n        },\n    )\n    response.raise_for_status()\n    return response.json()\n\n\nresult = bundle_search(\n    db_name=\"my_db\",\n    namespace=\"default\",\n    values=[\"Alice\", \"Bob\", \"Carol\"],\n    field_name=\"name\",\n    top_k=5,\n)\nprint(result)\n</code></pre> <p>Expected output:</p> <pre><code>{\n  \"status\": \"success\",\n  \"query_type\": \"bundle_search\",\n  \"values\": [\"Alice\", \"Bob\", \"Carol\"],\n  \"count\": 3,\n  \"results\": [\n    { \"_id\": 0, \"_score\": 0.923, \"data\": { \"name\": \"Alice\", \"department\": \"Engineering\" } },\n    { \"_id\": 5, \"_score\": 0.871, \"data\": { \"name\": \"Bob\",   \"department\": \"Finance\" } },\n    { \"_id\": 9, \"_score\": 0.844, \"data\": { \"name\": \"Carol\", \"department\": \"Legal\" } }\n  ]\n}\n</code></pre>"},{"location":"api/api-client/combined/","title":"<code>POST /combined/</code>","text":"<p>Executes a multi-stage pipeline query: JOIN \u2192 SELECT \u2192 AGGREGATE in a single request. Each stage is optional. Stages execute in order and feed their output into the next stage.</p>"},{"location":"api/api-client/combined/#request","title":"Request","text":"<p>Query Parameters:</p> Parameter Description <code>db_name</code> Name of the database <p>Body:</p> Parameter Type Required Default Description <code>namespace</code> string \u274c* \u2014 Namespace for non-join queries. Required if <code>join</code> is not provided <code>join</code> object \u274c \u2014 JOIN configuration (see <code>/join/</code> docs). If omitted, loads <code>namespace</code> directly <code>select</code> object \u274c \u2014 SELECT/filter configuration (see <code>/select/</code> docs) <code>aggregate</code> object \u274c \u2014 AGGREGATE configuration (see <code>/aggregate/</code> docs) <code>convert_types</code> bool \u274c <code>true</code> Auto-convert string values to int/float where possible <p>At least one of <code>join</code>, <code>select</code>, or <code>aggregate</code> must be provided.</p>"},{"location":"api/api-client/combined/#behavior","title":"Behavior","text":"<p>Execution order:</p> <ol> <li>JOIN \u2014 if provided, joins two namespaces into a combined dataset. Otherwise loads <code>namespace</code> directly.</li> <li>SELECT \u2014 if provided, applies WHERE filters, column projection, DISTINCT, ORDER BY, LIMIT, and OFFSET to the current dataset.</li> <li>AGGREGATE \u2014 if provided, applies pre-filters, GROUP BY, aggregations, HAVING, ORDER BY, and LIMIT to produce grouped results.</li> </ol> <p>Each stage receives the output of the previous stage as its input, enabling complex pipelines in a single API call.</p>"},{"location":"api/api-client/combined/#responses","title":"Responses","text":""},{"location":"api/api-client/combined/#200-ok-rows-result-no-aggregate","title":"200 OK \u2014 rows result (no aggregate)","text":"<pre><code>{\n  \"result_type\": \"rows\",\n  \"total_rows\": 5,\n  \"execution_time_ms\": 31.2,\n  \"stages\": [\n    { \"stage\": \"join\",   \"rows_output\": 9,  \"time_ms\": 18.1 },\n    { \"stage\": \"select\", \"rows_output\": 5,  \"time_ms\": 2.4  }\n  ],\n  \"rows\": [\n    { \"emp.name\": \"Alice\", \"emp.department\": \"Engineering\", \"ord.product\": \"Laptop\", \"ord.amount\": 2500 }\n  ]\n}\n</code></pre>"},{"location":"api/api-client/combined/#200-ok-aggregated-result","title":"200 OK \u2014 aggregated result","text":"<pre><code>{\n  \"result_type\": \"aggregated\",\n  \"total_groups\": 3,\n  \"execution_time_ms\": 42.7,\n  \"stages\": [\n    { \"stage\": \"join\",      \"rows_output\": 9, \"time_ms\": 18.1 },\n    { \"stage\": \"select\",    \"rows_output\": 9, \"time_ms\": 1.2  },\n    { \"stage\": \"aggregate\", \"groups\": 3,      \"time_ms\": 0.8  }\n  ],\n  \"groups\": [\n    { \"emp.department\": \"Engineering\", \"order_count\": 4, \"total_spend\": 5270 }\n  ]\n}\n</code></pre> Field Description <code>result_type</code> <code>\"rows\"</code> or <code>\"aggregated\"</code> <code>stages</code> Execution trace showing rows/groups and time per stage <code>rows</code> Present when <code>result_type</code> is <code>\"rows\"</code> <code>groups</code> Present when <code>result_type</code> is <code>\"aggregated\"</code>"},{"location":"api/api-client/combined/#error-responses","title":"Error Responses","text":"Status Condition <code>400</code> No operations specified, or <code>namespace</code> missing when <code>join</code> not provided <code>404</code> Namespace not found <code>500</code> Unexpected internal error"},{"location":"api/api-client/combined/#notes","title":"Notes","text":"<ul> <li>The <code>stages</code> array in the response is useful for performance debugging \u2014 it shows exactly how many rows/groups each stage produced and how long it took.</li> <li><code>convert_types</code> is applied at the end for row results only. Aggregated results are always numeric.</li> <li>ORDER BY in the SELECT stage uses stable sort \u2014 multiple ORDER BY fields are supported.</li> </ul>"},{"location":"api/api-client/combined/#example","title":"Example","text":"<pre><code>import requests\n\nSERVER_URL = \"http://hbserver:8000\"\nAPI_KEY    = \"yourapitoken\"\n\ndef combined(db_name: str, query: dict) -&gt; dict:\n    response = requests.post(\n        f\"{SERVER_URL}/combined/\",\n        headers={\"X-API-Key\": API_KEY},\n        params={\"db_name\": db_name},\n        json=query,\n    )\n    response.raise_for_status()\n    return response.json()\n\n\n# Join employees + orders, filter completed orders, aggregate spend by department\nresult = combined(\"my_db\", {\n    \"join\": {\n        \"left_namespace\":  \"employees\",\n        \"right_namespace\": \"orders\",\n        \"join_type\":       \"inner\",\n        \"join_conditions\": [{\"left_field\": \"id\", \"right_field\": \"employee_id\", \"operator\": \"eq\"}],\n        \"left_prefix\":     \"emp\",\n        \"right_prefix\":    \"ord\",\n    },\n    \"select\": {\n        \"where\": [{\"field\": \"ord.status\", \"operator\": \"eq\", \"value\": \"completed\"}]\n    },\n    \"aggregate\": {\n        \"group_by\": [\"emp.department\"],\n        \"aggregations\": [\n            {\"field\": \"ord.order_id\", \"operation\": \"count\", \"alias\": \"order_count\"},\n            {\"field\": \"ord.amount\",   \"operation\": \"sum\",   \"alias\": \"total_spend\"},\n        ],\n        \"order_by\": [\"-total_spend\"],\n    },\n})\nprint(result)\n</code></pre>"},{"location":"api/api-client/extract/","title":"<code>POST /extract/{db_name}/{namespace}</code>","text":"<p>Retrieves the stored field values for one or more rows by ID. Returns all fields or a specified subset.</p>"},{"location":"api/api-client/extract/#request","title":"Request","text":"<p>Content-Type: <code>application/json</code></p> <p>URL Parameters:</p> Parameter Description <code>db_name</code> Name of the database <code>namespace</code> Namespace within the database <p>Body:</p> Parameter Type Required Default Description <code>row_ids</code> list of int \u2705 \u2014 Row IDs to retrieve <code>fields</code> list of string \u274c <code>null</code> Specific fields to return. If omitted, all fields are returned"},{"location":"api/api-client/extract/#behavior","title":"Behavior","text":"<p>Fetches metadata for the given row IDs directly from RocksDB. Rows with no stored metadata are silently skipped. If <code>fields</code> is provided, only those keys are included in each result object.</p>"},{"location":"api/api-client/extract/#responses","title":"Responses","text":""},{"location":"api/api-client/extract/#200-ok","title":"200 OK","text":"<pre><code>{\n  \"status\": \"success\",\n  \"count\": 2,\n  \"results\": [\n    {\n      \"_id\": 0,\n      \"name\": \"Alice\",\n      \"department\": \"Engineering\",\n      \"role\": \"Senior Engineer\"\n    },\n    {\n      \"_id\": 5,\n      \"name\": \"Bob\",\n      \"department\": \"Finance\",\n      \"role\": \"Analyst\"\n    }\n  ]\n}\n</code></pre> Field Description <code>count</code> Number of rows returned <code>results</code> Array of row objects. Each includes <code>_id</code> plus requested fields"},{"location":"api/api-client/extract/#error-responses","title":"Error Responses","text":"Status Condition <code>404</code> Collection not found <code>500</code> Unexpected internal error"},{"location":"api/api-client/extract/#notes","title":"Notes","text":"<ul> <li>Rows not found in RocksDB are silently omitted from results \u2014 check <code>count</code> to verify all IDs were resolved.</li> <li>This endpoint reads cached field values only. For HDC slot extraction with similarity scores, use <code>/unbind/{db_name}/{namespace}</code>.</li> </ul>"},{"location":"api/api-client/extract/#example","title":"Example","text":"<pre><code>import requests\n\nSERVER_URL = \"http://hbserver:8000\"\nAPI_KEY    = \"yourapitoken\"\n\ndef extract_fields(db_name: str, namespace: str, row_ids: list, fields: list = None) -&gt; dict:\n    payload = {\"row_ids\": row_ids}\n    if fields:\n        payload[\"fields\"] = fields\n\n    response = requests.post(\n        f\"{SERVER_URL}/extract/{db_name}/{namespace}\",\n        headers={\"X-API-Key\": API_KEY},\n        json=payload,\n    )\n    response.raise_for_status()\n    return response.json()\n\n\nresult = extract_fields(\n    db_name=\"my_db\",\n    namespace=\"default\",\n    row_ids=[0, 5, 12],\n    fields=[\"name\", \"department\"],\n)\nprint(result)\n</code></pre> <p>Expected output:</p> <pre><code>{\n  \"status\": \"success\",\n  \"count\": 3,\n  \"results\": [\n    { \"_id\": 0,  \"name\": \"Alice\", \"department\": \"Engineering\" },\n    { \"_id\": 5,  \"name\": \"Bob\",   \"department\": \"Finance\" },\n    { \"_id\": 12, \"name\": \"Carol\", \"department\": \"Legal\" }\n  ]\n}\n</code></pre>"},{"location":"api/api-client/join/","title":"<code>POST /join/</code>","text":"<p>Joins two namespaces within the same database. Supports INNER, LEFT, RIGHT, and FULL OUTER joins with field-level join conditions.</p>"},{"location":"api/api-client/join/#request","title":"Request","text":"<p>Query Parameters:</p> Parameter Description <code>db_name</code> Name of the database containing both namespaces <p>Body:</p> Parameter Type Required Default Description <code>left_namespace</code> string \u2705 \u2014 Left-side namespace <code>right_namespace</code> string \u2705 \u2014 Right-side namespace <code>join_type</code> string \u2705 \u2014 One of: <code>inner</code>, <code>left</code>, <code>right</code>, <code>full</code> <code>join_conditions</code> list \u2705 \u2014 Field pairs to join on <code>left_prefix</code> string \u274c <code>\"\"</code> Prefix for left-side columns in output <code>right_prefix</code> string \u274c <code>\"\"</code> Prefix for right-side columns in output <code>limit</code> int \u274c \u2014 Max rows to return <code>key_separator</code> string \u274c <code>\".\"</code> Separator used when combining prefixed field names <p>Join condition object:</p> Field Type Description <code>left_field</code> string Field name in the left namespace <code>right_field</code> string Field name in the right namespace <code>operator</code> string Join operator \u2014 typically <code>\"eq\"</code>"},{"location":"api/api-client/join/#behavior","title":"Behavior","text":"<p>Performs the join in Rust across both namespaces using RocksDB row metadata. Both namespaces must exist within the same <code>db_name</code>. Column name conflicts between namespaces are resolved using <code>left_prefix</code> and <code>right_prefix</code>.</p>"},{"location":"api/api-client/join/#responses","title":"Responses","text":""},{"location":"api/api-client/join/#200-ok","title":"200 OK","text":"<pre><code>{\n  \"total_rows\": 5,\n  \"execution_time_ms\": 24.1,\n  \"rows\": [\n    {\n      \"emp.id\":         \"E001\",\n      \"emp.name\":       \"Alice\",\n      \"emp.department\": \"Engineering\",\n      \"ord.order_id\":   \"O001\",\n      \"ord.product\":    \"Laptop\",\n      \"ord.amount\":     \"2500\"\n    }\n  ]\n}\n</code></pre> Field Description <code>total_rows</code> Number of joined rows returned <code>execution_time_ms</code> Query execution time <code>rows</code> Array of joined row objects"},{"location":"api/api-client/join/#error-responses","title":"Error Responses","text":"Status Condition <code>404</code> One or both namespaces not found <code>500</code> Unexpected internal error"},{"location":"api/api-client/join/#notes","title":"Notes","text":"<ul> <li>Both namespaces must be in the same <code>db_name</code>.</li> <li>Use <code>left_prefix</code> and <code>right_prefix</code> to avoid column name collisions.</li> <li>INNER join returns only rows with matches in both sides.</li> <li>LEFT join returns all left rows, with nulls for unmatched right rows.</li> </ul>"},{"location":"api/api-client/join/#example","title":"Example","text":"<pre><code>import requests\n\nSERVER_URL = \"http://hbserver:8000\"\nAPI_KEY    = \"yourapitoken\"\n\ndef join(db_name: str, query: dict) -&gt; dict:\n    response = requests.post(\n        f\"{SERVER_URL}/join/\",\n        headers={\"X-API-Key\": API_KEY},\n        params={\"db_name\": db_name},\n        json=query,\n    )\n    response.raise_for_status()\n    return response.json()\n\n\nresult = join(\"my_db\", {\n    \"left_namespace\":  \"employees\",\n    \"right_namespace\": \"orders\",\n    \"join_type\":       \"inner\",\n    \"join_conditions\": [\n        {\"left_field\": \"id\", \"right_field\": \"employee_id\", \"operator\": \"eq\"}\n    ],\n    \"left_prefix\":  \"emp\",\n    \"right_prefix\": \"ord\",\n})\nprint(result)\n</code></pre> <p>Expected output:</p> <pre><code>{\n  \"total_rows\": 9,\n  \"execution_time_ms\": 21.3,\n  \"rows\": [\n    { \"emp.id\": \"E001\", \"emp.name\": \"Alice\", \"ord.order_id\": \"O001\", \"ord.product\": \"Laptop\" }\n  ]\n}\n</code></pre>"},{"location":"api/api-client/links_ingest/","title":"<code>POST /compose/links/ingest</code>","text":"<p>Stores explicit value mappings between a source field and a target field in a named link collection. Used to define cross-encoding joins where fields have different types or structures. Each call replaces all existing links for the given collection.</p>"},{"location":"api/api-client/links_ingest/#request","title":"Request","text":"<p>Content-Type: <code>application/json</code></p> <p>Body:</p> Parameter Type Required Description <code>link_collection</code> string \u2705 Name of the link collection to create or replace <code>source_collection</code> string \u2705 Name of the source data collection <code>source_field</code> string \u2705 Field name in the source collection <code>target_collection</code> string \u2705 Name of the target data collection <code>target_field</code> string \u2705 Field name in the target collection <code>links</code> list of objects \u2705 List of value mappings. Each entry: <code>{\"source_value\": ..., \"target_value\": ..., \"weight\": ...}</code> <p>Link object:</p> Field Type Required Description <code>source_value</code> string \u2705 Value from the source field <code>target_value</code> string \u2705 Corresponding value in the target field <code>weight</code> float \u274c Optional weight for the link (stored but not currently used in matching)"},{"location":"api/api-client/links_ingest/#behavior","title":"Behavior","text":"<p>Both forward (<code>source \u2192 target</code>) and reverse (<code>target \u2192 source</code>) mappings are built and stored in memory. Any existing links for <code>link_collection</code> are completely replaced on each call. Links with missing <code>source_value</code> or <code>target_value</code> are silently skipped.</p>"},{"location":"api/api-client/links_ingest/#responses","title":"Responses","text":""},{"location":"api/api-client/links_ingest/#200-ok","title":"200 OK","text":"<pre><code>{\n  \"status\": \"success\",\n  \"links_created\": 42,\n  \"link_collection\": \"expertise_to_employees\"\n}\n</code></pre> Field Description <code>links_created</code> Total number of link entries processed <code>link_collection</code> Name of the collection that was created or replaced"},{"location":"api/api-client/links_ingest/#error-responses","title":"Error Responses","text":"Status Condition <code>500</code> Unexpected internal error"},{"location":"api/api-client/links_ingest/#notes","title":"Notes","text":"<ul> <li>Link storage is currently in-memory and will not persist across server restarts.</li> <li>Each call fully replaces the existing link collection \u2014 there is no partial update.</li> <li>Use <code>/compose/links/match</code> to query stored links, and <code>/compose/links/{link_collection}</code> to inspect them.</li> </ul>"},{"location":"api/api-client/links_ingest/#example","title":"Example","text":"<pre><code>import requests\n\nSERVER_URL = \"http://hbserver:8000\"\nAPI_KEY    = \"yourapitoken\"\n\ndef ingest_links(link_collection: str, links: list) -&gt; dict:\n    response = requests.post(\n        f\"{SERVER_URL}/compose/links/ingest\",\n        headers={\"X-API-Key\": API_KEY},\n        json={\n            \"link_collection\":  link_collection,\n            \"source_collection\": \"expertise\",\n            \"source_field\":      \"subject\",\n            \"target_collection\": \"employees\",\n            \"target_field\":      \"name\",\n            \"links\":             links,\n        },\n    )\n    response.raise_for_status()\n    return response.json()\n\n\nresult = ingest_links(\n    link_collection=\"expertise_to_employees\",\n    links=[\n        {\"source_value\": \"machine learning\", \"target_value\": \"Alice\"},\n        {\"source_value\": \"machine learning\", \"target_value\": \"Bob\"},\n        {\"source_value\": \"finance\",          \"target_value\": \"Carol\"},\n    ],\n)\nprint(result)\n</code></pre> <p>Expected output:</p> <pre><code>{\n  \"status\": \"success\",\n  \"links_created\": 3,\n  \"link_collection\": \"expertise_to_employees\"\n}\n</code></pre>"},{"location":"api/api-client/links_list/","title":"<code>GET /compose/links/{link_collection}</code>","text":"<p>Lists stored links in a collection. Intended for debugging and inspection.</p>"},{"location":"api/api-client/links_list/#request","title":"Request","text":"<p>URL Parameters:</p> Parameter Description <code>link_collection</code> Name of the link collection to inspect <p>Query Parameters:</p> Parameter Type Required Default Description <code>limit</code> int \u274c <code>100</code> Maximum number of links to return"},{"location":"api/api-client/links_list/#behavior","title":"Behavior","text":"<p>Returns up to <code>limit</code> forward links from the collection as <code>{source_value, target_value}</code> pairs. Also returns the total number of links stored across all source values. If the collection does not exist, returns an empty list with <code>total: 0</code>.</p>"},{"location":"api/api-client/links_list/#responses","title":"Responses","text":""},{"location":"api/api-client/links_list/#200-ok","title":"200 OK","text":"<pre><code>{\n  \"link_collection\": \"expertise_to_employees\",\n  \"links\": [\n    { \"source_value\": \"machine learning\", \"target_value\": \"Alice\" },\n    { \"source_value\": \"machine learning\", \"target_value\": \"Bob\" },\n    { \"source_value\": \"finance\",          \"target_value\": \"Carol\" }\n  ],\n  \"total\": 3\n}\n</code></pre> Field Description <code>link_collection</code> Name of the collection inspected <code>links</code> Array of <code>{source_value, target_value}</code> pairs, up to <code>limit</code> <code>total</code> Total number of forward links in the collection"},{"location":"api/api-client/links_list/#error-responses","title":"Error Responses","text":"Status Condition <code>500</code> Unexpected internal error"},{"location":"api/api-client/links_list/#notes","title":"Notes","text":"<ul> <li>Only forward links are listed. To inspect reverse mappings, use <code>/compose/links/match</code> with <code>direction: \"reverse\"</code>.</li> <li><code>total</code> reflects the full count, even if <code>limit</code> truncates the returned list.</li> <li>This endpoint requires no auth body \u2014 it is a simple GET with URL and query params only.</li> </ul>"},{"location":"api/api-client/links_list/#example","title":"Example","text":"<pre><code>import requests\n\nSERVER_URL = \"http://hbserver:8000\"\nAPI_KEY    = \"yourapitoken\"\n\ndef list_links(link_collection: str, limit: int = 100) -&gt; dict:\n    response = requests.get(\n        f\"{SERVER_URL}/compose/links/{link_collection}\",\n        headers={\"X-API-Key\": API_KEY},\n        params={\"limit\": limit},\n    )\n    response.raise_for_status()\n    return response.json()\n\n\nresult = list_links(\"expertise_to_employees\", limit=50)\nprint(result)\n</code></pre> <p>Expected output:</p> <pre><code>{\n  \"link_collection\": \"expertise_to_employees\",\n  \"links\": [\n    { \"source_value\": \"machine learning\", \"target_value\": \"Alice\" },\n    { \"source_value\": \"machine learning\", \"target_value\": \"Bob\" },\n    { \"source_value\": \"finance\",          \"target_value\": \"Carol\" }\n  ],\n  \"total\": 3\n}\n</code></pre>"},{"location":"api/api-client/links_match/","title":"<code>POST /compose/links/match</code>","text":"<p>Looks up linked values for a list of source values using a stored link collection. Supports both forward (<code>source \u2192 target</code>) and reverse (<code>target \u2192 source</code>) lookups.</p>"},{"location":"api/api-client/links_match/#request","title":"Request","text":"<p>Content-Type: <code>application/json</code></p> <p>Body:</p> Parameter Type Required Default Description <code>link_collection</code> string \u2705 \u2014 Name of the link collection to query <code>source_values</code> list of string \u2705 \u2014 Values to look up <code>direction</code> string \u274c <code>\"forward\"</code> <code>\"forward\"</code> for source \u2192 target, <code>\"reverse\"</code> for target \u2192 source"},{"location":"api/api-client/links_match/#behavior","title":"Behavior","text":"<p>For each value in <code>source_values</code>, returns the list of linked values from the stored mapping. Values with no links return an empty list. The link collection must have been previously created via <code>/compose/links/ingest</code>.</p>"},{"location":"api/api-client/links_match/#responses","title":"Responses","text":""},{"location":"api/api-client/links_match/#200-ok","title":"200 OK","text":"<pre><code>{\n  \"status\": \"success\",\n  \"direction\": \"forward\",\n  \"results\": {\n    \"machine learning\": [\"Alice\", \"Bob\"],\n    \"finance\":          [\"Carol\"],\n    \"quantum physics\":  []\n  }\n}\n</code></pre> Field Description <code>direction</code> The lookup direction used <code>results</code> Map of each input value to its list of linked values. Empty list if no links found"},{"location":"api/api-client/links_match/#error-responses","title":"Error Responses","text":"Status Condition <code>500</code> Unexpected internal error"},{"location":"api/api-client/links_match/#notes","title":"Notes","text":"<ul> <li>If the link collection does not exist, all values return empty lists (no error is raised).</li> <li>Use <code>\"reverse\"</code> direction to look up which source values map to a given target value.</li> <li>Link collections are in-memory and must be re-ingested after a server restart.</li> </ul>"},{"location":"api/api-client/links_match/#example","title":"Example","text":"<pre><code>import requests\n\nSERVER_URL = \"http://hbserver:8000\"\nAPI_KEY    = \"yourapitoken\"\n\ndef link_match(link_collection: str, source_values: list, direction: str = \"forward\") -&gt; dict:\n    response = requests.post(\n        f\"{SERVER_URL}/compose/links/match\",\n        headers={\"X-API-Key\": API_KEY},\n        json={\n            \"link_collection\": link_collection,\n            \"source_values\":   source_values,\n            \"direction\":       direction,\n        },\n    )\n    response.raise_for_status()\n    return response.json()\n\n\n# Forward lookup: what employees have expertise in these topics?\nresult = link_match(\n    link_collection=\"expertise_to_employees\",\n    source_values=[\"machine learning\", \"finance\", \"quantum physics\"],\n    direction=\"forward\",\n)\nprint(result)\n\n# Reverse lookup: what topics is Alice linked to?\nresult = link_match(\n    link_collection=\"expertise_to_employees\",\n    source_values=[\"Alice\"],\n    direction=\"reverse\",\n)\nprint(result)\n</code></pre> <p>Expected output (forward):</p> <pre><code>{\n  \"status\": \"success\",\n  \"direction\": \"forward\",\n  \"results\": {\n    \"machine learning\": [\"Alice\", \"Bob\"],\n    \"finance\":          [\"Carol\"],\n    \"quantum physics\":  []\n  }\n}\n</code></pre> <p>Expected output (reverse):</p> <pre><code>{\n  \"status\": \"success\",\n  \"direction\": \"reverse\",\n  \"results\": {\n    \"Alice\": [\"machine learning\"]\n  }\n}\n</code></pre>"},{"location":"api/api-client/multihop/","title":"<code>POST /multihop/</code>","text":"<p>Executes a multi-hop query across a namespace, applying a sequence of field-level filters to progressively narrow down candidates before returning the top results.</p>"},{"location":"api/api-client/multihop/#request","title":"Request","text":"<p>Content-Type: <code>application/json</code></p> Parameter Type Required Default Description <code>query</code> object \u2705 \u2014 Key-value pairs representing the initial filter conditions <code>path</code> array of <code>[field, value]</code> \u2705 \u2014 Ordered list of hops. Each hop is a <code>[field, value]</code> tuple applied sequentially to filter candidates <code>db_name</code> string \u274c <code>\"fractal_db\"</code> Name of the database to query <code>namespace</code> string \u274c <code>\"string\"</code> Namespace to query within the database <code>top_k</code> int \u274c <code>10</code> Maximum number of results to return"},{"location":"api/api-client/multihop/#behavior","title":"Behavior","text":"<p>Multi-hop filtering \u2014 The query is executed in steps. The initial <code>query</code> dict filters the full candidate pool, then each entry in <code>path</code> applies an additional field-level filter to the surviving candidates. This allows traversal of structured relationships (e.g. filter by department, then by role, then by seniority).</p> <p>Scoring \u2014 Each result is returned with a relevance score. Non-finite scores (NaN, Inf) are returned as <code>null</code>.</p> <p>Data retrieval \u2014 Row metadata is fetched directly from RocksDB using the matched row IDs, so no CSV or in-memory DataFrame is required at query time.</p> <p>Explanation \u2014 Every response includes a full trace of how many candidates survived each hop, making it easy to debug filter chains.</p>"},{"location":"api/api-client/multihop/#responses","title":"Responses","text":""},{"location":"api/api-client/multihop/#200-ok","title":"200 OK","text":"<pre><code>{\n  \"results\": [\n    {\n      \"row_id\": 42,\n      \"score\": 0.91,\n      \"name\": \"Alice Johnson\",\n      \"department\": \"Engineering\",\n      \"role\": \"Senior Engineer\"\n    }\n  ],\n  \"explanation\": {\n    \"initial_filters_matched\": 120,\n    \"final_result_count\": 3,\n    \"hops\": [\n      {\n        \"field\": \"department\",\n        \"value\": \"Engineering\",\n        \"filter_type\": \"exact\",\n        \"candidates_before\": 120,\n        \"candidates_after\": 40\n      },\n      {\n        \"field\": \"role\",\n        \"value\": \"Senior Engineer\",\n        \"filter_type\": \"exact\",\n        \"candidates_before\": 40,\n        \"candidates_after\": 3\n      }\n    ],\n    \"trace\": \"...\"\n  },\n  \"db_name\": \"my_db\",\n  \"namespace\": \"default\",\n  \"top_k\": 10,\n  \"query\": {\"department\": \"Engineering\"},\n  \"path\": [[\"role\", \"Senior Engineer\"]]\n}\n</code></pre> <p><code>results</code> array \u2014 each item contains:</p> Field Description <code>row_id</code> Internal row identifier <code>score</code> Relevance score, or <code>null</code> if non-finite <code>...</code> All other metadata fields stored for that row <p><code>explanation</code> object:</p> Field Description <code>initial_filters_matched</code> Candidates matched by the initial <code>query</code> <code>final_result_count</code> Candidates remaining after all hops <code>hops</code> Per-hop breakdown: field, value, filter type, and candidate counts before/after <code>trace</code> Full internal trace string for debugging"},{"location":"api/api-client/multihop/#error-responses","title":"Error Responses","text":"Status Condition <code>500</code> Database not found, namespace not loaded, or unexpected internal error"},{"location":"api/api-client/multihop/#notes","title":"Notes","text":"<ul> <li>The <code>path</code> order matters \u2014 hops are applied sequentially and each one filters the output of the previous.</li> <li>Ensure the namespace is already ingested via <code>/build_ingest_data/</code> before querying.</li> <li><code>db_name</code> and <code>namespace</code> must exactly match what was used during ingest.</li> </ul>"},{"location":"api/api-client/multihop/#example","title":"Example","text":"<pre><code>import requests\n\nSERVER_URL = \"http://hbserver:8000\"\nAPI_KEY    = \"yourapitoken\"\n\ndef multihop_query(query: dict, path: list, namespace: str) -&gt; dict:\n    response = requests.post(\n        f\"{SERVER_URL}/multihop/\",\n        headers={\"X-API-Key\": API_KEY},\n        json={\n            \"query\":     query,\n            \"path\":      path,\n            \"db_name\":   \"my_db\",\n            \"namespace\": namespace,\n            \"top_k\":     10,\n        },\n    )\n    response.raise_for_status()\n    return response.json()\n\n\nresult = multihop_query(\n    query={\"department\": \"Engineering\"},\n    path=[\n        [\"role\", \"Senior Engineer\"],\n        [\"location\", \"New York\"],\n    ],\n    namespace=\"default\",\n)\nprint(result)\n</code></pre> <p>Expected output:</p> <pre><code>{\n  \"results\": [\n    {\n      \"row_id\": 42,\n      \"score\": 0.91,\n      \"name\": \"Alice Johnson\",\n      \"department\": \"Engineering\",\n      \"role\": \"Senior Engineer\",\n      \"location\": \"New York\"\n    }\n  ],\n  \"explanation\": {\n    \"initial_filters_matched\": 120,\n    \"final_result_count\": 1,\n    \"hops\": [\n      {\n        \"field\": \"role\",\n        \"value\": \"Senior Engineer\",\n        \"filter_type\": \"exact\",\n        \"candidates_before\": 120,\n        \"candidates_after\": 8\n      },\n      {\n        \"field\": \"location\",\n        \"value\": \"New York\",\n        \"filter_type\": \"exact\",\n        \"candidates_before\": 8,\n        \"candidates_after\": 1\n      }\n    ],\n    \"trace\": \"...\"\n  },\n  \"db_name\": \"my_db\",\n  \"namespace\": \"default\",\n  \"top_k\": 10,\n  \"query\": {\"department\": \"Engineering\"},\n  \"path\": [[\"role\", \"Senior Engineer\"], [\"location\", \"New York\"]]\n}\n</code></pre>"},{"location":"api/api-client/multihop_unstructured/","title":"<code>POST /unstructured/multihop_query/</code>","text":"<p>Executes a multi-hop semantic retrieval over an ingested document namespace. Each hop progressively refines the candidate pool by following semantic and symbolic edges, enabling retrieval that traverses document structure rather than relying on a single-pass search.</p>"},{"location":"api/api-client/multihop_unstructured/#request","title":"Request","text":"<p>Content-Type: <code>application/json</code></p> Parameter Type Required Default Description <code>query</code> string \u2705 \u2014 Natural language query string <code>db_name</code> string \u2705 \u2014 Name of the database to query <code>namespace</code> string \u2705 \u2014 Namespace to query within the database <code>role</code> string \u274c <code>null</code> Target role for symbolic encoding (e.g. <code>\"paragraph\"</code>). Defaults to <code>\"paragraph\"</code> internally if <code>use_symbolic</code> is true and no role is provided <code>use_symbolic</code> bool \u274c <code>true</code> Whether to include symbolic encoding in retrieval <code>num_hops</code> int \u274c <code>3</code> Number of hops to traverse <code>top_k_per_hop</code> int \u274c <code>15</code> Candidate pool size at each hop <code>final_top_k</code> int \u274c <code>10</code> Number of final results to return <code>hop_decay</code> float \u274c <code>0.85</code> Score decay factor applied at each hop <code>context_expansion_ratio</code> float \u274c <code>0.5</code> Fraction of each hop's candidates used to seed the next hop"},{"location":"api/api-client/multihop_unstructured/#behavior","title":"Behavior","text":"<p>Multi-hop traversal \u2014 Rather than a single retrieval pass, the query is executed across <code>num_hops</code> iterations. Each hop uses the top candidates from the previous hop as context seeds for the next, following semantic and symbolic edges through the document.</p> <p>Symbolic encoding \u2014 When <code>use_symbolic</code> is true, the target <code>role</code> is encoded symbolically using <code>\"exact\"</code> encoding and used to guide retrieval toward structurally relevant chunks. If symbolic encoding fails it is skipped silently and retrieval continues without it.</p> <p>Score decay \u2014 Scores are multiplied by <code>hop_decay</code> at each successive hop, so earlier hops carry more weight in the final ranking. Set to <code>1.0</code> to disable decay.</p> <p>Data loading \u2014 All text content is fetched lazily from RocksDB using the final set of result row IDs. Each hop displays up to 3 representative docs for tracing \u2014 <code>final_results</code> contains the full ranked output.</p>"},{"location":"api/api-client/multihop_unstructured/#responses","title":"Responses","text":""},{"location":"api/api-client/multihop_unstructured/#200-ok","title":"200 OK","text":"<pre><code>{\n  \"query\": \"explain the appeals process\",\n  \"namespace\": \"document_upload_3f9a1c2e\",\n  \"hops\": [\n    {\n      \"hop\": 0,\n      \"docs\": [\"Appeals must be submitted in writing...\", \"The review board convenes...\", \"...\"]\n    },\n    {\n      \"hop\": 1,\n      \"docs\": [\"Decisions are issued within 30 days...\", \"...\"]\n    }\n  ],\n  \"final_results\": [\n    {\n      \"row_id\": 34,\n      \"value\": \"Appeals must be submitted in writing within 14 days...\",\n      \"role\": \"paragraph\",\n      \"parent\": \"chunk_6\",\n      \"text\": \"Appeals must be submitted in writing within 14 days...\",\n      \"score\": 0.923\n    }\n  ],\n  \"symbolic_edges\": [\n    { \"hop\": 0, \"doc_idx\": 34 }\n  ]\n}\n</code></pre> <p><code>final_results</code> array \u2014 each item contains:</p> Field Description <code>row_id</code> Internal row identifier <code>value</code> Text content of the chunk <code>role</code> Cell role label (e.g. <code>\"paragraph\"</code>, <code>\"sentence\"</code>) <code>parent</code> Parent chunk identifier <code>text</code> Alias of <code>value</code> <code>score</code> Final relevance score. Non-finite values are clamped to <code>0.0</code> <p><code>hops</code> array:</p> Field Description <code>hop</code> Hop index (0-based) <code>docs</code> Up to 3 representative document snippets from that hop <p><code>symbolic_edges</code> array:</p> Field Description <code>hop</code> Hop where the edge was activated <code>doc_idx</code> Row ID of the document linked via symbolic edge"},{"location":"api/api-client/multihop_unstructured/#error-responses","title":"Error Responses","text":"Status Condition <code>500</code> Namespace not found, retrieval failure, or unexpected internal error"},{"location":"api/api-client/multihop_unstructured/#notes","title":"Notes","text":"<ul> <li>The namespace must already be ingested via <code>/unstructured/upload_document/</code> before querying.</li> <li>Increase <code>num_hops</code> for longer documents where relevant content may be spread across distant chunks.</li> <li>If <code>final_results</code> is empty, try lowering <code>hop_decay</code>, increasing <code>top_k_per_hop</code>, or setting <code>use_symbolic</code> to <code>false</code> to isolate the issue.</li> </ul>"},{"location":"api/api-client/multihop_unstructured/#example","title":"Example","text":"<pre><code>import requests\n\nSERVER_URL = \"http://hbserver:8000\"\nAPI_KEY    = \"yourapitoken\"\n\ndef multihop_query(query: str, namespace: str) -&gt; dict:\n    response = requests.post(\n        f\"{SERVER_URL}/unstructured/multihop_query/\",\n        headers={\"X-API-Key\": API_KEY},\n        json={\n            \"query\":                   query,\n            \"db_name\":                 \"fractal_db\",\n            \"namespace\":               namespace,\n            \"role\":                    \"paragraph\",  # optional\n            \"use_symbolic\":            True,          # optional, defaults to True\n            \"num_hops\":                3,             # optional, defaults to 3\n            \"top_k_per_hop\":           15,            # optional, defaults to 15\n            \"final_top_k\":             10,            # optional, defaults to 10\n            \"hop_decay\":               0.85,          # optional, defaults to 0.85\n            \"context_expansion_ratio\": 0.5,           # optional, defaults to 0.5\n        },\n    )\n    response.raise_for_status()\n    return response.json()\n\n\nresult = multihop_query(\n    query=\"explain the appeals process\",\n    namespace=\"document_upload_3f9a1c2e\",\n)\nprint(result)\n</code></pre> <p>Expected output:</p> <pre><code>{\n  \"query\": \"explain the appeals process\",\n  \"namespace\": \"document_upload_3f9a1c2e\",\n  \"hops\": [\n    { \"hop\": 0, \"docs\": [\"Appeals must be submitted in writing...\", \"The review board...\", \"...\"] },\n    { \"hop\": 1, \"docs\": [\"Decisions are issued within 30 days...\", \"...\"] },\n    { \"hop\": 2, \"docs\": [\"Final rulings are binding unless...\", \"...\"] }\n  ],\n  \"final_results\": [\n    {\n      \"row_id\": 34,\n      \"value\": \"Appeals must be submitted in writing within 14 days...\",\n      \"role\": \"paragraph\",\n      \"parent\": \"chunk_6\",\n      \"text\": \"Appeals must be submitted in writing within 14 days...\",\n      \"score\": 0.923\n    }\n  ],\n  \"symbolic_edges\": [\n    { \"hop\": 0, \"doc_idx\": 34 }\n  ]\n}\n</code></pre>"},{"location":"api/api-client/query_rag_symbolic/","title":"<code>POST /query_rag_symbolic/</code>","text":"<p>Retrieves the most relevant chunks from an ingested document namespace using a hybrid semantic + symbolic search pipeline. Results are ranked and returned directly \u2014 no LLM inference is performed.</p>"},{"location":"api/api-client/query_rag_symbolic/#request","title":"Request","text":"<p>Content-Type: <code>application/json</code></p> Parameter Type Required Default Description <code>query</code> string \u2705 \u2014 Natural language query string <code>db_name</code> string \u274c <code>\"fractal_db\"</code> Name of the database to query <code>namespace</code> string \u274c <code>\"pdf_upload\"</code> Namespace to query within the database <code>role</code> string \u274c <code>\"value\"</code> Filter results to a specific cell role (e.g. <code>\"value\"</code>, <code>\"header\"</code>, <code>\"all\"</code>) <code>top_k</code> int \u274c <code>10</code> Number of top results to return"},{"location":"api/api-client/query_rag_symbolic/#behavior","title":"Behavior","text":"<p>Hybrid retrieval \u2014 Candidates are fetched using a combination of semantic similarity (sentence embeddings) and keyword matching via <code>hybrid_search_matrix()</code>. The initial retrieval pool is <code>top_k * 5</code> to allow for downstream filtering and re-ranking.</p> <p>Symbolic encoding \u2014 The <code>role</code> field is encoded symbolically and used to bind results to the requested cell role during both retrieval and scoring.</p> <p>Role filtering \u2014 After retrieval, results whose <code>role</code> field does not match the requested role are discarded (unless <code>role</code> is <code>\"all\"</code>).</p> <p>Re-ranking \u2014 Surviving candidates are re-scored using a weighted average: - <code>60%</code> hybrid score (semantic + keyword) - <code>40%</code> symbolic score (structural similarity)</p> <p>Results are then sorted by final score and trimmed to <code>top_k</code>.</p>"},{"location":"api/api-client/query_rag_symbolic/#responses","title":"Responses","text":""},{"location":"api/api-client/query_rag_symbolic/#200-ok","title":"200 OK","text":"<pre><code>{\n  \"query\": \"what is the refund policy?\",\n  \"role_restriction\": \"value\",\n  \"namespace\": \"document_upload_3f9a1c2e\",\n  \"top_k\": 10,\n  \"chunks_retrieved\": 4,\n  \"results\": [\n    {\n      \"row_id\": 17,\n      \"score\": 0.812,\n      \"hybrid_score\": 0.874,\n      \"symbolic_score\": 0.721,\n      \"role\": \"value\",\n      \"value\": \"Refunds are processed within 5\u20137 business days...\",\n      \"parent\": \"chunk_3\"\n    }\n  ]\n}\n</code></pre> <p><code>results</code> array \u2014 each item contains:</p> Field Description <code>row_id</code> Internal row identifier <code>score</code> Final weighted score (0.6 \u00d7 hybrid + 0.4 \u00d7 symbolic) <code>hybrid_score</code> Raw hybrid retrieval score <code>symbolic_score</code> Symbolic vector similarity score <code>role</code> Cell role label (e.g. <code>\"value\"</code>, <code>\"header\"</code>) <code>value</code> Text content of the chunk <code>parent</code> Parent chunk identifier"},{"location":"api/api-client/query_rag_symbolic/#error-responses","title":"Error Responses","text":"Status Condition <code>500</code> Symbolic encoding failed, namespace not found, or unexpected internal error"},{"location":"api/api-client/query_rag_symbolic/#notes","title":"Notes","text":"<ul> <li>The namespace must already be ingested via <code>/upload_document/</code> or <code>/build_ingest_data/</code> before querying.</li> <li>Setting <code>role</code> to <code>\"all\"</code> disables role filtering and returns results across all cell types.</li> <li>No GPT or LLM inference is performed \u2014 this endpoint returns raw ranked chunks only.</li> </ul>"},{"location":"api/api-client/query_rag_symbolic/#example","title":"Example","text":"<pre><code>import requests\n\nSERVER_URL = \"http://hbserver:8000\"\nAPI_KEY    = \"yourapitoken\"\n\ndef query_rag_symbolic(query: str, namespace: str) -&gt; dict:\n    response = requests.post(\n        f\"{SERVER_URL}/unstructured/query_rag_symbolic/\",\n        headers={\"X-API-Key\": API_KEY},\n        json={\n            \"query\":     query,\n            \"db_name\":   \"fractal_db\",\n            \"namespace\": namespace,\n            \"role\":      \"value\",   # optional, defaults to \"value\"\n            \"top_k\":     10,        # optional, defaults to 10\n        },\n    )\n    response.raise_for_status()\n    return response.json()\n\n\nresult = query_rag_symbolic(\n    query=\"what is the refund policy?\",\n    namespace=\"document_upload_3f9a1c2e\",\n)\nprint(result)\n</code></pre> <p>Expected output:</p> <pre><code>{\n  \"query\": \"what is the refund policy?\",\n  \"role_restriction\": \"value\",\n  \"namespace\": \"document_upload_3f9a1c2e\",\n  \"top_k\": 10,\n  \"chunks_retrieved\": 4,\n  \"results\": [\n    {\n      \"row_id\": 17,\n      \"score\": 0.812,\n      \"hybrid_score\": 0.874,\n      \"symbolic_score\": 0.721,\n      \"role\": \"value\",\n      \"value\": \"Refunds are processed within 5\u20137 business days...\",\n      \"parent\": \"chunk_3\"\n    }\n  ]\n}\n</code></pre>"},{"location":"api/api-client/row_crud/","title":"Row CRUD Endpoints","text":"<p>Four endpoints for single-row operations on <code>Row</code> molecule collections. These provide relational-style CRUD with primary key identity, atomic updates, and duplicate detection.</p> <p>Architecture note: Row CRUD is part of <code>RelationalTable</code> \u2014 structured storage with chain binding encoding. It does not generate semantic embeddings. For semantic search over row data, use <code>Catalog.index()</code> separately.</p>"},{"location":"api/api-client/row_crud/#post-rowinsert","title":"<code>POST /row/insert/</code>","text":"<p>Insert a single row into a <code>Row</code> molecule collection.</p>"},{"location":"api/api-client/row_crud/#request-body","title":"Request Body","text":"Parameter Type Required Description <code>db_name</code> string \u2705 Database name <code>namespace</code> string \u2705 Namespace (must exist and use <code>Row</code> molecule) <code>row</code> object \u2705 Row data including the primary key field <code>template_schema</code> object \u2705 Row molecule schema with <code>primary_key</code> defined"},{"location":"api/api-client/row_crud/#behavior","title":"Behavior","text":"<ul> <li>Checks for duplicate primary key \u2014 returns <code>409</code> if exists</li> <li>Encodes row using chain binding: <code>pk \u229b (f\u2081\u229bv\u2081) \u229b (f\u2082\u229bv\u2082) \u229b ...</code></li> <li>Row ID is assigned atomically (safe for concurrent inserts)</li> <li>The namespace must have been created first via <code>/build_ingest_data/</code> with a <code>Row</code> schema</li> </ul>"},{"location":"api/api-client/row_crud/#response","title":"Response","text":"<pre><code>{\n  \"status\": \"success\",\n  \"pk_field\": \"id\",\n  \"pk_value\": \"E011\",\n  \"row_id\": 10,\n  \"namespace\": \"employees\",\n  \"db_name\": \"my_db\",\n  \"note\": \"Row stored. For semantic search, use Catalog.index() or Catalog.reindex().\"\n}\n</code></pre>"},{"location":"api/api-client/row_crud/#error-responses","title":"Error Responses","text":"Status Condition <code>400</code> Row missing primary key, or namespace uses a non-Row molecule <code>404</code> Namespace not found <code>409</code> Duplicate primary key <code>500</code> Unexpected internal error"},{"location":"api/api-client/row_crud/#post-rowget","title":"<code>POST /row/get/</code>","text":"<p>Retrieve a row by primary key (O(1) lookup).</p>"},{"location":"api/api-client/row_crud/#request-body_1","title":"Request Body","text":"Parameter Type Required Description <code>db_name</code> string \u2705 Database name <code>namespace</code> string \u2705 Namespace <code>pk_field</code> string \u2705 Primary key field name <code>pk_value</code> string \u2705 Primary key value to look up"},{"location":"api/api-client/row_crud/#response_1","title":"Response","text":"<pre><code>{\n  \"status\": \"success\",\n  \"row_id\": 10,\n  \"data\": { \"id\": \"E011\", \"name\": \"Zara\", \"department\": \"Engineering\" },\n  \"namespace\": \"employees\",\n  \"db_name\": \"my_db\"\n}\n</code></pre>"},{"location":"api/api-client/row_crud/#error-responses_1","title":"Error Responses","text":"Status Condition <code>404</code> Namespace or row not found <code>500</code> Unexpected internal error"},{"location":"api/api-client/row_crud/#post-rowupdate","title":"<code>POST /row/update/</code>","text":"<p>Atomically update a row by primary key.</p>"},{"location":"api/api-client/row_crud/#request-body_2","title":"Request Body","text":"Parameter Type Required Description <code>db_name</code> string \u2705 Database name <code>namespace</code> string \u2705 Namespace <code>pk_field</code> string \u2705 Primary key field name <code>pk_value</code> string \u2705 Primary key value identifying the row <code>updates</code> object \u2705 Fields to update. Cannot include <code>pk_field</code> <code>template_schema</code> object \u274c Schema for re-encoding. Falls back to stored schema"},{"location":"api/api-client/row_crud/#behavior_1","title":"Behavior","text":"<p>Merges <code>updates</code> into existing row data, then re-encodes the entire row atomically. The primary key cannot be updated. Semantic embeddings are not regenerated \u2014 use <code>Catalog.reindex()</code> if text fields changed.</p>"},{"location":"api/api-client/row_crud/#response_2","title":"Response","text":"<pre><code>{\n  \"status\": \"success\",\n  \"method\": \"atomic_row_update\",\n  \"pk_field\": \"id\",\n  \"pk_value\": \"E011\",\n  \"row_id\": 10,\n  \"old_values\": { \"salary\": \"95000\" },\n  \"new_values\": { \"salary\": \"105000\" },\n  \"namespace\": \"employees\",\n  \"db_name\": \"my_db\",\n  \"note\": \"Row updated. For semantic search, use Catalog.reindex() if text fields changed.\"\n}\n</code></pre>"},{"location":"api/api-client/row_crud/#error-responses_2","title":"Error Responses","text":"Status Condition <code>400</code> Attempted to update the primary key field <code>404</code> Namespace or row not found <code>500</code> Unexpected internal error"},{"location":"api/api-client/row_crud/#post-rowdelete","title":"<code>POST /row/delete/</code>","text":"<p>Delete a row by primary key.</p>"},{"location":"api/api-client/row_crud/#request-body_3","title":"Request Body","text":"Parameter Type Required Description <code>db_name</code> string \u2705 Database name <code>namespace</code> string \u2705 Namespace <code>pk_field</code> string \u2705 Primary key field name <code>pk_value</code> string \u2705 Primary key value to delete"},{"location":"api/api-client/row_crud/#response_3","title":"Response","text":"<pre><code>{\n  \"status\": \"success\",\n  \"deleted\": { \"pk_field\": \"id\", \"pk_value\": \"E011\", \"row_id\": 10 },\n  \"namespace\": \"employees\",\n  \"db_name\": \"my_db\"\n}\n</code></pre>"},{"location":"api/api-client/row_crud/#error-responses_3","title":"Error Responses","text":"Status Condition <code>404</code> Namespace or row not found <code>500</code> Unexpected internal error"},{"location":"api/api-client/row_crud/#post-rowdelete_filter","title":"<code>POST /row/delete_filter/</code>","text":"<p>Bulk delete rows matching a field value.</p>"},{"location":"api/api-client/row_crud/#request-body_4","title":"Request Body","text":"Parameter Type Required Description <code>db_name</code> string \u2705 Database name <code>namespace</code> string \u2705 Namespace <code>field</code> string \u2705 Field to filter on <code>value</code> string \u2705 Value to match (exact)"},{"location":"api/api-client/row_crud/#response_4","title":"Response","text":"<pre><code>{\n  \"status\": \"success\",\n  \"rows_deleted\": 3,\n  \"filter\": { \"field\": \"department\", \"value\": \"Engineering\" },\n  \"namespace\": \"employees\",\n  \"db_name\": \"my_db\"\n}\n</code></pre>"},{"location":"api/api-client/row_crud/#error-responses_4","title":"Error Responses","text":"Status Condition <code>404</code> Namespace not found <code>500</code> Unexpected internal error"},{"location":"api/api-client/row_crud/#notes","title":"Notes","text":"<ul> <li>All Row CRUD endpoints require the namespace to be created with <code>\"molecule\": \"Row\"</code> and a <code>primary_key</code> defined in the schema.</li> <li>The primary key is immutable \u2014 attempting to update it returns <code>400</code>.</li> <li><code>delete_filter</code> uses exact string matching \u2014 it does not support operators.</li> <li>Row CRUD does not touch semantic embeddings. Use <code>Catalog.reindex()</code> after updates if semantic search is needed.</li> </ul>"},{"location":"api/api-client/row_crud/#schema-example","title":"Schema Example","text":"<pre><code>ROW_SCHEMA = {\n    \"molecule\": \"Row\",\n    \"primary_key\": {\"name\": \"id\"},\n    \"fields\": {\n        \"id\":         {\"encoding\": \"exact\"},\n        \"name\":       {\"encoding\": \"exact\"},\n        \"department\": {\"encoding\": \"exact\"},\n        \"salary\":     {\"encoding\": \"numeric\"},\n    }\n}\n</code></pre>"},{"location":"api/api-client/search_slot/","title":"<code>POST /compose/search_slot/{db_name}/{namespace}</code>","text":"<p>Searches within a single named slot rather than against full row vectors. For example, searching for <code>\"Einstein\"</code> only in the <code>\"subject\"</code> slot of Triple-encoded data, ignoring other slots entirely.</p>"},{"location":"api/api-client/search_slot/#request","title":"Request","text":"<p>Content-Type: <code>application/json</code></p> <p>URL Parameters:</p> Parameter Description <code>db_name</code> Name of the database <code>namespace</code> Namespace within the database <p>Body:</p> Parameter Type Required Default Description <code>query</code> string \u2705 \u2014 The value to search for within the slot <code>slot</code> string \u2705 \u2014 The slot to search within (e.g. <code>\"subject\"</code>, <code>\"object\"</code>) <code>encoding</code> string \u274c <code>null</code> Encoding type: <code>\"semantic\"</code>, <code>\"exact\"</code>, or <code>\"numeric\"</code>. Auto-detected from schema if omitted <code>top_k</code> int \u274c <code>10</code> Number of results to return <code>schema_json_data</code> string \u274c <code>null</code> JSON string of the schema. Required if schema is not stored in metadata"},{"location":"api/api-client/search_slot/#behavior","title":"Behavior","text":"<p>The query is encoded using the slot's encoding strategy, then compared only against the target slot's vector component in each row. This isolates the search to a specific structural position in the data.</p> <p>If <code>encoding</code> is <code>\"semantic\"</code>, the query embedding is loaded into the cache before the Rust search call.</p> <p>A schema is required \u2014 either stored in metadata from ingest, or provided via <code>schema_json_data</code>.</p>"},{"location":"api/api-client/search_slot/#responses","title":"Responses","text":""},{"location":"api/api-client/search_slot/#200-ok","title":"200 OK","text":"<pre><code>{\n  \"status\": \"success\",\n  \"query_type\": \"slot_search\",\n  \"query\": \"Einstein\",\n  \"slot\": \"subject\",\n  \"count\": 3,\n  \"results\": [\n    {\n      \"_id\": 14,\n      \"_score\": 0.961,\n      \"data\": {\n        \"subject\": \"Einstein\",\n        \"predicate\": \"developed\",\n        \"object\": \"Relativity\"\n      }\n    }\n  ]\n}\n</code></pre> Field Description <code>query</code> The search query <code>slot</code> The slot that was searched <code>count</code> Number of results returned <code>results</code> Array of matches with <code>_id</code>, <code>_score</code>, and <code>data</code>"},{"location":"api/api-client/search_slot/#error-responses","title":"Error Responses","text":"Status Condition <code>400</code> No schema found and none provided, or invalid query <code>404</code> Collection not found <code>500</code> Unexpected internal error"},{"location":"api/api-client/search_slot/#notes","title":"Notes","text":"<ul> <li>Slot search is more precise than full-row search when you know which structural position a value occupies.</li> <li>For searching across multiple slots simultaneously with different weights, use <code>/compose/search_slots</code>.</li> <li>Schema must be available \u2014 either stored from ingest or passed in <code>schema_json_data</code>.</li> </ul>"},{"location":"api/api-client/search_slot/#example","title":"Example","text":"<pre><code>import requests\n\nSERVER_URL = \"http://hbserver:8000\"\nAPI_KEY    = \"yourapitoken\"\n\ndef search_slot(db_name: str, namespace: str, query: str, slot: str, top_k: int = 10) -&gt; dict:\n    response = requests.post(\n        f\"{SERVER_URL}/compose/search_slot/{db_name}/{namespace}\",\n        headers={\"X-API-Key\": API_KEY},\n        json={\n            \"query\": query,\n            \"slot\":  slot,\n            \"top_k\": top_k,\n        },\n    )\n    response.raise_for_status()\n    return response.json()\n\n\nresult = search_slot(\n    db_name=\"my_db\",\n    namespace=\"triples\",\n    query=\"Einstein\",\n    slot=\"subject\",\n    top_k=5,\n)\nprint(result)\n</code></pre> <p>Expected output:</p> <pre><code>{\n  \"status\": \"success\",\n  \"query_type\": \"slot_search\",\n  \"query\": \"Einstein\",\n  \"slot\": \"subject\",\n  \"count\": 2,\n  \"results\": [\n    { \"_id\": 14, \"_score\": 0.961, \"data\": { \"subject\": \"Einstein\", \"predicate\": \"developed\", \"object\": \"Relativity\" } },\n    { \"_id\": 17, \"_score\": 0.903, \"data\": { \"subject\": \"Einstein\", \"predicate\": \"born_in\",   \"object\": \"Ulm\" } }\n  ]\n}\n</code></pre>"},{"location":"api/api-client/search_slots/","title":"<code>POST /compose/search_slots/{db_name}/{namespace}</code>","text":"<p>Searches across multiple slots simultaneously, with a different query and optional weight per slot. The final score is a weighted average of per-slot similarities.</p>"},{"location":"api/api-client/search_slots/#request","title":"Request","text":"<p>Content-Type: <code>application/json</code></p> <p>URL Parameters:</p> Parameter Description <code>db_name</code> Name of the database <code>namespace</code> Namespace within the database <p>Body:</p> Parameter Type Required Default Description <code>slot_queries</code> object \u2705 \u2014 Map of slot name \u2192 query config. See slot query format below <code>top_k</code> int \u274c <code>10</code> Number of results to return <code>schema_json_data</code> string \u274c <code>null</code> JSON string of the schema. Required if schema is not stored in metadata <p>Slot query format \u2014 each entry in <code>slot_queries</code> can be a plain string or a full config object:</p> <pre><code>{\n  \"subject\": \"Einstein\",\n  \"predicate\": { \"query\": \"developed\", \"weight\": 0.3, \"encoding\": \"exact\" },\n  \"object\":    { \"query\": \"physics\",   \"weight\": 0.7, \"encoding\": \"semantic\" }\n}\n</code></pre> Field Type Required Default Description <code>query</code> string \u2705 \u2014 Value to search for in this slot <code>weight</code> float \u274c <code>1.0</code> Relative weight for this slot's score contribution <code>encoding</code> string \u274c schema-inferred Encoding override for this slot"},{"location":"api/api-client/search_slots/#behavior","title":"Behavior","text":"<p>Each slot query is encoded independently using its slot's encoding strategy (or the provided override). Scores from all slots are combined as a weighted average to produce a final ranking. Semantic slot queries have their embeddings loaded into the cache before the Rust call.</p> <p>A schema is required \u2014 either stored in metadata from ingest, or provided via <code>schema_json_data</code>.</p>"},{"location":"api/api-client/search_slots/#responses","title":"Responses","text":""},{"location":"api/api-client/search_slots/#200-ok","title":"200 OK","text":"<pre><code>{\n  \"status\": \"success\",\n  \"query_type\": \"multi_slot_search\",\n  \"slot_queries\": {\n    \"subject\":   \"Einstein\",\n    \"predicate\": { \"query\": \"developed\", \"weight\": 0.3 }\n  },\n  \"count\": 3,\n  \"results\": [\n    {\n      \"_id\": 14,\n      \"_score\": 0.874,\n      \"data\": {\n        \"subject\":   \"Einstein\",\n        \"predicate\": \"developed\",\n        \"object\":    \"Relativity\"\n      }\n    }\n  ]\n}\n</code></pre> Field Description <code>slot_queries</code> The slot queries as provided <code>count</code> Number of results returned <code>results</code> Array of matches with <code>_id</code>, <code>_score</code>, and <code>data</code>"},{"location":"api/api-client/search_slots/#error-responses","title":"Error Responses","text":"Status Condition <code>400</code> No schema found, none provided, or invalid slot query format <code>404</code> Collection not found <code>500</code> Unexpected internal error"},{"location":"api/api-client/search_slots/#notes","title":"Notes","text":"<ul> <li>Weights do not need to sum to 1.0 \u2014 they are used as relative importance signals.</li> <li>For a single-slot query, prefer <code>/compose/search_slot</code> for simplicity.</li> <li>Schema must be available \u2014 either stored from ingest or passed in <code>schema_json_data</code>.</li> </ul>"},{"location":"api/api-client/search_slots/#example","title":"Example","text":"<pre><code>import requests\n\nSERVER_URL = \"http://hbserver:8000\"\nAPI_KEY    = \"yourapitoken\"\n\ndef search_slots(db_name: str, namespace: str, slot_queries: dict, top_k: int = 10) -&gt; dict:\n    response = requests.post(\n        f\"{SERVER_URL}/compose/search_slots/{db_name}/{namespace}\",\n        headers={\"X-API-Key\": API_KEY},\n        json={\n            \"slot_queries\": slot_queries,\n            \"top_k\":        top_k,\n        },\n    )\n    response.raise_for_status()\n    return response.json()\n\n\nresult = search_slots(\n    db_name=\"my_db\",\n    namespace=\"triples\",\n    slot_queries={\n        \"subject\":   \"Einstein\",\n        \"predicate\": {\"query\": \"developed\", \"weight\": 0.3, \"encoding\": \"exact\"},\n        \"object\":    {\"query\": \"physics\",   \"weight\": 0.7, \"encoding\": \"semantic\"},\n    },\n    top_k=5,\n)\nprint(result)\n</code></pre> <p>Expected output:</p> <pre><code>{\n  \"status\": \"success\",\n  \"query_type\": \"multi_slot_search\",\n  \"slot_queries\": {\n    \"subject\": \"Einstein\",\n    \"predicate\": { \"query\": \"developed\", \"weight\": 0.3, \"encoding\": \"exact\" },\n    \"object\":    { \"query\": \"physics\",   \"weight\": 0.7, \"encoding\": \"semantic\" }\n  },\n  \"count\": 2,\n  \"results\": [\n    { \"_id\": 14, \"_score\": 0.874, \"data\": { \"subject\": \"Einstein\", \"predicate\": \"developed\", \"object\": \"Relativity\" } },\n    { \"_id\": 21, \"_score\": 0.741, \"data\": { \"subject\": \"Einstein\", \"predicate\": \"wrote\",     \"object\": \"physics paper\" } }\n  ]\n}\n</code></pre>"},{"location":"api/api-client/select/","title":"<code>POST /select/</code>","text":"<p>Executes a SQL-style SELECT query against an ingested namespace. Supports column projection, WHERE filtering, ORDER BY, LIMIT, OFFSET, and DISTINCT.</p>"},{"location":"api/api-client/select/#request","title":"Request","text":"<p>Query Parameters:</p> Parameter Description <code>db_name</code> Name of the database <code>namespace</code> Namespace to query <p>Body:</p> Parameter Type Required Default Description <code>columns</code> list of string \u274c all Columns to return. If empty, all columns are returned <code>where</code> list of condition \u274c \u2014 Filter conditions <code>logical_op</code> string \u274c <code>\"and\"</code> How to combine WHERE conditions: <code>\"and\"</code> or <code>\"or\"</code> <code>order_by</code> list of order \u274c \u2014 Sort fields <code>limit</code> int \u274c \u2014 Max rows to return <code>offset</code> int \u274c <code>0</code> Number of rows to skip <code>distinct</code> bool \u274c <code>false</code> Remove duplicate rows <p>WHERE condition object:</p> Field Type Description <code>field</code> string Column name to filter on <code>operator</code> string One of: <code>eq</code>, <code>ne</code>, <code>gt</code>, <code>gte</code>, <code>lt</code>, <code>lte</code>, <code>like</code>, <code>in</code>, <code>notin</code>, <code>isnull</code>, <code>isnotnull</code> <code>value</code> string or list Value to compare against. Use a list for <code>in</code> / <code>notin</code> <p>ORDER BY object:</p> Field Type Description <code>field</code> string Column to sort by <code>descending</code> bool <code>true</code> for descending, <code>false</code> for ascending (default)"},{"location":"api/api-client/select/#behavior","title":"Behavior","text":"<p>Filters are applied in order against RocksDB row metadata. Numeric comparisons (<code>gt</code>, <code>gte</code>, <code>lt</code>, <code>lte</code>) automatically cast values to float. String operations (<code>like</code>) support <code>%</code> wildcards. All conditions are combined using <code>logical_op</code> (<code>and</code> by default).</p>"},{"location":"api/api-client/select/#responses","title":"Responses","text":""},{"location":"api/api-client/select/#200-ok","title":"200 OK","text":"<pre><code>{\n  \"total_rows\": 3,\n  \"execution_time_ms\": 12.4,\n  \"rows\": [\n    { \"id\": \"E001\", \"name\": \"Alice\", \"department\": \"Engineering\", \"salary\": \"120000\" },\n    { \"id\": \"E004\", \"name\": \"Dave\",  \"department\": \"Engineering\", \"salary\": \"95000\"  }\n  ]\n}\n</code></pre> Field Description <code>total_rows</code> Number of rows returned <code>execution_time_ms</code> Query execution time <code>rows</code> Array of row objects"},{"location":"api/api-client/select/#error-responses","title":"Error Responses","text":"Status Condition <code>404</code> Namespace not found <code>500</code> Unexpected internal error"},{"location":"api/api-client/select/#notes","title":"Notes","text":"<ul> <li><code>like</code> operator supports <code>%</code> prefix (<code>%value</code>), suffix (<code>value%</code>), and both (<code>%value%</code>).</li> <li>Numeric comparisons work on string-stored numbers \u2014 they are cast to float at query time.</li> <li>Column projection happens after filtering, so WHERE can reference columns not in <code>columns</code>.</li> </ul>"},{"location":"api/api-client/select/#example","title":"Example","text":"<pre><code>import requests\n\nSERVER_URL = \"http://hbserver:8000\"\nAPI_KEY    = \"yourapitoken\"\n\ndef select(db_name: str, namespace: str, query: dict) -&gt; dict:\n    response = requests.post(\n        f\"{SERVER_URL}/select/\",\n        headers={\"X-API-Key\": API_KEY},\n        params={\"db_name\": db_name, \"namespace\": namespace},\n        json=query,\n    )\n    response.raise_for_status()\n    return response.json()\n\n\nresult = select(\"my_db\", \"employees\", {\n    \"columns\": [\"name\", \"department\", \"salary\"],\n    \"where\": [\n        {\"field\": \"department\", \"operator\": \"eq\",  \"value\": \"Engineering\"},\n        {\"field\": \"salary\",     \"operator\": \"gte\", \"value\": \"100000\"},\n    ],\n    \"logical_op\": \"and\",\n    \"order_by\": [{\"field\": \"salary\", \"descending\": True}],\n    \"limit\": 5,\n})\nprint(result)\n</code></pre> <p>Expected output:</p> <pre><code>{\n  \"total_rows\": 2,\n  \"execution_time_ms\": 8.1,\n  \"rows\": [\n    { \"name\": \"Alice\", \"department\": \"Engineering\", \"salary\": \"120000\" },\n    { \"name\": \"Jack\",  \"department\": \"Engineering\", \"salary\": \"102000\" }\n  ]\n}\n</code></pre>"},{"location":"api/api-client/traverse_fuzzy/","title":"<code>POST /compose/traverse_fuzzy/{db_name}/{namespace}</code>","text":"<p>Performs fuzzy semantic graph traversal starting from a value in a given slot, following a sequence of predicate/edge values hop by hop. Unlike exact graph traversal, each hop uses vector similarity \u2014 enabling semantic path following across loosely structured data.</p>"},{"location":"api/api-client/traverse_fuzzy/#request","title":"Request","text":"<p>Content-Type: <code>application/json</code></p> <p>URL Parameters:</p> Parameter Description <code>db_name</code> Name of the database <code>namespace</code> Namespace within the database <p>Body:</p> Parameter Type Required Default Description <code>start_value</code> string \u2705 \u2014 Starting node value (e.g. <code>\"Alice\"</code>) <code>start_slot</code> string \u2705 \u2014 Slot to search <code>start_value</code> in (e.g. <code>\"subject\"</code>) <code>path</code> list of string \u2705 \u2014 Ordered list of predicate/edge values to follow (e.g. <code>[\"works_at\", \"located_in\"]</code>) <code>hop_threshold</code> float \u274c <code>0.5</code> Minimum similarity score required to follow an edge at each hop <code>max_candidates</code> int \u274c <code>100</code> Maximum candidates to carry forward at each hop <code>top_k</code> int \u274c <code>10</code> Number of final results to return <code>schema_json_data</code> string \u274c <code>null</code> JSON string of the schema. Required if not stored in metadata"},{"location":"api/api-client/traverse_fuzzy/#behavior","title":"Behavior","text":"<p>Hop-by-hop traversal \u2014 Starting from rows where <code>start_slot</code> is similar to <code>start_value</code>, the traversal follows each entry in <code>path</code> as a predicate. At each hop, only candidates above <code>hop_threshold</code> are carried forward, up to <code>max_candidates</code>.</p> <p>Semantic edges \u2014 Because similarity rather than exact matching is used, edges like <code>\"works_at\"</code> will also match <code>\"employed_by\"</code> or <code>\"works_for\"</code> if they are semantically close \u2014 a capability not possible in traditional graph databases.</p> <p>A schema is required \u2014 either stored in metadata from ingest, or provided via <code>schema_json_data</code>.</p>"},{"location":"api/api-client/traverse_fuzzy/#responses","title":"Responses","text":""},{"location":"api/api-client/traverse_fuzzy/#200-ok","title":"200 OK","text":"<pre><code>{\n  \"status\": \"success\",\n  \"query_type\": \"fuzzy_traverse\",\n  \"start_value\": \"Alice\",\n  \"start_slot\": \"subject\",\n  \"path\": [\"works_at\", \"located_in\"],\n  \"count\": 2,\n  \"results\": [\n    {\n      \"_id\": 42,\n      \"_score\": 0.831,\n      \"data\": {\n        \"subject\":   \"Acme Corp\",\n        \"predicate\": \"located_in\",\n        \"object\":    \"New York\"\n      }\n    }\n  ]\n}\n</code></pre> Field Description <code>start_value</code> The starting node value <code>start_slot</code> The slot searched at the start <code>path</code> The edge sequence followed <code>count</code> Number of results returned <code>results</code> Final nodes reached, with <code>_id</code>, <code>_score</code>, and <code>data</code>"},{"location":"api/api-client/traverse_fuzzy/#error-responses","title":"Error Responses","text":"Status Condition <code>400</code> No schema found, none provided, or invalid path <code>404</code> Collection not found <code>500</code> Unexpected internal error"},{"location":"api/api-client/traverse_fuzzy/#notes","title":"Notes","text":"<ul> <li>Raise <code>hop_threshold</code> to require more confident edge matches at each hop; lower it to allow looser semantic traversal.</li> <li>If traversal returns 0 results, try lowering <code>hop_threshold</code> or verifying the path values exist in the data.</li> <li>Schema must be available \u2014 either stored from ingest or passed in <code>schema_json_data</code>.</li> </ul>"},{"location":"api/api-client/traverse_fuzzy/#example","title":"Example","text":"<pre><code>import requests\n\nSERVER_URL = \"http://hbserver:8000\"\nAPI_KEY    = \"yourapitoken\"\n\ndef traverse_fuzzy(db_name: str, namespace: str, start_value: str, start_slot: str, path: list, top_k: int = 10) -&gt; dict:\n    response = requests.post(\n        f\"{SERVER_URL}/compose/traverse_fuzzy/{db_name}/{namespace}\",\n        headers={\"X-API-Key\": API_KEY},\n        json={\n            \"start_value\":    start_value,\n            \"start_slot\":     start_slot,\n            \"path\":           path,\n            \"hop_threshold\":  0.5,\n            \"max_candidates\": 100,\n            \"top_k\":          top_k,\n        },\n    )\n    response.raise_for_status()\n    return response.json()\n\n\nresult = traverse_fuzzy(\n    db_name=\"my_db\",\n    namespace=\"triples\",\n    start_value=\"Alice\",\n    start_slot=\"subject\",\n    path=[\"works_at\", \"located_in\"],\n    top_k=5,\n)\nprint(result)\n</code></pre> <p>Expected output:</p> <pre><code>{\n  \"status\": \"success\",\n  \"query_type\": \"fuzzy_traverse\",\n  \"start_value\": \"Alice\",\n  \"start_slot\": \"subject\",\n  \"path\": [\"works_at\", \"located_in\"],\n  \"count\": 1,\n  \"results\": [\n    { \"_id\": 42, \"_score\": 0.831, \"data\": { \"subject\": \"Acme Corp\", \"predicate\": \"located_in\", \"object\": \"New York\" } }\n  ]\n}\n</code></pre>"},{"location":"api/api-client/unbind/","title":"<code>POST /unbind/{db_name}/{namespace}</code>","text":"<p>Extracts slot values from compositionally-encoded rows using HDC (HyperDimensional Computing) algebra. Unlike <code>/extract</code>, this performs actual inverse binding operations and returns similarity scores indicating extraction confidence.</p>"},{"location":"api/api-client/unbind/#request","title":"Request","text":"<p>Content-Type: <code>application/json</code></p> <p>URL Parameters:</p> Parameter Description <code>db_name</code> Name of the database <code>namespace</code> Namespace within the database <p>Body:</p> Parameter Type Required Default Description <code>row_ids</code> list of int \u2705 \u2014 Row IDs to unbind <code>slots</code> list of string \u2705 \u2014 Slot names to extract (e.g. <code>[\"subject\", \"object\"]</code>) <code>include_scores</code> bool \u274c <code>true</code> Whether to include per-slot similarity scores in the response"},{"location":"api/api-client/unbind/#behavior","title":"Behavior","text":"<p>HDC unbinding \u2014 Each row's hypervector is decoded using the inverse binding operation for the requested slots. The similarity score for each slot indicates how confidently that value was extracted (1.0 = perfect, 0.0 = no signal).</p> <p>Semantic slots \u2014 If any requested slot uses <code>\"semantic\"</code> encoding, embeddings for all stored values in that namespace are loaded into the cache before unbinding, then cleared afterwards.</p> <p>Schema required \u2014 The collection must have been ingested with a Compose schema stored in metadata. If not, use <code>/extract</code> instead.</p> <p>Slot validation \u2014 Requesting an unknown slot (not present in the schema) returns a <code>400</code> error listing available slots.</p>"},{"location":"api/api-client/unbind/#responses","title":"Responses","text":""},{"location":"api/api-client/unbind/#200-ok","title":"200 OK","text":"<pre><code>{\n  \"status\": \"success\",\n  \"count\": 2,\n  \"results\": [\n    {\n      \"_id\": 0,\n      \"subject\": \"Alice\",\n      \"predicate\": \"works_at\",\n      \"object\": \"Acme Corp\",\n      \"_scores\": {\n        \"subject\": 0.97,\n        \"predicate\": 0.88,\n        \"object\": 0.91\n      }\n    },\n    {\n      \"_id\": 5,\n      \"subject\": \"Bob\",\n      \"predicate\": \"reports_to\",\n      \"object\": \"Alice\",\n      \"_scores\": {\n        \"subject\": 0.95,\n        \"predicate\": 0.84,\n        \"object\": 0.89\n      }\n    }\n  ]\n}\n</code></pre> Field Description <code>count</code> Number of rows processed <code>results</code> Array of row objects with extracted slot values <code>_scores</code> Per-slot similarity scores (omitted if <code>include_scores</code> is false)"},{"location":"api/api-client/unbind/#error-responses","title":"Error Responses","text":"Status Condition <code>400</code> Unknown slot name, or collection was not ingested with a Compose schema <code>404</code> Collection or metadata not found <code>500</code> Unexpected internal error"},{"location":"api/api-client/unbind/#notes","title":"Notes","text":"<ul> <li>Requires the collection to have been ingested with a Compose schema (e.g. Triple, or a custom slot schema).</li> <li>For simple field value retrieval without HDC algebra, use <code>/extract</code> instead.</li> <li>Lower similarity scores (below ~0.5) suggest the slot value may be ambiguous or was not strongly encoded.</li> </ul>"},{"location":"api/api-client/unbind/#example","title":"Example","text":"<pre><code>import requests\n\nSERVER_URL = \"http://hbserver:8000\"\nAPI_KEY    = \"yourapitoken\"\n\ndef unbind_slots(db_name: str, namespace: str, row_ids: list, slots: list) -&gt; dict:\n    response = requests.post(\n        f\"{SERVER_URL}/unbind/{db_name}/{namespace}\",\n        headers={\"X-API-Key\": API_KEY},\n        json={\n            \"row_ids\":        row_ids,\n            \"slots\":          slots,\n            \"include_scores\": True,\n        },\n    )\n    response.raise_for_status()\n    return response.json()\n\n\nresult = unbind_slots(\n    db_name=\"my_db\",\n    namespace=\"triples\",\n    row_ids=[0, 5],\n    slots=[\"subject\", \"predicate\", \"object\"],\n)\nprint(result)\n</code></pre> <p>Expected output:</p> <pre><code>{\n  \"status\": \"success\",\n  \"count\": 2,\n  \"results\": [\n    {\n      \"_id\": 0,\n      \"subject\": \"Alice\",\n      \"predicate\": \"works_at\",\n      \"object\": \"Acme Corp\",\n      \"_scores\": { \"subject\": 0.97, \"predicate\": 0.88, \"object\": 0.91 }\n    }\n  ]\n}\n</code></pre>"},{"location":"api/api-client/upload_document/","title":"<code>POST /upload_document/</code>","text":"<p>Uploads and indexes a document (PDF, TXT, DOCX, or JSON) into the vector database. The file is automatically parsed, chunked, and embedded. Requires sufficient storage quota.</p>"},{"location":"api/api-client/upload_document/#request","title":"Request","text":"<p>Content-Type: <code>multipart/form-data</code></p> Parameter Type Required Default Description <code>file</code> file \u2705 \u2014 Document to upload. Supported types: <code>.pdf</code>, <code>.txt</code>, <code>.docx</code>, <code>.json</code> <code>dim</code> int \u274c <code>512</code> Vector dimensionality <code>seed</code> int \u274c <code>42</code> Random seed for the HyperBinder index <code>depth</code> int \u274c <code>3</code> Index depth parameter <code>vector_col</code> string \u274c <code>null</code> Reserved for precomputed vector passthrough (JSON documents only)"},{"location":"api/api-client/upload_document/#behavior","title":"Behavior","text":"<p>File parsing \u2014 The file is routed to the appropriate processor based on its type: - PDF / TXT / DOCX \u2014 Full text is extracted, then split into overlapping chunks (size: 2500 chars, overlap: 200 chars). Each chunk is labeled with a role, parent, and chunk ID via <code>TextLabeler</code>. - JSON \u2014 Cells are extracted directly via <code>JSONProcessor</code>, preserving structure.</p> <p>Namespace isolation \u2014 Each upload gets its own auto-generated namespace in the format <code>document_upload_{8-char UUID}</code>, so uploads never overwrite each other. All uploads share the <code>fractal_db</code> database.</p> <p>Vector handling has two modes: - <code>generated</code> \u2014 Embeddings are computed server-side using the app's sentence model - <code>precomputed</code> \u2014 If cells carry an <code>embedding</code> field (JSON documents), those vectors are used directly and auto-normalized for cosine similarity</p> <p>Schema \u2014 The schema is fixed for all document uploads with the fields: <code>value</code>, <code>chunk_id</code>, <code>parent</code>, <code>role</code>.</p>"},{"location":"api/api-client/upload_document/#responses","title":"Responses","text":""},{"location":"api/api-client/upload_document/#200-ok","title":"200 OK","text":"<pre><code>{\n  \"status\": \"success\",\n  \"namespace\": \"document_upload_3f9a1c2e\",\n  \"total_cells\": 87,\n  \"vector_source\": \"generated\"\n}\n</code></pre> Field Description <code>status</code> Always <code>\"success\"</code> on a successful request <code>namespace</code> Auto-generated namespace assigned to this upload \u2014 save this to query the document later <code>total_cells</code> Number of chunks/cells indexed <code>vector_source</code> <code>\"generated\"</code> or <code>\"precomputed\"</code>"},{"location":"api/api-client/upload_document/#error-responses","title":"Error Responses","text":"Status Condition <code>400</code> No file provided, or unsupported file type <code>413</code> Uploaded file exceeds the maximum allowed size <code>500</code> Unexpected internal server error"},{"location":"api/api-client/upload_document/#notes","title":"Notes","text":"<ul> <li>Save the returned <code>namespace</code> \u2014 it is the only way to reference this document in subsequent query calls.</li> <li>Unlike <code>/build_ingest_data/</code>, the namespace is always auto-generated and cannot be set manually.</li> <li>All document uploads share <code>db_name = \"fractal_db\"</code> internally.</li> <li>Storage usage is recorded after every successful upload via <code>record_ingest()</code>.</li> </ul>"},{"location":"api/api-client/upload_document/#example","title":"Example","text":"<pre><code>import requests\n\nSERVER_URL = \"http://hbserver:8000\"\nAPI_KEY    = \"yourapitoken\"\n\ndef upload_document(filepath: str) -&gt; dict:\n    with open(filepath, \"rb\") as f:\n        response = requests.post(\n            f\"{SERVER_URL}/upload_document/\",\n            headers={\"X-API-Key\": API_KEY},\n            files={\n                \"file\": (filepath.split(\"/\")[-1], f)\n            },\n            data={\n                \"dim\":   512,  # optional, defaults to 512\n                \"seed\":  42,   # optional, defaults to 42\n                \"depth\": 3,    # optional, defaults to 3\n            },\n        )\n    response.raise_for_status()\n    return response.json()\n\n\nresult = upload_document(r\"yourpdf.pdf\")\nprint(result)\n</code></pre> <p>Expected output:</p> <pre><code>{\n  \"status\": \"success\",\n  \"namespace\": \"document_upload_3f9a1c2e\",\n  \"total_cells\": 87,\n  \"vector_source\": \"generated\"\n}\n</code></pre>"},{"location":"api/compose/","title":"Compose API","text":"<p>The Compose system provides schema-aware data encoding and querying using Hyperdimensional Computing.</p>"},{"location":"api/compose/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      COMPOUNDS                               \u2502\n\u2502       Domain-specific structures (convenience wrappers)      \u2502\n\u2502   KnowledgeGraph, TimeSeries, Hierarchy, Document, Network   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                      MOLECULES                               \u2502\n\u2502            Core compositional building blocks                \u2502\n\u2502       Pair, Triple, Bundle, Sequence, Tree, Graph           \u2502\n\u251c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500 \u2524\n\u2502                  ATOMS (Advanced Only)                       \u2502\n\u2502              Low-level HDC primitives                        \u2502\n\u2502            bind, unbind, bundle, similarity                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api/compose/#quick-reference","title":"Quick Reference","text":"Component Description Link Molecules Core structures (Pair, Triple, etc.) Reference Compounds Domain templates (KnowledgeGraph, etc.) Reference Fields Field configuration and encoding Reference Query Builder Schema-aware query interface Reference Intersections Cross-collection joins Reference"},{"location":"api/compose/#common-imports","title":"Common Imports","text":"<pre><code># Molecules\nfrom hybi.compose import Pair, Triple, Bundle, Sequence, Tree, Graph\n\n# Compounds\nfrom hybi.compose import KnowledgeGraph, Catalog, TimeSeries, Hierarchy\n\n# Configuration\nfrom hybi.compose import Field, Encoding, NumericScale\n\n# Intersections (cross-collection queries)\nfrom hybi.compose.intersections import (\n    Intersection, IntersectionMode, JoinConfig,\n    JoinedResult, JoinedResultSet,\n    Link, LinkSet,  # For flexible (cross-encoding) intersections\n)\n\n# Query results\nfrom hybi.compose import ComposeResult, ComposeResultSet\n</code></pre>"},{"location":"api/compose/#basic-usage","title":"Basic Usage","text":"<pre><code>from hybi import HyperBinder\nfrom hybi.compose import Triple, Field, Encoding\n\nhb = HyperBinder()\n\n# Define schema\nschema = Triple(\n    subject=Field(\"entity\"),\n    predicate=Field(\"relation\", encoding=Encoding.EXACT),\n    object=Field(\"target\"),\n)\n\n# Ingest with schema\nhb.ingest(df, collection=\"facts\", schema=schema)\n\n# Query with schema\nq = hb.query(\"facts\", schema=schema)\nresults = q.find(subject=\"Einstein\")\n</code></pre>"},{"location":"api/compose/compounds/","title":"Compounds","text":"<p>Compounds are pre-configured molecules for common domain patterns.</p>"},{"location":"api/compose/compounds/#overview","title":"Overview","text":"Compound Based On Use Case KnowledgeGraph Triple Entity-relation-entity facts Catalog Bundle Generic tabular data (read-heavy) RelationalTable Row Mutable tables with CRUD TimeSeries Sequence Time-ordered data Hierarchy Tree Org charts, taxonomies Document Bundle Document chunks with metadata Network Graph Social graphs, citations <p>Compounds expand to molecules at definition time, so they have the same capabilities once created.</p>"},{"location":"api/compose/compounds/#knowledgegraph","title":"KnowledgeGraph","text":"<p>Pre-configured Triple for knowledge graph data.</p> <pre><code>from hybi.compose import KnowledgeGraph\n\nschema = KnowledgeGraph(\n    entity_field=\"person\",\n    relation_field=\"relationship\",\n    # Defaults: SEMANTIC for entities, EXACT for relations\n)\n</code></pre> <p>Equivalent to: <pre><code>Triple(\n    subject=Field(\"person\", encoding=Encoding.SEMANTIC),\n    predicate=Field(\"relationship\", encoding=Encoding.EXACT),\n    object=Field(\"target\", encoding=Encoding.SEMANTIC),\n)\n</code></pre></p>"},{"location":"api/compose/compounds/#hybi.compose.KnowledgeGraph","title":"<code>hybi.compose.KnowledgeGraph</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseMolecule</code></p> <p>Knowledge graph compound: entity-relation-entity triples.</p> <p>A convenience wrapper around Triple with sensible defaults for knowledge graph use cases (semantic entities, exact relations).</p> Expands to <p>Triple(     subject=Field(entity_field, encoding=SEMANTIC),     predicate=Field(relation_field, encoding=EXACT),     object=Field(entity_field, encoding=SEMANTIC), )</p> Example"},{"location":"api/compose/compounds/#hybi.compose.KnowledgeGraph--simple-usage-defaults-to-entityrelation-columns","title":"Simple usage - defaults to entity/relation columns","text":"<p>schema = KnowledgeGraph() hb.ingest(facts_df, collection=\"kg\", schema=schema)</p>"},{"location":"api/compose/compounds/#hybi.compose.KnowledgeGraph--custom-field-names","title":"Custom field names","text":"<p>schema = KnowledgeGraph( ...     entity_field=\"person\", ...     relation_field=\"relationship\", ... )</p>"},{"location":"api/compose/compounds/#hybi.compose.KnowledgeGraph--with-custom-encoding","title":"With custom encoding","text":"<p>schema = KnowledgeGraph( ...     entity_field=\"entity\", ...     relation_field=\"predicate\", ...     entity_encoding=Encoding.EXACT,  # For IDs instead of text ... )</p>"},{"location":"api/compose/compounds/#hybi.compose.KnowledgeGraph.__init__","title":"<code>__init__(entity_field='entity', relation_field='relation', subject_field=None, object_field=None, entity_encoding=Encoding.SEMANTIC, relation_encoding=Encoding.EXACT, entity_weight=1.0, relation_weight=1.0)</code>","text":""},{"location":"api/compose/compounds/#catalog","title":"Catalog","text":"<p>Pre-configured Bundle for tabular data.</p> <pre><code>from hybi.compose import Catalog, Field, Encoding\n\nschema = Catalog(\n    columns={\n        \"name\": Field(encoding=Encoding.SEMANTIC, weight=1.5),\n        \"category\": Field(encoding=Encoding.EXACT),\n        \"price\": Field(encoding=Encoding.NUMERIC, similar_within=50),\n    }\n)\n</code></pre>"},{"location":"api/compose/compounds/#hybi.compose.Catalog","title":"<code>hybi.compose.Catalog</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseMolecule</code></p> <p>Catalog compound: searchable collection with SQL-like operations.</p> <p>A convenience wrapper around Bundle optimized for tabular data with a familiar SQL-like query interface. Catalog provides a bridge between traditional relational thinking and hyperdimensional computing.</p> Expands to <p>Bundle(fields={     column_name: Field(encoding=..., weight=...),     ... })</p> <p>Unlike pure relational tables, Catalog supports: - Semantic search: Find rows by meaning, not just exact values - Fuzzy matching: Similarity-based lookups with configurable thresholds - Vector joins: Join collections by semantic similarity, not just key equality</p> Operations Map Catalog Method HDC Operation select() Field projection (SelectQuery) where() Exact filter + similarity search join() JoinQuery (exact or semantic) aggregate() AggregateQuery (GROUP BY) search() Vector similarity search Example Notes <ul> <li>primary_key is metadata only; HDC doesn't require explicit keys</li> <li>For semantic joins, use Encoding.SEMANTIC on join columns</li> <li>The underlying Bundle uses bundle encoding (lossy but searchable)</li> </ul>"},{"location":"api/compose/compounds/#hybi.compose.Catalog--define-a-products-catalog","title":"Define a products catalog","text":"<p>schema = Catalog( ...     columns={ ...         \"name\": Field(encoding=Encoding.SEMANTIC, weight=2.0), ...         \"description\": Field(encoding=Encoding.SEMANTIC), ...         \"category\": Field(encoding=Encoding.EXACT), ...         \"price\": Field(encoding=Encoding.NUMERIC, similar_within=50), ...     }, ...     primary_key=\"id\", ... ) hb.ingest(products_df, collection=\"products\", schema=schema)</p>"},{"location":"api/compose/compounds/#hybi.compose.Catalog--traditional-style-query","title":"Traditional-style query","text":"<p>results = hb.query(\"products\").where(category=\"electronics\")</p>"},{"location":"api/compose/compounds/#hybi.compose.Catalog--semantic-query-hdc-advantage","title":"Semantic query (HDC advantage)","text":"<p>results = hb.query(\"products\").search(\"lightweight laptop for travel\")</p>"},{"location":"api/compose/compounds/#hybi.compose.Catalog--join-with-another-catalog","title":"Join with another catalog","text":"<p>order_schema = Catalog( ...     columns={\"product_id\": Field(encoding=Encoding.EXACT), ...} ... ) joined = hb.query(\"orders\").join(\"products\", on=\"product_id\")</p>"},{"location":"api/compose/compounds/#hybi.compose.Catalog--aggregation","title":"Aggregation","text":"<p>stats = hb.query(\"products\").aggregate( ...     group_by=[\"category\"], ...     aggregations={\"avg_price\": (\"price\", \"avg\")} ... )</p>"},{"location":"api/compose/compounds/#hybi.compose.Catalog.__init__","title":"<code>__init__(columns=dict(), primary_key=None, catalog_name=None)</code>","text":""},{"location":"api/compose/compounds/#relationaltable","title":"RelationalTable","text":"<p>SQL-like table with full CRUD support.</p> <p>RelationalTable provides familiar relational database semantics with atomic row-level operations. Unlike Catalog (which is optimized for search), RelationalTable uses structured encoding which enables true field-level updates.</p>"},{"location":"api/compose/compounds/#catalog-vs-relationaltable","title":"Catalog vs RelationalTable","text":"Aspect Catalog RelationalTable Encoding Search-optimized Structured Search Fast Moderate UPDATE/DELETE Not supported Full support Use case Search catalog Mutable tables <p>Use Catalog when you primarily search and append data. Use RelationalTable when you need UPDATE/DELETE operations.</p> <pre><code>from hybi.compose import RelationalTable, Field, Encoding\n\nschema = RelationalTable(\n    columns={\n        \"user_id\": Field(encoding=Encoding.EXACT),\n        \"email\": Field(encoding=Encoding.EXACT),\n        \"name\": Field(encoding=Encoding.SEMANTIC),\n        \"salary\": Field(encoding=Encoding.NUMERIC, similar_within=10000),\n    },\n    primary_key=\"user_id\",\n)\n</code></pre> <p>CRUD Operations:</p> <pre><code># Ingest data\nhb.ingest(users_df, collection=\"users\", schema=schema)\n\n# Read by primary key\nuser = hb.query(\"users\", schema).get(user_id=\"U001\")\n\n# Update fields atomically\nhb.update(\n    \"users\",\n    where={\"user_id\": \"U001\"},\n    set={\"email\": \"new@example.com\", \"salary\": 120000},\n    schema=schema,\n)\n\n# Delete row\nhb.delete(\"users\", where={\"user_id\": \"U001\"}, schema=schema)\n\n# Upsert (insert or update)\nhb.upsert(\"users\", row={\"user_id\": \"U001\", ...}, schema=schema)\n</code></pre> <p>Equivalent to: <pre><code>Row(\n    primary_key=Field(\"user_id\", encoding=Encoding.EXACT),\n    fields={\n        \"email\": Field(encoding=Encoding.EXACT),\n        \"name\": Field(encoding=Encoding.SEMANTIC),\n        \"salary\": Field(encoding=Encoding.NUMERIC, similar_within=10000),\n    },\n)\n</code></pre></p>"},{"location":"api/compose/compounds/#search-crud-architecture","title":"Search &amp; CRUD Architecture","text":"<p>For optimal performance, use Catalog for search and RelationalTable for CRUD:</p> <pre><code>flowchart TB\n    subgraph Catalog[\"CATALOG (Search)\"]\n        C1[Search-optimized&lt;br/&gt;fast]\n        C2[Semantic Discovery]\n        C1 --&gt; C2\n    end\n\n    subgraph RelationalTable[\"RELATIONAL TABLE (CRUD)\"]\n        R1[Structured&lt;br/&gt;exact]\n        R2[PK Lookups]\n        R1 --&gt; R2\n    end\n\n    C2 --&gt; Bridge\n    R2 --&gt; Bridge\n    Bridge[BRIDGE&lt;br/&gt;Primary Keys] --&gt; Mutations[Deterministic Mutations]</code></pre> <p>Recommended pattern: - Use Catalog for semantic search (optimized for similarity matching) - Use RelationalTable for CRUD (optimized for exact field updates) - Bridge between them using shared primary keys</p> <p>Single-schema alternative: RelationalTable can handle both search and CRUD, but search performance is slower than dedicated Catalog.</p>"},{"location":"api/compose/compounds/#fuzzy-to-exact-bridge-pattern","title":"Fuzzy-to-Exact Bridge Pattern","text":"<p>When you need to combine semantic discovery with exact mutations, use the bridge pattern:</p> <ol> <li>Fuzzy search casts a wide net using semantic similarity</li> <li>Exact filters narrow to deterministic boundaries</li> <li>CRUD via PKs operates on the refined set</li> </ol> <pre><code># 1. Semantic search finds candidates\ncandidates = hb.query(\"users\", schema).search(\"machine learning expert\", top_k=50)\n\n# 2. Exact filtering narrows to deterministic set\nrefined = [r for r in candidates\n           if r.data[\"department\"] == \"Engineering\"\n           and r.data[\"status\"] == \"active\"]\n\n# 3. CRUD via primary keys (safe - deterministic)\nfor r in refined:\n    hb.update(\"users\", where={\"user_id\": r.data[\"user_id\"]}, set={...}, schema=schema)\n</code></pre> <p>This pattern leverages fuzzy search for discovery (\"I don't know the exact term\") while ensuring mutations operate on deterministic, exactly-identified rows.</p> <p>See Fuzzy-to-Exact Pattern for a complete implementation.</p>"},{"location":"api/compose/compounds/#hybi.compose.RelationalTable","title":"<code>hybi.compose.RelationalTable</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseMolecule</code></p> <p>SQL-like table with full CRUD support.</p> <p>RelationalTable provides familiar relational database semantics: - Row-level UPDATE: Modify individual fields - Row-level DELETE: Remove rows by primary key - Field extraction: Read individual field values cleanly - ACID guarantees: Single-row atomicity</p> <p>Unlike Catalog (which uses lossy Bundle encoding optimized for search), RelationalTable uses Row encoding with chain binding, which is lossless. This enables true field-level updates without re-encoding entire rows.</p> Trade-offs vs Catalog Aspect Catalog RelationalTable Encoding Bundle (lossy) Row (lossless) Search Fast Moderate UPDATE/DELETE Not supported Full support Use case Search catalog Mutable tables <p>Use RelationalTable when you need UPDATE/DELETE operations. Use Catalog when you primarily search and append data.</p> Expands to <p>Row(     primary_key=Field(pk_column, encoding=EXACT),     fields={...other columns...}, )</p> Example Notes <ul> <li>Primary key is required and must use EXACT encoding</li> <li>Primary key cannot be updated (immutable row identity)</li> <li>Updates are atomic at the row level</li> </ul>"},{"location":"api/compose/compounds/#hybi.compose.RelationalTable--define-a-users-table","title":"Define a users table","text":"<p>schema = RelationalTable( ...     columns={ ...         \"user_id\": Field(encoding=Encoding.EXACT), ...         \"email\": Field(encoding=Encoding.EXACT), ...         \"name\": Field(encoding=Encoding.SEMANTIC), ...         \"salary\": Field(encoding=Encoding.NUMERIC), ...     }, ...     primary_key=\"user_id\", ... ) hb.ingest(users_df, collection=\"users\", schema=schema)</p>"},{"location":"api/compose/compounds/#hybi.compose.RelationalTable--read-by-primary-key","title":"Read by primary key","text":"<p>user = hb.query(\"users\", schema).get(user_id=\"U001\")</p>"},{"location":"api/compose/compounds/#hybi.compose.RelationalTable--update-fields","title":"Update fields","text":"<p>hb.update( ...     \"users\", ...     where={\"user_id\": \"U001\"}, ...     set={\"email\": \"new@example.com\"}, ...     schema=schema, ... )</p>"},{"location":"api/compose/compounds/#hybi.compose.RelationalTable--delete-row","title":"Delete row","text":"<p>hb.delete(\"users\", where={\"user_id\": \"U001\"}, schema=schema)</p>"},{"location":"api/compose/compounds/#hybi.compose.RelationalTable.columns","title":"<code>columns = dataclass_field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Column definitions mapping column names to Field configurations.</p> <p>Must include the primary key column.</p> Example <p>columns={     \"id\": Field(encoding=Encoding.EXACT),     \"name\": Field(encoding=Encoding.SEMANTIC),     \"email\": Field(encoding=Encoding.EXACT), }</p>"},{"location":"api/compose/compounds/#hybi.compose.RelationalTable.primary_key","title":"<code>primary_key = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name of the primary key column.</p> <p>Required. The referenced column must: - Exist in columns - Use EXACT encoding</p> <p>The primary key provides: - O(1) row lookup via PK index - Row identity for UPDATE/DELETE operations - Uniqueness constraint on ingest</p>"},{"location":"api/compose/compounds/#hybi.compose.RelationalTable.__init__","title":"<code>__init__(columns=dict(), primary_key=None, table_name=None)</code>","text":""},{"location":"api/compose/compounds/#timeseries","title":"TimeSeries","text":"<p>Pre-configured molecule for time-ordered data. Supports two modes:</p>"},{"location":"api/compose/compounds/#temporal-mode-with-timestamp_field","title":"Temporal Mode (with timestamp_field)","text":"<p>When <code>timestamp_field</code> is provided, expands to a Pair enabling temporal queries:</p> <pre><code>from hybi.compose import TimeSeries\n\nschema = TimeSeries(\n    value_field=\"measurement\",\n    timestamp_field=\"recorded_at\",  # Enables at_time(), time_range(), when()\n)\n</code></pre> <p>Supported queries: <code>search</code>, <code>find</code>, <code>at_time</code>, <code>time_range</code>, <code>when</code></p>"},{"location":"api/compose/compounds/#positional-mode-without-timestamp_field","title":"Positional Mode (without timestamp_field)","text":"<p>When <code>timestamp_field</code> is None, expands to a Sequence enabling position-based queries:</p> <pre><code>schema = TimeSeries(\n    value_field=\"message\",\n    timestamp_field=None,  # Position-based mode\n    position_encoding=\"random\",\n    max_length=512,\n)\n</code></pre> <p>Supported queries: <code>search</code>, <code>at</code>, <code>contains</code>, <code>prefix</code></p> <p>See <code>timeseries_demo.py</code> for a complete example using positional mode.</p>"},{"location":"api/compose/compounds/#hybi.compose.TimeSeries","title":"<code>hybi.compose.TimeSeries</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseMolecule</code></p> <p>Time series compound: temporal data with timestamp-value binding.</p> <p>TimeSeries encodes time-indexed data using hyperdimensional temporal binding. When a timestamp_field is provided, each row is encoded as:</p> <pre><code>timestamp \u229b value\n</code></pre> <p>This enables powerful temporal queries: - at_time(ts): Find values at/near a specific timestamp - time_range(start, end): Find values within a time window - when(value): Find timestamps when a value occurred</p> <p>Expands to (when timestamp_field provided):     Pair(         left=Field(timestamp_field, encoding=TEMPORAL),         right=Field(value_field, encoding=value_encoding),     )</p> <p>Expands to (when timestamp_field is None - legacy mode):     Sequence(         item=Field(value_field, encoding=value_encoding),         position_encoding=\"sinusoidal\",         max_length=max_length,     )</p> Example"},{"location":"api/compose/compounds/#hybi.compose.TimeSeries--recommended-with-timestamp-field-enables-temporal-queries","title":"Recommended: with timestamp field (enables temporal queries)","text":"<p>schema = TimeSeries( ...     value_field=\"temperature\", ...     timestamp_field=\"recorded_at\", ...     value_encoding=Encoding.NUMERIC, ... ) hb.ingest(sensor_df, collection=\"readings\", schema=schema)</p>"},{"location":"api/compose/compounds/#hybi.compose.TimeSeries--query-what-was-the-temperature-at-2pm","title":"Query: What was the temperature at 2pm?","text":"<p>results = hb.query(\"readings\").at_time(\"2024-01-15 14:00:00\")</p>"},{"location":"api/compose/compounds/#hybi.compose.TimeSeries--query-temperatures-between-1pm-and-3pm","title":"Query: Temperatures between 1pm and 3pm","text":"<p>results = hb.query(\"readings\").time_range( ...     start=\"2024-01-15 13:00:00\", ...     end=\"2024-01-15 15:00:00\", ... )</p>"},{"location":"api/compose/compounds/#hybi.compose.TimeSeries--legacy-mode-without-timestamp-uses-row-position","title":"Legacy mode: without timestamp (uses row position)","text":"<p>schema = TimeSeries(value_field=\"price\")  # timestamp_field=None</p>"},{"location":"api/compose/compounds/#hybi.compose.TimeSeries--note-this-mode-only-supports-positional-queries-not-temporal","title":"Note: This mode only supports positional queries, not temporal","text":""},{"location":"api/compose/compounds/#hybi.compose.TimeSeries.__init__","title":"<code>__init__(value_field='value', timestamp_field=None, value_encoding=Encoding.SEMANTIC, value_weight=1.0, timestamp_weight=1.0, position_encoding='sinusoidal', max_length=512)</code>","text":""},{"location":"api/compose/compounds/#hierarchy","title":"Hierarchy","text":"<p>Pre-configured Tree for parent-child relationships.</p> <pre><code>from hybi.compose import Hierarchy\n\nschema = Hierarchy(\n    node_field=\"employee\",\n    parent_field=\"manager\",\n)\n</code></pre>"},{"location":"api/compose/compounds/#hybi.compose.Hierarchy","title":"<code>hybi.compose.Hierarchy</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseMolecule</code></p> <p>Hierarchy compound: parent-child organizational structures.</p> <p>A convenience wrapper around Tree optimized for hierarchical data like org charts, file systems, taxonomies, or nested categories.</p> Expands to <p>Tree(     child=Field(node_field, encoding=node_encoding),     parent=Field(parent_field, encoding=node_encoding),     level=Field(level_field) if level_field else None, )</p> Example"},{"location":"api/compose/compounds/#hybi.compose.Hierarchy--org-chart","title":"Org chart","text":"<p>schema = Hierarchy( ...     node_field=\"employee\", ...     parent_field=\"manager\", ... ) hb.ingest(org_df, collection=\"org\", schema=schema)</p>"},{"location":"api/compose/compounds/#hybi.compose.Hierarchy--file-system-with-depth-tracking","title":"File system with depth tracking","text":"<p>schema = Hierarchy( ...     node_field=\"path\", ...     parent_field=\"parent_path\", ...     level_field=\"depth\", ... )</p>"},{"location":"api/compose/compounds/#hybi.compose.Hierarchy--taxonomy-with-exact-matching","title":"Taxonomy with exact matching","text":"<p>schema = Hierarchy( ...     node_field=\"category\", ...     parent_field=\"parent_category\", ...     node_encoding=Encoding.EXACT, ... )</p>"},{"location":"api/compose/compounds/#hybi.compose.Hierarchy.__init__","title":"<code>__init__(node_field='node', parent_field='parent', level_field=None, node_encoding=Encoding.SEMANTIC, node_weight=1.0)</code>","text":""},{"location":"api/compose/compounds/#document","title":"Document","text":"<p>Pre-configured Bundle for document chunks.</p> <pre><code>from hybi.compose import Document, Field, Encoding\n\nschema = Document(\n    content_field=\"text\",\n    metadata_fields={\n        \"source\": Field(),\n        \"page\": Field(encoding=Encoding.NUMERIC),\n        \"section\": Field(encoding=Encoding.EXACT),\n    },\n)\n</code></pre>"},{"location":"api/compose/compounds/#hybi.compose.Document","title":"<code>hybi.compose.Document</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseMolecule</code></p> <p>Document compound: structured content with metadata.</p> <p>A convenience wrapper around Bundle optimized for document storage with a primary content field and associated metadata fields.</p> Expands to <p>Bundle(fields={     content_field: Field(encoding=SEMANTIC, weight=content_weight),     **{name: field for name, field in metadata_fields.items()}, })</p> Example"},{"location":"api/compose/compounds/#hybi.compose.Document--simple-document-with-title-and-content","title":"Simple document with title and content","text":"<p>schema = Document( ...     content_field=\"body\", ...     metadata_fields={\"title\": Field(), \"author\": Field()}, ... ) hb.ingest(docs_df, collection=\"docs\", schema=schema)</p>"},{"location":"api/compose/compounds/#hybi.compose.Document--article-with-categories","title":"Article with categories","text":"<p>schema = Document( ...     content_field=\"text\", ...     content_weight=2.0,  # Boost content in search ...     metadata_fields={ ...         \"headline\": Field(weight=1.5), ...         \"category\": Field(encoding=Encoding.EXACT), ...         \"published_date\": Field(encoding=Encoding.TEMPORAL), ...     }, ... )</p>"},{"location":"api/compose/compounds/#hybi.compose.Document.__init__","title":"<code>__init__(content_field='content', content_encoding=Encoding.SEMANTIC, content_weight=1.0, metadata_fields=None)</code>","text":""},{"location":"api/compose/compounds/#network","title":"Network","text":"<p>Pre-configured Graph for network data.</p> <pre><code>from hybi.compose import Network\n\nschema = Network(\n    node_field=\"user\",\n    edge_field=\"interaction\",\n    directed=True,\n    # Optional: use separate columns for source/target nodes\n    # source_field=\"from_user\",\n    # target_field=\"to_user\",\n)\n</code></pre>"},{"location":"api/compose/compounds/#hybi.compose.Network","title":"<code>hybi.compose.Network</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseMolecule</code></p> <p>Network compound: node-edge-node graph structures.</p> <p>A convenience wrapper around Graph optimized for social networks, citation graphs, dependency graphs, and other network structures.</p> Expands to <p>Graph(     node=Field(node_field, encoding=node_encoding),     edge=Field(edge_field, encoding=edge_encoding),     directed=directed, )</p> Example"},{"location":"api/compose/compounds/#hybi.compose.Network--social-network","title":"Social network","text":"<p>schema = Network( ...     node_field=\"user\", ...     edge_field=\"connection_type\", ... ) hb.ingest(social_df, collection=\"social\", schema=schema)</p>"},{"location":"api/compose/compounds/#hybi.compose.Network--citation-network-undirected","title":"Citation network (undirected)","text":"<p>schema = Network( ...     node_field=\"paper_id\", ...     edge_field=\"citation_type\", ...     node_encoding=Encoding.EXACT, ...     directed=False, ... )</p>"},{"location":"api/compose/compounds/#hybi.compose.Network--dependency-graph","title":"Dependency graph","text":"<p>schema = Network( ...     node_field=\"package\", ...     edge_field=\"dependency_type\", ...     source_field=\"dependent\", ...     target_field=\"dependency\", ... )</p>"},{"location":"api/compose/compounds/#hybi.compose.Network.__init__","title":"<code>__init__(node_field='node', edge_field='edge', source_field=None, target_field=None, node_encoding=Encoding.SEMANTIC, edge_encoding=Encoding.EXACT, node_weight=1.0, edge_weight=1.0, directed=True)</code>","text":""},{"location":"api/compose/compounds/#when-to-use-compounds-vs-molecules","title":"When to Use Compounds vs Molecules","text":"<p>Use compounds when:</p> <ul> <li>Your data fits a common pattern</li> <li>You want sensible encoding defaults</li> <li>You're prototyping quickly</li> </ul> <p>Use molecules when:</p> <ul> <li>You need custom encodings per field</li> <li>You're nesting structures</li> <li>You need fine-grained control over weights</li> </ul> <p>See Molecules vs Compounds for detailed guidance.</p>"},{"location":"api/compose/compounds/#example-code","title":"Example Code","text":"<p>Complete runnable examples for each compound type:</p> Compound Example File Description KnowledgeGraph <code>knowledge_graph_demo.py</code> Entity-relation-entity facts with traversal Document <code>document_demo.py</code> Document chunks with metadata Hierarchy <code>hierarchy_demo.py</code> Org charts and taxonomies TimeSeries <code>timeseries_demo.py</code> Time-ordered data Network <code>network_demo.py</code> Social graphs and citations Catalog <code>product_catalog_demo.py</code> Product catalogs with search RelationalTable <code>fuzzy_to_exact_demo.py</code> CRUD with fuzzy-to-exact pattern <p>Run any example from the SDK directory:</p> <pre><code>cd sdk\npython examples/compose/knowledge_graph_demo.py\n</code></pre> <p>See Examples README for the full example index.</p>"},{"location":"api/compose/fields/","title":"Fields &amp; Encoding","text":"<p>Configure how individual fields are encoded into hypervectors.</p>"},{"location":"api/compose/fields/#field","title":"Field","text":"<p>The <code>Field</code> class configures a single column's encoding behavior.</p> <pre><code>from hybi.compose import Field, Encoding\n\nField(\n    name=\"description\",           # Column name (optional, inferred from slot)\n    encoding=Encoding.SEMANTIC,   # How to encode values\n    weight=1.5,                   # Importance in similarity (default 1.0)\n    similar_within=0.1,           # Scale for NUMERIC encoding\n    searchable=True,              # Include in search (default True)\n)\n</code></pre>"},{"location":"api/compose/fields/#hybi.compose.Field","title":"<code>hybi.compose.Field</code>  <code>dataclass</code>","text":"<p>Configuration for a single field in a Compose schema.</p> <p>Field.name specifies which DataFrame COLUMN to use for this slot. The slot name (e.g., \"subject\" in Triple) is separate from the column name.</p> Column Name Resolution <ol> <li>If Field.name is provided, use that as the column name</li> <li>If Field.name is None, use the slot name as the column name</li> </ol> Example"},{"location":"api/compose/fields/#hybi.compose.Field--column-name-matches-slot-name-most-common","title":"Column name matches slot name (most common)","text":"<p>Triple(     subject=Field(\"subject\"),  # Uses column \"subject\"     predicate=Field(\"predicate\"),     object=Field(\"object\"), )</p>"},{"location":"api/compose/fields/#hybi.compose.Field--column-name-differs-from-slot-name","title":"Column name differs from slot name","text":"<p>Triple(     subject=Field(\"entity_name\"),  # Uses column \"entity_name\" for subject slot     predicate=Field(\"relation_type\"),     object=Field(\"target_entity\"), )</p>"},{"location":"api/compose/fields/#hybi.compose.Field--field-with-custom-encoding","title":"Field with custom encoding","text":"<p>Field(\"category\", encoding=Encoding.EXACT)</p>"},{"location":"api/compose/fields/#hybi.compose.Field--field-with-weight-boost","title":"Field with weight boost","text":"<p>Field(\"description\", weight=2.0)</p>"},{"location":"api/compose/fields/#hybi.compose.Field--numeric-field-with-scale-preset-recommended","title":"Numeric field with scale preset (recommended)","text":"<p>Field(\"price\", encoding=Encoding.NUMERIC, similar_within=NumericScale.DOLLARS)</p>"},{"location":"api/compose/fields/#hybi.compose.Field--numeric-field-with-custom-scale","title":"Numeric field with custom scale","text":"<p>Field(\"score\", encoding=Encoding.NUMERIC, similar_within=25)</p>"},{"location":"api/compose/fields/#hybi.compose.Field.name","title":"<code>name = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>DataFrame column name to use for this slot.</p> <p>If None, the slot name is used as the column name. Example: Triple(subject=Field()) uses the \"subject\" column.</p>"},{"location":"api/compose/fields/#hybi.compose.Field.encoding","title":"<code>encoding = Encoding.SEMANTIC</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>How values are encoded into hypervectors.</p>"},{"location":"api/compose/fields/#hybi.compose.Field.weight","title":"<code>weight = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Importance weight in similarity calculations.</p> <p>Higher weights make this field more influential in search. The final score is a weighted average: \u03a3(similarity \u00d7 weight) / \u03a3(weight).</p>"},{"location":"api/compose/fields/#hybi.compose.Field.similar_within","title":"<code>similar_within = 0.1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Scale for NUMERIC encoding: the distance at which values are \"similar\".</p> <p>Values within this distance have ~60% similarity. Values at 2\u00d7 this distance have ~14% similarity. Values at 3\u00d7 this distance have ~1% similarity.</p> Use NumericScale presets for common data types <p>similar_within=NumericScale.DOLLARS     # $50 difference = similar similar_within=NumericScale.RATING_5    # 0.5 star difference = similar similar_within=NumericScale.PERCENTAGE  # 5 points difference = similar</p> Or use a custom number <p>similar_within=100  # 100 units difference = similar</p> <p>Only used when encoding=Encoding.NUMERIC. Default: 0.1 (suitable for normalized 0-1 data).</p>"},{"location":"api/compose/fields/#hybi.compose.Field.searchable","title":"<code>searchable = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to include this field in search queries.</p>"},{"location":"api/compose/fields/#hybi.compose.Field.required","title":"<code>required = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether the field must be present (not null) in data.</p>"},{"location":"api/compose/fields/#hybi.compose.Field.__init__","title":"<code>__init__(name=None, encoding=Encoding.SEMANTIC, weight=1.0, similar_within=0.1, searchable=True, required=False)</code>","text":""},{"location":"api/compose/fields/#encoding","title":"Encoding","text":"<p>The <code>Encoding</code> enum specifies how values become vectors.</p> Encoding Behavior Use When <code>SEMANTIC</code> Similar values \u2192 similar vectors Text, names, descriptions <code>EXACT</code> Each unique value \u2192 distinct vector IDs, categories, types <code>NUMERIC</code> Close numbers \u2192 similar vectors Prices, counts, ratings <code>TEMPORAL</code> Time-aware encoding for dates/timestamps Timestamps, dates, event times <code>HIERARCHICAL</code> Parent-child similarity encoding Taxonomies, org structures <pre><code>from hybi.compose import Encoding\n\n# Semantic: \"apple\" is similar to \"fruit\"\nField(\"description\", encoding=Encoding.SEMANTIC)\n\n# Exact: \"category_a\" is NOT similar to \"category_b\"\nField(\"type\", encoding=Encoding.EXACT)\n\n# Numeric: 100 is similar to 110 (within similar_within)\nField(\"price\", encoding=Encoding.NUMERIC, similar_within=50)\n</code></pre>"},{"location":"api/compose/fields/#hybi.compose.Encoding","title":"<code>hybi.compose.Encoding</code>","text":"<p>               Bases: <code>Enum</code></p> <p>How a field value is encoded into hypervectors.</p> <p>Different encoding types are suited for different data types and query patterns.</p>"},{"location":"api/compose/fields/#hybi.compose.Encoding.SEMANTIC","title":"<code>SEMANTIC = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Similar values produce similar vectors (default).</p> <p>Best for: text, embeddings, semantic content. Enables: similarity search, semantic matching.</p>"},{"location":"api/compose/fields/#hybi.compose.Encoding.EXACT","title":"<code>EXACT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Each unique value gets a random orthogonal vector.</p> <p>Best for: categorical values, IDs, enums. Enables: exact match queries, slot-based unbinding.</p>"},{"location":"api/compose/fields/#hybi.compose.Encoding.NUMERIC","title":"<code>NUMERIC = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Gaussian RBF encoding for continuous values.</p> <p>Best for: prices, measurements, quantities. Enables: range queries, numeric similarity. Uses similar_within parameter for scale.</p>"},{"location":"api/compose/fields/#hybi.compose.Encoding.TEMPORAL","title":"<code>TEMPORAL = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Time-aware encoding for dates and timestamps.</p> <p>Storage: Unix epoch seconds (i64 precision). Timezone: Naive datetime/strings use local time; timezone-aware respected. NULLs: Field omitted from storage; queries treat as \"no match\".</p> <p>Best for: timestamps, dates, event times. Enables: temporal queries, time-range filtering.</p>"},{"location":"api/compose/fields/#hybi.compose.Encoding.HIERARCHICAL","title":"<code>HIERARCHICAL = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Parent-child similarity encoding.</p> <p>Best for: categories, taxonomies, org structures. Enables: hierarchical queries, level-aware matching.</p>"},{"location":"api/compose/fields/#numericscale","title":"NumericScale","text":"<p>Pre-configured scales for numeric encoding.</p> <pre><code>from hybi.compose import Field, Encoding, NumericScale\n\n# Prices in dollars (similar within $100)\nField(\"price\", encoding=Encoding.NUMERIC, similar_within=NumericScale.DOLLARS)\n\n# 5-star ratings\nField(\"rating\", encoding=Encoding.NUMERIC, similar_within=NumericScale.RATING_5)\n\n# Percentages\nField(\"score\", encoding=Encoding.NUMERIC, similar_within=NumericScale.PERCENTAGE)\n</code></pre>"},{"location":"api/compose/fields/#hybi.compose.NumericScale","title":"<code>hybi.compose.NumericScale</code>","text":"<p>Preset scales for NUMERIC field encoding.</p> <p>These presets define \"similar_within\" values for common data types. The value represents the distance at which two numbers have ~60% similarity.</p> Usage <p>Field(\"price\", encoding=Encoding.NUMERIC, similar_within=NumericScale.DOLLARS) Field(\"rating\", encoding=Encoding.NUMERIC, similar_within=NumericScale.RATING_5)</p> How it works <p>similar_within=50 means values within 50 units have high similarity (~60%+). Values at exactly 50 apart have ~60% similarity. Values at 100 apart (2x) have ~14% similarity. Values at 150 apart (3x) have ~1% similarity.</p> Custom values <p>You can use any positive number: similar_within=100 for custom scales.</p>"},{"location":"api/compose/fields/#hybi.compose.NumericScale.CENTS","title":"<code>CENTS = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Price in cents: $0.10 difference = high similarity. For micro-transactions.</p>"},{"location":"api/compose/fields/#hybi.compose.NumericScale.DOLLARS","title":"<code>DOLLARS = 50</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Price in dollars: $50 difference = high similarity. For consumer goods.</p>"},{"location":"api/compose/fields/#hybi.compose.NumericScale.DOLLARS_LUXURY","title":"<code>DOLLARS_LUXURY = 500</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Price in dollars: $500 difference = high similarity. For luxury items.</p>"},{"location":"api/compose/fields/#hybi.compose.NumericScale.RATING_5","title":"<code>RATING_5 = 0.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>5-star rating: 0.5 star difference = high similarity.</p>"},{"location":"api/compose/fields/#hybi.compose.NumericScale.RATING_10","title":"<code>RATING_10 = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>10-point rating: 1 point difference = high similarity.</p>"},{"location":"api/compose/fields/#hybi.compose.NumericScale.RATING_100","title":"<code>RATING_100 = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>100-point rating (percentages): 10 point difference = high similarity.</p>"},{"location":"api/compose/fields/#hybi.compose.NumericScale.PERCENTAGE","title":"<code>PERCENTAGE = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Percentage (0-100): 5 percentage points = high similarity.</p>"},{"location":"api/compose/fields/#hybi.compose.NumericScale.FRACTION","title":"<code>FRACTION = 0.05</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fraction (0.0-1.0): 0.05 difference = high similarity.</p>"},{"location":"api/compose/fields/#hybi.compose.NumericScale.TEMPERATURE_C","title":"<code>TEMPERATURE_C = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Temperature in Celsius: 2\u00b0C difference = high similarity.</p>"},{"location":"api/compose/fields/#hybi.compose.NumericScale.TEMPERATURE_F","title":"<code>TEMPERATURE_F = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Temperature in Fahrenheit: 4\u00b0F difference = high similarity.</p>"},{"location":"api/compose/fields/#hybi.compose.NumericScale.SMALL_COUNT","title":"<code>SMALL_COUNT = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Small counts (0-10): 1 unit difference = high similarity.</p>"},{"location":"api/compose/fields/#hybi.compose.NumericScale.MEDIUM_COUNT","title":"<code>MEDIUM_COUNT = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Medium counts (0-100): 10 unit difference = high similarity.</p>"},{"location":"api/compose/fields/#hybi.compose.NumericScale.LARGE_COUNT","title":"<code>LARGE_COUNT = 100</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Large counts (0-1000): 100 unit difference = high similarity.</p>"},{"location":"api/compose/fields/#hybi.compose.NumericScale.SECONDS","title":"<code>SECONDS = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Duration in seconds: 5 seconds = high similarity.</p>"},{"location":"api/compose/fields/#hybi.compose.NumericScale.MINUTES","title":"<code>MINUTES = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Duration in minutes: 1 minute = high similarity.</p>"},{"location":"api/compose/fields/#hybi.compose.NumericScale.HOURS","title":"<code>HOURS = 0.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Duration in hours: 30 minutes = high similarity.</p>"},{"location":"api/compose/fields/#hybi.compose.NumericScale.DAYS","title":"<code>DAYS = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Duration in days: 1 day = high similarity.</p>"},{"location":"api/compose/fields/#field-weights","title":"Field Weights","text":"<p>Weights control relative importance in similarity calculations:</p> <pre><code>from hybi.compose import Bundle, Field, Encoding\n\nschema = Bundle(\n    fields={\n        \"title\": Field(encoding=Encoding.SEMANTIC, weight=2.0),  # 2x importance\n        \"description\": Field(encoding=Encoding.SEMANTIC, weight=1.0),\n        \"category\": Field(encoding=Encoding.EXACT, weight=0.5),  # Half weight\n    }\n)\n</code></pre> <p>When searching, higher-weighted fields contribute more to the similarity score.</p>"},{"location":"api/compose/fields/#encoding-selection-guide","title":"Encoding Selection Guide","text":"<pre><code>flowchart LR\n    Q1{Categorical/ID?} --&gt;|Yes| EXACT\n    Q1 --&gt;|No| Q2{Numeric?}\n    Q2 --&gt;|Yes| NUMERIC\n    Q2 --&gt;|No| SEMANTIC</code></pre>"},{"location":"api/compose/fields/#examples","title":"Examples","text":"Field Type Example Values Encoding Product name \"MacBook Pro\", \"iPhone\" SEMANTIC Category \"electronics\", \"clothing\" EXACT Price 999.99, 49.99 NUMERIC Description \"Lightweight laptop...\" SEMANTIC User ID \"user_12345\" EXACT Rating 4.5, 3.0 NUMERIC Relationship type \"works_at\", \"knows\" EXACT"},{"location":"api/compose/fields/#fieldpath","title":"FieldPath","text":"<p>The <code>FieldPath</code> dataclass represents a path to a field within a nested schema. It's returned by <code>schema.resolve_field()</code> and used internally for field resolution.</p> <pre><code>from hybi.compose.fields import FieldPath\n\n# FieldPath for a nested field\npath = schema.resolve_field(\"subject_type\")\nprint(path.parts)          # (\"subject\", \"left\")\nprint(path.column_name)    # \"subject_type\"\nprint(path.dot_notation)   # \"subject.left\"\nprint(path.root_slot)      # \"subject\"\nprint(path.is_nested)      # True\n</code></pre>"},{"location":"api/compose/fields/#properties","title":"Properties","text":"Property Type Description <code>parts</code> <code>Tuple[str, ...]</code> Tuple of slot names from root to field <code>column_name</code> <code>str</code> The DataFrame column name <code>field</code> <code>Field</code> The Field configuration <code>dot_notation</code> <code>str</code> Path as dot-separated string <code>root_slot</code> <code>str</code> The top-level slot name <code>is_nested</code> <code>bool</code> True if path has multiple parts"},{"location":"api/compose/fields/#hybi.compose.fields.FieldPath","title":"<code>hybi.compose.fields.FieldPath</code>  <code>dataclass</code>","text":"<p>Represents a path to a field within a nested schema.</p> <p>For simple schemas: FieldPath((\"subject\",), \"entity\", field) For nested schemas: FieldPath((\"subject\", \"left\"), \"subject_type\", field)</p> <p>This enables queries using column names (what users see in DataFrames) rather than requiring knowledge of the internal slot structure.</p> <p>Attributes:</p> Name Type Description <code>parts</code> <code>Tuple[str, ...]</code> <p>Tuple of slot names forming the path from root to leaf</p> <code>column_name</code> <code>str</code> <p>The DataFrame column name this path maps to</p> <code>field</code> <code>Field</code> <p>The Field configuration at this path</p> Example <p>schema = Triple( ...     subject=Pair( ...         left=Field(\"subject_type\"), ...         right=Field(\"subject_name\"), ...     ), ...     predicate=Field(\"relation\"), ...     object=Field(\"target\"), ... ) field_map = schema.get_field_map() field_map[\"subject_type\"] FieldPath(parts=(\"subject\", \"left\"), column_name=\"subject_type\", field=Field(...))</p>"},{"location":"api/compose/fields/#hybi.compose.fields.FieldPath.parts","title":"<code>parts</code>  <code>instance-attribute</code>","text":"<p>Tuple of slot names from root to this field.</p>"},{"location":"api/compose/fields/#hybi.compose.fields.FieldPath.column_name","title":"<code>column_name</code>  <code>instance-attribute</code>","text":"<p>The DataFrame column name this path maps to.</p>"},{"location":"api/compose/fields/#hybi.compose.fields.FieldPath.field","title":"<code>field</code>  <code>instance-attribute</code>","text":"<p>The Field configuration at this path.</p>"},{"location":"api/compose/fields/#hybi.compose.fields.FieldPath.dot_notation","title":"<code>dot_notation</code>  <code>property</code>","text":"<p>Return the path as dot-separated string: 'subject.left'.</p>"},{"location":"api/compose/fields/#hybi.compose.fields.FieldPath.root_slot","title":"<code>root_slot</code>  <code>property</code>","text":"<p>Return the top-level slot name.</p>"},{"location":"api/compose/fields/#hybi.compose.fields.FieldPath.is_nested","title":"<code>is_nested</code>  <code>property</code>","text":"<p>Whether this is a nested path (more than one part).</p>"},{"location":"api/compose/fields/#schemaevolution","title":"SchemaEvolution","text":"<p>The <code>SchemaEvolution</code> enum controls how schema changes are handled during subsequent ingest operations on a collection.</p> <p>When using <code>ADAPTIVE</code> mode, you can optionally suppress evolution warnings for bulk/backfill jobs.</p> <pre><code>from hybi.compose import SchemaEvolution\n\nhb.ingest(df, collection=\"users\", schema=schema, evolution=SchemaEvolution.STRICT)\n\n# ADAPTIVE mode with warnings suppressed\nhb.ingest(\n    df,\n    collection=\"users\",\n    schema=schema,\n    evolution=SchemaEvolution.ADAPTIVE,\n    warn_schema_evolution=False,\n)\n</code></pre> Mode Behavior <code>ADAPTIVE</code> Default. Additive changes allowed with warnings. New fields auto-added. <code>STRICT</code> No changes allowed without explicit migration. Raises error on schema change. <code>LOCKED</code> Immutable schema. Even additive changes are blocked after first ingest. Parameter Type Default Description <code>warn_schema_evolution</code> <code>bool</code> <code>True</code> In <code>ADAPTIVE</code> mode, emit schema evolution warnings when additive changes are applied. Set to <code>False</code> to suppress warning noise in controlled pipelines."},{"location":"api/compose/fields/#hybi.compose.SchemaEvolution","title":"<code>hybi.compose.SchemaEvolution</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Controls how schema changes are handled for a collection.</p> <p>Schema evolution mode determines whether changes to the schema (adding fields, changing encodings, etc.) are allowed during subsequent ingest operations.</p> Example <p>hb.ingest(df, collection=\"users\", schema=schema, ...           evolution=SchemaEvolution.STRICT)</p>"},{"location":"api/compose/fields/#hybi.compose.SchemaEvolution.ADAPTIVE","title":"<code>ADAPTIVE = 'adaptive'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default mode: additive changes allowed with warnings.</p> <ul> <li>New fields in data are automatically added to schema</li> <li>Breaking changes (removing fields) require explicit flag</li> <li>Encoding changes require explicit migration</li> <li>Best for: development, exploration, evolving data</li> </ul>"},{"location":"api/compose/fields/#hybi.compose.SchemaEvolution.STRICT","title":"<code>STRICT = 'strict'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>No changes allowed without explicit migration.</p> <ul> <li>Any schema change raises an error</li> <li>Requires explicit migration for changes</li> <li>Best for: production, regulated environments</li> </ul>"},{"location":"api/compose/fields/#hybi.compose.SchemaEvolution.LOCKED","title":"<code>LOCKED = 'locked'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Immutable schema - no changes allowed at all.</p> <ul> <li>Even additive changes are blocked</li> <li>Schema is frozen after first ingest</li> <li>Best for: audit logs, compliance, immutable data</li> </ul>"},{"location":"api/compose/intersections/","title":"Intersections","text":"<p>Intersections are the glue layer that connects collections, enabling cross-collection queries via <code>.join()</code>.</p>"},{"location":"api/compose/intersections/#overview","title":"Overview","text":"<p>An intersection declares a relationship between fields in two different collections:</p> <pre><code># Declare: employees.employee_id links to expertise.subject\nhb.intersect(\"employees.employee_id\", \"expertise.subject\")\n\n# Now you can join them\nresults = hb.query(\"employees\").search(\"engineering\").join(\"expertise\")\n\nfor r in results:\n    if r.is_matched:\n        print(f\"{r.source['name']} knows {r.target['skill']}\")\n</code></pre> <p>Without intersections, collections are isolated islands. With intersections, they become a connected graph you can traverse.</p>"},{"location":"api/compose/intersections/#declaring-intersections","title":"Declaring Intersections","text":""},{"location":"api/compose/intersections/#hbintersect","title":"hb.intersect()","text":"<p>Register a relationship between two collection fields:</p> <pre><code># Basic intersection (auto-detects relation type)\nhb.intersect(\"employees.employee_id\", \"expertise.subject\")\n\n# Explicit identity matching (exact equality)\nhb.intersect(\n    \"projects.project_id\",\n    \"budgets.project_id\",\n    relation=\"identity\"\n)\n\n# Semantic matching (embedding similarity)\nhb.intersect(\n    \"documents.content\",\n    \"topics.description\",\n    relation=\"semantic\",\n    threshold=0.7,      # Minimum similarity score\n    min_margin=0.05,    # Gap between best and second-best match\n)\n</code></pre>"},{"location":"api/compose/intersections/#relation-types","title":"Relation Types","text":"Relation Matching Use When <code>\"identity\"</code> Exact equality IDs, foreign keys, categorical values <code>\"semantic\"</code> Embedding similarity Text content, descriptions, fuzzy matching <code>\"auto\"</code> Inferred from field encodings Default - uses EXACT\u2192identity, SEMANTIC\u2192semantic <code>\"link\"</code> Explicit value mappings Cross-encoding intersections (requires flexible mode)"},{"location":"api/compose/intersections/#intersectionmode","title":"IntersectionMode","text":"<p>Controls whether intersections allow cross-encoding type pairs.</p> <pre><code>from hybi.compose.intersections import IntersectionMode\n\n# Default: only same-encoding pairs allowed\nmode = IntersectionMode.STRICT\n\n# Cross-encoding pairs via explicit links\nmode = IntersectionMode.FLEXIBLE\n</code></pre> Mode Allowed Pairs Relation Types <code>STRICT</code> Same encoding only (EXACT\u2194EXACT, SEMANTIC\u2194SEMANTIC) <code>identity</code>, <code>semantic</code>, <code>auto</code> <code>FLEXIBLE</code> Any encoding pair <code>link</code> only"},{"location":"api/compose/intersections/#intersection","title":"Intersection","text":"<p>The <code>Intersection</code> class represents a declared relationship.</p> <pre><code>from hybi.compose.intersections import Intersection\n\nintersection = Intersection(\n    source=\"employees.employee_id\",\n    target=\"expertise.subject\",\n    relation=\"identity\",\n    threshold=0.7,      # For semantic relations\n    min_margin=0.05,    # Confidence margin\n)\n</code></pre>"},{"location":"api/compose/intersections/#hybi.compose.intersections.Intersection","title":"<code>hybi.compose.intersections.Intersection</code>  <code>dataclass</code>","text":"<p>Declares a relationship between two collection fields.</p> <p>An intersection defines how data from one collection relates to data in another collection, enabling cross-collection queries via .join().</p> <p>Attributes:</p> Name Type Description <code>source</code> <code>str</code> <p>Source collection and field in \"collection.field\" format</p> <code>target</code> <code>str</code> <p>Target collection and field in \"collection.field\" format</p> <code>relation</code> <code>Literal['identity', 'semantic', 'auto', 'link']</code> <p>Type of matching - \"identity\" (exact), \"semantic\" (similarity),       \"auto\" (inferred from field encodings), or \"link\" (explicit bindings)</p> <code>threshold</code> <code>float</code> <p>Minimum similarity score for semantic matching (0.0 to 1.0)</p> <code>min_margin</code> <code>float</code> <p>Minimum gap between best and second-best match for confidence</p> <code>mode</code> <code>IntersectionMode</code> <p>STRICT (default, same-type only) or FLEXIBLE (cross-type via links)</p> Example"},{"location":"api/compose/intersections/#hybi.compose.intersections.Intersection--strict-mode-default-same-encoding-types","title":"Strict mode (default) - same encoding types","text":"<p>intersection = Intersection( ...     source=\"employees.employee_id\", ...     target=\"projects.owner_id\", ...     relation=\"identity\", ... )</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.Intersection--flexible-mode-cross-encoding-types-via-links","title":"Flexible mode - cross encoding types via links","text":"<p>intersection = Intersection( ...     source=\"employees.employee_id\", ...     target=\"expertise.topic\", ...     relation=\"link\", ...     mode=IntersectionMode.FLEXIBLE, ... )</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.Intersection.source","title":"<code>source</code>  <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.Intersection.target","title":"<code>target</code>  <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.Intersection.relation","title":"<code>relation = 'auto'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.Intersection.threshold","title":"<code>threshold = 0.7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.Intersection.min_margin","title":"<code>min_margin = 0.05</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.Intersection.mode","title":"<code>mode = IntersectionMode.STRICT</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.Intersection.link_collection","title":"<code>link_collection = field(init=False, default=None, repr=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.Intersection.__init__","title":"<code>__init__(source, target, relation='auto', threshold=0.7, min_margin=0.05, mode=IntersectionMode.STRICT)</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.Intersection.reversed","title":"<code>reversed()</code>","text":"<p>Create a reversed intersection (target \u2192 source).</p> <p>Returns:</p> Type Description <code>Intersection</code> <p>New Intersection with source and target swapped.</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.Intersection.resolved_relation","title":"<code>resolved_relation()</code>","text":"<p>Get the resolved relation type.</p> <p>If relation is \"auto\" and encodings are known, resolves to \"identity\" or \"semantic\" based on encoding types.</p> <p>Returns:</p> Type Description <code>str</code> <p>Resolved relation string, or \"auto\" if cannot resolve.</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.Intersection.has_links","title":"<code>has_links()</code>","text":"<p>Check if this intersection has a link collection.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if this is a flexible intersection with a link collection.</p>"},{"location":"api/compose/intersections/#joining-collections","title":"Joining Collections","text":"<p>Once intersections are declared, use <code>.join()</code> to traverse them:</p> <pre><code># Single join\nresults = hb.query(\"employees\").search(\"engineering\").join(\"expertise\")\n\n# Chained joins (multi-hop)\nresults = (\n    hb.query(\"employees\")\n    .search(\"senior engineer\")\n    .join(\"expertise\")\n    .join(\"projects\")\n    .join(\"budgets\")\n)\n\n# Access joined data\nfor r in results:\n    print(f\"Employee: {r.source['name']}\")\n    if r.target:\n        print(f\"  Expertise: {r.target['skill']}\")\n</code></pre>"},{"location":"api/compose/intersections/#join-options","title":"Join Options","text":"<pre><code>results = query.join(\n    \"expertise\",\n    on=(\"employee_id\", \"subject\"),  # Override intersection fields\n    where={\"level\": \"Expert\"},       # Filter target collection\n    top_k=5,                         # Limit matches per source row\n)\n</code></pre>"},{"location":"api/compose/intersections/#joinedresult","title":"JoinedResult","text":"<p>A single result from a cross-collection join.</p> <pre><code>for result in results:\n    # Check match status\n    if result.is_matched:\n        # Access source and target data\n        name = result.source[\"name\"]\n        skill = result.target[\"skill\"]\n\n    elif result.is_null:\n        # Ambiguous match (multiple close candidates)\n        print(f\"Unclear match for {result.source['name']}\")\n\n    elif result.is_no_match:\n        # No match found\n        print(f\"No expertise for {result.source['name']}\")\n</code></pre>"},{"location":"api/compose/intersections/#output-formats","title":"Output Formats","text":"<pre><code># Direct access (recommended)\nresult.source[\"name\"]      # From source collection\nresult.target[\"skill\"]     # From target collection\n\n# Flat dictionary (prefixed keys)\nresult.to_flat()\n# {'employees.name': 'Alice', 'expertise.skill': 'Python', '_score': 0.95}\n\n# Nested dictionary\nresult.to_nested()\n# {'employees': {'name': 'Alice'}, 'expertise': {'skill': 'Python'}}\n</code></pre>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResult","title":"<code>hybi.compose.intersections.JoinedResult</code>  <code>dataclass</code>","text":"<p>Result of joining data from two collections.</p> <p>Represents a single row from a cross-collection query, combining source and target data with matching metadata.</p> <p>Attributes:</p> Name Type Description <code>source_data</code> <code>Dict[str, Any]</code> <p>Data from the source collection.</p> <code>target_data</code> <code>Optional[Dict[str, Any]]</code> <p>Data from the target collection (None if no match).</p> <code>intersection</code> <code>Intersection</code> <p>The intersection used for this join.</p> <code>score</code> <code>float</code> <p>Combined similarity/match score.</p> <code>status</code> <code>JoinStatus</code> <p>Match status (matched, null, no_match).</p> <code>margin</code> <code>float</code> <p>Gap between best and second-best match (for semantic).</p> Example <p>result = JoinedResult( ...     source_data={\"name\": \"Alice\", \"id\": \"EMP001\"}, ...     target_data={\"subject\": \"EMP001\", \"object\": \"Python\"}, ...     intersection=intersection, ...     score=1.0, ...     status=JoinStatus.MATCHED, ... ) result.to_flat() {'employees.name': 'Alice', 'employees.id': 'EMP001',  'expertise.subject': 'EMP001', 'expertise.object': 'Python'}</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResult.source_data","title":"<code>source_data</code>  <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResult.target_data","title":"<code>target_data</code>  <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResult.score","title":"<code>score = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResult.status","title":"<code>status = JoinStatus.MATCHED</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResult.margin","title":"<code>margin = 0.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResult.source","title":"<code>source</code>  <code>property</code>","text":"<p>Access source collection data directly.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of source fields.</p> Example <p>result.source[\"name\"] 'Alice' result.source[\"employee_id\"] 'EMP001'</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResult.target","title":"<code>target</code>  <code>property</code>","text":"<p>Access target collection data directly.</p> <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>Dictionary of target fields, or None if no match.</p> Example <p>if result.target: ...     print(result.target[\"skill\"]) 'Python'</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResult.is_matched","title":"<code>is_matched</code>  <code>property</code>","text":"<p>Return True if this result has a confident match.</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResult.is_null","title":"<code>is_null</code>  <code>property</code>","text":"<p>Return True if this result is ambiguous (NULL).</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResult.is_no_match","title":"<code>is_no_match</code>  <code>property</code>","text":"<p>Return True if no match was found.</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResult.to_flat","title":"<code>to_flat()</code>","text":"<p>Convert to a flat dictionary with prefixed keys.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with keys like \"collection.field\".</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResult.to_nested","title":"<code>to_nested()</code>","text":"<p>Convert to a nested dictionary by collection.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with collections as top-level keys.</p>"},{"location":"api/compose/intersections/#joinedresultset","title":"JoinedResultSet","text":"<p>Collection of joined results with filtering utilities.</p> <pre><code># Filter to confident matches only\nmatched = results.filter_matched()\n\n# Statistics\nprint(f\"Matched: {results.matched_count}\")\nprint(f\"Ambiguous: {results.null_count}\")\nprint(f\"No match: {results.no_match_count}\")\nprint(f\"Expansion: {results.expansion_ratio}x\")  # Fan-out factor\n\n# Chained joins\ndeeper = results.join(\"projects\").join(\"budgets\")\n\n# Deduplication (handle diamond patterns)\ndeduped = results.dedupe(key_field=\"doc_id\", strategy=\"best_score\")\n\n# Convert to lists\nflat_dicts = results.to_flat_dicts()\nnested_dicts = results.to_nested_dicts()\n</code></pre>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResultSet","title":"<code>hybi.compose.intersections.JoinedResultSet</code>  <code>dataclass</code>","text":"<p>Collection of joined results from a cross-collection query.</p> <p>Provides iteration, filtering, and conversion utilities for working with joined data. Supports chained joins via .join().</p> <p>Attributes:</p> Name Type Description <code>results</code> <code>List[JoinedResult]</code> <p>List of JoinedResult objects.</p> <code>intersection</code> <code>Optional[Intersection]</code> <p>The intersection used for the join.</p> <code>source_count</code> <code>int</code> <p>Number of source rows before joining.</p> <code>target_count</code> <code>int</code> <p>Number of target rows before joining.</p> <code>depth</code> <code>int</code> <p>Current depth in the join chain (0 = source).</p> <code>was_truncated</code> <code>bool</code> <p>Whether results were truncated due to limits.</p> <code>truncation_reason</code> <code>Optional[str]</code> <p>Why truncation occurred (\"max_depth\", \"max_results\", \"cycle\").</p> <code>collections_visited</code> <code>List[str]</code> <p>Ordered list of collections in the join chain.</p> <code>timing_ms</code> <code>float</code> <p>Execution time in milliseconds.</p> Example"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResultSet--chained-joins","title":"Chained joins","text":"<p>results = hb.query(\"employees\").search(\"...\") \\ ...     .join(\"expertise\") \\ ...     .join(\"projects\")</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResultSet.results","title":"<code>results = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResultSet.intersection","title":"<code>intersection = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResultSet.source_count","title":"<code>source_count = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResultSet.target_count","title":"<code>target_count = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResultSet.depth","title":"<code>depth = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResultSet.was_truncated","title":"<code>was_truncated = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResultSet.matched_count","title":"<code>matched_count</code>  <code>property</code>","text":"<p>Return the number of matched results.</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResultSet.null_count","title":"<code>null_count</code>  <code>property</code>","text":"<p>Return the number of ambiguous (NULL) results.</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResultSet.no_match_count","title":"<code>no_match_count</code>  <code>property</code>","text":"<p>Return the number of unmatched results.</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResultSet.expansion_ratio","title":"<code>expansion_ratio</code>  <code>property</code>","text":"<p>Return the ratio of output rows to input rows.</p> <p>A ratio &gt; 1.0 indicates one-to-many expansion.</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResultSet.filter_matched","title":"<code>filter_matched()</code>","text":"<p>Return only confidently matched results.</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResultSet.filter_by_status","title":"<code>filter_by_status(status)</code>","text":"<p>Return results with a specific status.</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResultSet.dedupe","title":"<code>dedupe(key_field=None, strategy='best_score')</code>","text":"<p>Remove duplicate results based on target entity.</p> <p>Handles diamond patterns where multiple paths lead to the same target entity by keeping only one result per unique target.</p> <p>Parameters:</p> Name Type Description Default <code>key_field</code> <code>Optional[str]</code> <p>Field to use as unique key. Defaults to target's primary key or first field.</p> <code>None</code> <code>strategy</code> <code>str</code> <p>How to choose which duplicate to keep: - \"best_score\": Keep highest scoring match (default) - \"first\": Keep first encountered</p> <code>'best_score'</code> <p>Returns:</p> Type Description <code>JoinedResultSet</code> <p>New JoinedResultSet with duplicates removed.</p> Example"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResultSet.dedupe--multiple-paths-to-same-document","title":"Multiple paths to same document","text":"<p>results = query.join(\"skills\").join(\"documents\") results = results.extend(query.join(\"projects\").join(\"documents\")) deduped = results.dedupe(key_field=\"doc_id\", strategy=\"best_score\")</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResultSet.limit","title":"<code>limit(n)</code>","text":"<p>Limit results to first n entries.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Maximum number of results to keep.</p> required <p>Returns:</p> Type Description <code>JoinedResultSet</code> <p>New JoinedResultSet with at most n results.</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResultSet.extend","title":"<code>extend(other)</code>","text":"<p>Combine results from another JoinedResultSet.</p> <p>Useful for merging results from multiple join paths (diamond pattern).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>JoinedResultSet</code> <p>Another JoinedResultSet to merge.</p> required <p>Returns:</p> Type Description <code>JoinedResultSet</code> <p>New JoinedResultSet with combined results.</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResultSet.join","title":"<code>join(target_collection, *, on=None, where=None, top_k=None)</code>","text":"<p>Continue joining to another collection (chained joins).</p> Enables patterns like <p>hb.query(\"A\").search(\"...\").join(\"B\").join(\"C\").join(\"D\")</p> <p>All join strategies (identity, semantic, link) are supported at every hop depth via shared dispatch in <code>_join_dispatch</code>.</p> <p>Parameters:</p> Name Type Description Default <code>target_collection</code> <code>str</code> <p>The collection to join with.</p> required <code>on</code> <code>Optional[tuple]</code> <p>Optional tuple of (source_field, target_field) to override the declared intersection fields.</p> <code>None</code> <code>where</code> <code>Optional[Dict[str, Any]]</code> <p>Optional filter to apply to target results during join.</p> <code>None</code> <code>top_k</code> <code>Optional[int]</code> <p>Optional limit on number of matches per source row.</p> <code>None</code> <p>Returns:</p> Type Description <code>JoinedResultSet</code> <p>JoinedResultSet containing combined data from all collections.</p> <p>Raises:</p> Type Description <code>QueryStateError</code> <p>If this result set wasn't created with chaining support.</p> <code>CircularJoinError</code> <p>If joining would create a cycle (when cycle_behavior=\"error\").</p> <code>MaxJoinDepthError</code> <p>If join chain exceeds max_join_depth.</p> <code>NoIntersectionError</code> <p>If no intersection exists between collections.</p> Example <p>results = hb.query(\"employees\").search(\"engineering\") \\ ...     .join(\"expertise\") \\ ...     .join(\"projects\") \\ ...     .join(\"budgets\")</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResultSet.to_flat_dicts","title":"<code>to_flat_dicts()</code>","text":"<p>Convert all results to flat dictionaries.</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinedResultSet.to_nested_dicts","title":"<code>to_nested_dicts()</code>","text":"<p>Convert all results to nested dictionaries.</p>"},{"location":"api/compose/intersections/#joinstatus","title":"JoinStatus","text":"<p>Match status for each joined result.</p> Status Meaning <code>MATCHED</code> Confident match found <code>NULL</code> Ambiguous match (margin too small between candidates) <code>NO_MATCH</code> No match found above threshold <pre><code>from hybi.compose.intersections import JoinStatus\n\n# Filter by status\nmatched = results.filter_by_status(JoinStatus.MATCHED)\nambiguous = results.filter_by_status(JoinStatus.NULL)\n</code></pre>"},{"location":"api/compose/intersections/#joinconfig","title":"JoinConfig","text":"<p>Configure join behavior for production safety.</p> <pre><code>from hybi.compose.intersections import JoinConfig\n\nconfig = JoinConfig(\n    max_join_depth=5,           # Maximum chained joins\n    max_results_per_join=10000, # Limit fan-out per hop\n    dedupe_strategy=\"best_score\",  # Handle diamond patterns\n    cycle_behavior=\"stop\",      # What to do on cycles\n)\n\nhb = HyperBinder(join_config=config)\n</code></pre>"},{"location":"api/compose/intersections/#options","title":"Options","text":"Option Default Description <code>max_join_depth</code> 5 Maximum number of chained <code>.join()</code> calls <code>max_results_per_join</code> 10000 Maximum results at each join step <code>dedupe_strategy</code> <code>\"best_score\"</code> <code>\"best_score\"</code>, <code>\"first\"</code>, or <code>\"none\"</code> <code>cycle_behavior</code> <code>\"stop\"</code> <code>\"stop\"</code>, <code>\"error\"</code>, or <code>\"allow\"</code>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinConfig","title":"<code>hybi.compose.intersections.JoinConfig</code>  <code>dataclass</code>","text":"<p>Configuration for join operations across collections.</p> <p>Controls limits, cycle handling, and deduplication behavior for production-safe join chains.</p> <p>Attributes:</p> Name Type Description <code>max_join_depth</code> <code>int</code> <p>Maximum number of join hops allowed in a chain. Prevents infinite cycles. Default is 5.</p> <code>max_results_per_join</code> <code>int</code> <p>Maximum results to keep at each join step. Prevents fan-out explosion. Default is 10000.</p> <code>dedupe_strategy</code> <code>Literal['best_score', 'first', 'none']</code> <p>How to handle diamond patterns where multiple paths lead to the same entity: - \"best_score\": Keep highest scoring match (default) - \"first\": Keep first encountered - \"none\": No deduplication (preserve all paths)</p> <code>cycle_behavior</code> <code>Literal['stop', 'error', 'allow']</code> <p>What to do when a cycle is detected: - \"stop\": Stop traversal, return results so far (default) - \"error\": Raise CircularJoinError - \"allow\": Continue (dangerous, relies on max_depth)</p> Example <p>config = JoinConfig(max_join_depth=3, dedupe_strategy=\"best_score\") hb = HyperBinder(join_config=config)</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinConfig.max_join_depth","title":"<code>max_join_depth = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinConfig.max_results_per_join","title":"<code>max_results_per_join = 10000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinConfig.dedupe_strategy","title":"<code>dedupe_strategy = 'best_score'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.JoinConfig.cycle_behavior","title":"<code>cycle_behavior = 'stop'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#the-bridge-pattern","title":"The Bridge Pattern","text":"<p>Intersections enable a powerful pattern for connecting heterogeneous data:</p> <pre><code>flowchart LR\n    D[\"Documents&lt;br/&gt;(Fuzzy)\"] &lt;--&gt;|semantic| K[\"Knowledge Graph&lt;br/&gt;(Entity Hub)\"] &lt;--&gt;|identity| T[\"Tables&lt;br/&gt;(Exact)\"]</code></pre> <p>Example: Find budget information for projects mentioned in emails:</p> <pre><code># Declare intersections\nhb.intersect(\"emails.content\", \"projects.description\", relation=\"semantic\")\nhb.intersect(\"projects.project_id\", \"budgets.project_id\", relation=\"identity\")\n\n# Query across all three\nresults = (\n    hb.query(\"emails\")\n    .search(\"Q2 budget allocation\")\n    .join(\"projects\")      # semantic: email content \u2192 project\n    .join(\"budgets\")       # identity: project ID \u2192 budget record\n)\n\nfor r in results:\n    print(f\"Email: {r['emails.subject']}\")\n    print(f\"Project: {r['projects.name']}\")\n    print(f\"Budget: ${r['budgets.allocated']:,}\")\n</code></pre> <p>The Knowledge Graph acts as a semantic index bridging: - Fuzzy text mentions \u2192 Canonical entities \u2192 Exact structured lookups</p>"},{"location":"api/compose/intersections/#error-handling","title":"Error Handling","text":"<pre><code>from hybi.compose.intersections import (\n    IntersectionError,\n    NoIntersectionError,\n    AmbiguousIntersectionError,\n    CircularJoinError,\n    MaxJoinDepthError,\n)\n\ntry:\n    results = query.join(\"unknown_collection\")\nexcept NoIntersectionError as e:\n    print(f\"No intersection defined: {e}\")\n\ntry:\n    results = query.join(\"A\").join(\"B\").join(\"A\")  # Cycle\nexcept CircularJoinError as e:\n    print(f\"Cycle detected: {e.collection} in {e.path}\")\n\ntry:\n    # Too many hops\n    results = query.join(\"A\").join(\"B\").join(\"C\").join(\"D\").join(\"E\").join(\"F\")\nexcept MaxJoinDepthError as e:\n    print(f\"Exceeded depth {e.max_depth}\")\n</code></pre>"},{"location":"api/compose/intersections/#hybi.compose.intersections.IntersectionError","title":"<code>hybi.compose.intersections.IntersectionError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for intersection operations.</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.NoIntersectionError","title":"<code>hybi.compose.intersections.NoIntersectionError</code>","text":"<p>               Bases: <code>IntersectionError</code></p> <p>Raised when no intersection is declared between two collections.</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.AmbiguousIntersectionError","title":"<code>hybi.compose.intersections.AmbiguousIntersectionError</code>","text":"<p>               Bases: <code>IntersectionError</code></p> <p>Raised when multiple intersections exist between collections.</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.CircularJoinError","title":"<code>hybi.compose.intersections.CircularJoinError</code>","text":"<p>               Bases: <code>IntersectionError</code></p> <p>Raised when a join chain would create a cycle.</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.MaxJoinDepthError","title":"<code>hybi.compose.intersections.MaxJoinDepthError</code>","text":"<p>               Bases: <code>IntersectionError</code></p> <p>Raised when join chain exceeds maximum allowed depth.</p>"},{"location":"api/compose/intersections/#flexible-intersections-cross-encoding","title":"Flexible Intersections (Cross-Encoding)","text":"<p>Flexible mode enables intersections between fields with different encoding types (e.g., EXACT\u2194SEMANTIC) using explicit link bindings.</p>"},{"location":"api/compose/intersections/#hbintersect_flexible","title":"hb.intersect_flexible()","text":"<p>Declare a flexible intersection allowing cross-encoding types:</p> <pre><code># Declare flexible intersection\nix = hb.intersect_flexible(\n    \"employees.employee_id\",    # EXACT encoding\n    \"expertise.topic\",          # SEMANTIC encoding\n    threshold=0.7,              # Optional: match threshold\n    bidirectional=True,         # Default: register both directions\n)\n\n# The intersection is created with mode=FLEXIBLE and relation=\"link\"\nprint(ix.mode)            # IntersectionMode.FLEXIBLE\nprint(ix.link_collection) # \"__links_employees_employee_id__expertise_topic\"\n</code></pre>"},{"location":"api/compose/intersections/#hbpopulate_links","title":"hb.populate_links()","text":"<p>Populate the flexible intersection with link data:</p> <pre><code>import pandas as pd\n\n# Create link data mapping employee IDs to topics\nlinks_df = pd.DataFrame({\n    \"emp_id\": [\"EMP001\", \"EMP002\", \"EMP003\"],\n    \"topic\": [\"machine learning\", \"databases\", \"cloud computing\"],\n})\n\n# Populate the intersection with links\nresult = hb.populate_links(\n    ix,                # The intersection from intersect_flexible()\n    links_df,          # DataFrame with link pairs\n    \"emp_id\",          # Source column name\n    \"topic\",           # Target column name\n    weight_column=None # Optional: column for link weights\n)\n\nprint(result)  # {'status': 'ok', 'links_stored': 3}\n</code></pre> <p>Each call to <code>populate_links()</code> replaces all existing links for that intersection.</p>"},{"location":"api/compose/intersections/#link","title":"Link","text":"<p>A single link binding between source and target values.</p> <pre><code>from hybi.compose.intersections import Link\n\nlink = Link(\n    source_value=\"EMP001\",\n    target_value=\"machine learning\",\n    weight=1.0,            # Optional weight (default 1.0)\n    metadata={\"note\": \"primary expertise\"},  # Optional metadata\n)\n\n# Convert to dictionary for serialization\nlink.to_dict()\n# {'source_value': 'EMP001', 'target_value': 'machine learning', 'weight': 1.0}\n</code></pre>"},{"location":"api/compose/intersections/#hybi.compose.intersections.Link","title":"<code>hybi.compose.intersections.Link</code>  <code>dataclass</code>","text":"<p>A single link binding between source and target values.</p> <p>Links enable cross-encoding intersections by explicitly declaring which source values correspond to which target values. The binding is bidirectional - you can query in either direction.</p> <p>Attributes:</p> Name Type Description <code>source_value</code> <code>Any</code> <p>The source field value (will be converted to string)</p> <code>target_value</code> <code>Any</code> <p>The target field value (will be converted to string)</p> <code>weight</code> <code>float</code> <p>Optional weight for this link (default 1.0)</p> <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <p>Optional additional metadata for this link</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.Link.source_value","title":"<code>source_value</code>  <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.Link.target_value","title":"<code>target_value</code>  <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.Link.weight","title":"<code>weight = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.Link.metadata","title":"<code>metadata = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.Link.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary for serialization.</p>"},{"location":"api/compose/intersections/#linkset","title":"LinkSet","text":"<p>Collection of links for a flexible intersection. Provides convenient creation from DataFrames or list of pairs.</p> <pre><code>from hybi.compose.intersections import LinkSet\nimport pandas as pd\n\n# From DataFrame (recommended)\ndf = pd.DataFrame({\n    \"emp_id\": [\"EMP001\", \"EMP002\", \"EMP003\"],\n    \"topic\": [\"ML\", \"DB\", \"Cloud\"],\n    \"confidence\": [0.9, 0.8, 0.95],\n})\nlink_set = LinkSet.from_dataframe(\n    df,\n    source_column=\"emp_id\",\n    target_column=\"topic\",\n    weight_column=\"confidence\",  # Optional\n)\n\n# From list of pairs\nlink_set = LinkSet.from_pairs([\n    (\"EMP001\", \"ML\"),\n    (\"EMP002\", \"DB\", 0.8),  # With weight\n])\n\n# Convert to mappings\nforward = link_set.to_forward_mapping()   # {\"EMP001\": [\"ML\"], ...}\nreverse = link_set.to_reverse_mapping()   # {\"ML\": [\"EMP001\"], ...}\n</code></pre>"},{"location":"api/compose/intersections/#hybi.compose.intersections.LinkSet","title":"<code>hybi.compose.intersections.LinkSet</code>  <code>dataclass</code>","text":"<p>Collection of links for a flexible intersection.</p> <p>LinkSet provides a convenient way to create and manage multiple links, typically from a DataFrame with two columns mapping source to target values.</p> <p>Attributes:</p> Name Type Description <code>links</code> <code>List[Link]</code> <p>List of Link objects</p> <code>source_field</code> <code>Optional[str]</code> <p>Name of the source field (for documentation)</p> <code>target_field</code> <code>Optional[str]</code> <p>Name of the target field (for documentation)</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.LinkSet.links","title":"<code>links = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.LinkSet.source_field","title":"<code>source_field = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.LinkSet.target_field","title":"<code>target_field = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"api/compose/intersections/#hybi.compose.intersections.LinkSet.from_dataframe","title":"<code>from_dataframe(df, source_column, target_column, weight_column=None)</code>  <code>classmethod</code>","text":"<p>Create LinkSet from a DataFrame with source and target columns.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame containing link pairs</p> required <code>source_column</code> <code>str</code> <p>Column name for source values</p> required <code>target_column</code> <code>str</code> <p>Column name for target values</p> required <code>weight_column</code> <code>Optional[str]</code> <p>Optional column name for link weights</p> <code>None</code> <p>Returns:</p> Type Description <code>LinkSet</code> <p>LinkSet ready for ingestion via populate_links()</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If required columns are missing</p> Example <p>df = pd.DataFrame({ ...     \"employee_id\": [\"EMP001\", \"EMP002\", \"EMP003\"], ...     \"topic\": [\"machine learning\", \"databases\", \"cloud computing\"] ... }) links = LinkSet.from_dataframe(df, \"employee_id\", \"topic\") len(links) 3</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.LinkSet.from_pairs","title":"<code>from_pairs(pairs, source_field=None, target_field=None)</code>  <code>classmethod</code>","text":"<p>Create LinkSet from a list of (source, target) pairs.</p> <p>Parameters:</p> Name Type Description Default <code>pairs</code> <code>List[tuple]</code> <p>List of (source_value, target_value) tuples,    or (source_value, target_value, weight) tuples</p> required <code>source_field</code> <code>Optional[str]</code> <p>Optional source field name</p> <code>None</code> <code>target_field</code> <code>Optional[str]</code> <p>Optional target field name</p> <code>None</code> <p>Returns:</p> Type Description <code>LinkSet</code> <p>LinkSet ready for ingestion</p> Example <p>links = LinkSet.from_pairs([ ...     (\"EMP001\", \"machine learning\"), ...     (\"EMP002\", \"databases\", 0.8),  # with weight ... ])</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.LinkSet.to_list","title":"<code>to_list()</code>","text":"<p>Convert to list of dictionaries for serialization.</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.LinkSet.to_forward_mapping","title":"<code>to_forward_mapping()</code>","text":"<p>Convert to forward mapping: source_value -&gt; [target_values].</p> <p>Returns:</p> Type Description <code>Dict[str, List[str]]</code> <p>Dictionary mapping each source value to its target values.</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.LinkSet.to_reverse_mapping","title":"<code>to_reverse_mapping()</code>","text":"<p>Convert to reverse mapping: target_value -&gt; [source_values].</p> <p>Returns:</p> Type Description <code>Dict[str, List[str]]</code> <p>Dictionary mapping each target value to its source values.</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.LinkSet.get_source_values","title":"<code>get_source_values()</code>","text":"<p>Get all unique source values.</p>"},{"location":"api/compose/intersections/#hybi.compose.intersections.LinkSet.get_target_values","title":"<code>get_target_values()</code>","text":"<p>Get all unique target values.</p>"},{"location":"api/compose/intersections/#complete-example","title":"Complete Example","text":"<pre><code>from hybi import HyperBinder\nfrom hybi.compose import Triple, Field, Encoding\nfrom hybi.compose.intersections import JoinConfig\n\n# Initialize with join configuration\nhb = HyperBinder(\n    join_config=JoinConfig(max_join_depth=4, dedupe_strategy=\"best_score\")\n)\n\n# Define schemas\nemployee_schema = Triple(\n    subject=Field(\"employee_id\", encoding=Encoding.EXACT),\n    predicate=Field(\"role\"),\n    object=Field(\"department\"),\n)\n\nexpertise_schema = Triple(\n    subject=Field(\"employee_id\", encoding=Encoding.EXACT),\n    predicate=Field(\"skill\"),\n    object=Field(\"level\"),\n)\n\n# Ingest data\nhb.ingest(employees_df, collection=\"employees\", schema=employee_schema)\nhb.ingest(expertise_df, collection=\"expertise\", schema=expertise_schema)\n\n# Declare intersection\nhb.intersect(\"employees.employee_id\", \"expertise.employee_id\")\n\n# Query with join\nresults = (\n    hb.query(\"employees\", schema=employee_schema)\n    .find(department=\"Engineering\")\n    .join(\"expertise\")\n)\n\n# Process results\nfor r in results.filter_matched():\n    print(f\"{r.source['employee_id']}: {r.target['skill']} ({r.target['level']})\")\n</code></pre>"},{"location":"api/compose/intersections/#complete-flexible-intersection-example","title":"Complete Flexible Intersection Example","text":"<p>Cross-encoding joins between EXACT IDs and SEMANTIC topics:</p> <pre><code>from hybi import HyperBinder\nfrom hybi.compose import Triple, Field, Encoding\nimport pandas as pd\n\nhb = HyperBinder()\n\n# Schema 1: Employees with EXACT IDs\nemployee_schema = Triple(\n    subject=Field(\"employee_id\", encoding=Encoding.EXACT),\n    predicate=Field(\"role\"),\n    object=Field(\"department\"),\n)\n\n# Schema 2: Expertise with SEMANTIC topics\nexpertise_schema = Triple(\n    subject=Field(\"topic\", encoding=Encoding.SEMANTIC),  # Different encoding!\n    predicate=Field(\"skill\"),\n    object=Field(\"level\"),\n)\n\n# Ingest data\nemployees_df = pd.DataFrame({\n    \"employee_id\": [\"EMP001\", \"EMP002\"],\n    \"role\": [\"Engineer\", \"Analyst\"],\n    \"department\": [\"ML\", \"Data\"],\n})\nexpertise_df = pd.DataFrame({\n    \"topic\": [\"machine learning\", \"data engineering\"],\n    \"skill\": [\"Python\", \"SQL\"],\n    \"level\": [\"Expert\", \"Senior\"],\n})\n\nhb.ingest(employees_df, collection=\"employees\", schema=employee_schema)\nhb.ingest(expertise_df, collection=\"expertise\", schema=expertise_schema)\n\n# Declare flexible intersection (cross-encoding!)\nix = hb.intersect_flexible(\"employees.employee_id\", \"expertise.topic\")\n\n# Provide the explicit link mappings\nlinks_df = pd.DataFrame({\n    \"emp_id\": [\"EMP001\", \"EMP002\"],\n    \"topic\": [\"machine learning\", \"data engineering\"],\n})\nhb.populate_links(ix, links_df, \"emp_id\", \"topic\")\n\n# Now cross-type joins work\nresults = (\n    hb.query(\"employees\", schema=employee_schema)\n    .find(department=\"ML\")\n    .join(\"expertise\")\n)\n\nfor r in results.filter_matched():\n    print(f\"{r.source['employee_id']} knows {r.target['topic']}: {r.target['skill']}\")\n    # EMP001 knows machine learning: Python\n</code></pre>"},{"location":"api/compose/molecules/","title":"Molecules","text":"<p>Molecules are the core compositional building blocks for defining schemas.</p>"},{"location":"api/compose/molecules/#overview","title":"Overview","text":"Molecule Slots Best For Pair left, right Key-value, edges Triple subject, predicate, object Knowledge graphs Bundle User-defined Tabular data (read-heavy) Row pk + fields Mutable tables (CRUD) Sequence item Ordered data Tree child, parent Hierarchies Graph source, edge, target Networks"},{"location":"api/compose/molecules/#structured-vs-search-optimized","title":"Structured vs Search-Optimized","text":"<p>Molecules use two encoding strategies:</p> <ul> <li>Structured (Pair, Triple, Row, Tree, Graph, Sequence): Fully decomposable, supports field extraction</li> <li>Search-optimized (Bundle): Optimized for multi-field similarity search, cannot be nested</li> </ul> <p>Row is particularly important because it enables SQL-like CRUD operations on individual rows, unlike Bundle which is optimized for search but doesn't support field-level updates.</p>"},{"location":"api/compose/molecules/#universal-query-methods","title":"Universal Query Methods","text":"<p>All molecule types support these common query methods:</p> Method Description Common Parameters <code>search(query, top_k=10)</code> Hybrid semantic + symbolic search <code>query</code>: str or dict, <code>top_k</code>: max results <code>search_slots(**slot_queries)</code> Per-slot weighted search <code>slot_queries</code>: dict mapping slots to queries <code>search_prototype(examples, top_k=10)</code> Bundle examples as search prototype <code>examples</code>: list of values"},{"location":"api/compose/molecules/#common-query-parameters","title":"Common Query Parameters","text":"<ul> <li><code>top_k</code>: Maximum number of results to return (default: 10)</li> <li><code>mode</code>: Query mode - \"exact\" or \"fuzzy\"/\"semantic\" (varies by method)</li> <li><code>similarity_threshold</code>: Minimum similarity score for results (0.0-1.0)</li> </ul>"},{"location":"api/compose/molecules/#pair","title":"Pair","text":"<p>Two-element structure with <code>left</code> and <code>right</code> slots.</p> <pre><code>from hybi.compose import Pair, Field, Encoding\n\nschema = Pair(\n    left=Field(\"key\", encoding=Encoding.EXACT),\n    right=Field(\"value\", encoding=Encoding.SEMANTIC),\n)\n</code></pre> <p>Supported queries: <code>find(left=X)</code>, <code>find(right=Y)</code>, <code>search()</code></p>"},{"location":"api/compose/molecules/#hybi.compose.Pair","title":"<code>hybi.compose.Pair</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseMolecule</code></p> <p>Two-element binding: A \u229b B.</p> <p>Pair encodes a relationship between two elements, like key-value pairs, directed edges, or binary relations.</p> <p>Slots can be Fields or nested Molecules:</p> <pre><code># Simple: both slots are Fields\nPair(\n    left=Field(\"key\", encoding=Encoding.EXACT),\n    right=Field(\"value\"),\n)\n\n# Nested: left slot contains another Pair\nPair(\n    left=Pair(\n        left=Field(\"namespace\"),\n        right=Field(\"key\"),\n    ),\n    right=Field(\"value\"),\n)\n# Encoding: (namespace \u229b key) \u229b value\n</code></pre> Encoding <p>left \u229b right</p> Supported Queries <ul> <li>find(left=X): Find right values bound with X</li> <li>find(right=Y): Find left values bound with Y</li> <li>search(): Semantic similarity search</li> </ul> Example <p>schema = Pair( ...     left=Field(\"key\", encoding=Encoding.EXACT), ...     right=Field(\"value\", encoding=Encoding.SEMANTIC), ... ) hb.ingest(df, collection=\"kv_store\", schema=schema)</p>"},{"location":"api/compose/molecules/#hybi.compose.Pair--query-what-value-is-associated-with-key-config_123","title":"Query: What value is associated with key \"config_123\"?","text":"<p>results = hb.query(\"kv_store\").find(left=\"config_123\")</p>"},{"location":"api/compose/molecules/#hybi.compose.Pair.molecule_type","title":"<code>molecule_type</code>  <code>property</code>","text":""},{"location":"api/compose/molecules/#hybi.compose.Pair.left","title":"<code>left</code>  <code>instance-attribute</code>","text":"<p>Configuration for the left element (Field or nested Molecule).</p>"},{"location":"api/compose/molecules/#hybi.compose.Pair.right","title":"<code>right</code>  <code>instance-attribute</code>","text":"<p>Configuration for the right element (Field or nested Molecule).</p>"},{"location":"api/compose/molecules/#hybi.compose.Pair.__init__","title":"<code>__init__(left, right, _skip_validation=False)</code>","text":""},{"location":"api/compose/molecules/#hybi.compose.Pair.slots","title":"<code>slots()</code>","text":""},{"location":"api/compose/molecules/#triple","title":"Triple","text":"<p>Three-element structure with <code>subject</code>, <code>predicate</code>, and <code>object</code> slots.</p> <pre><code>from hybi.compose import Triple, Field, Encoding\n\nschema = Triple(\n    subject=Field(\"entity\", encoding=Encoding.SEMANTIC),\n    predicate=Field(\"relation\", encoding=Encoding.EXACT),\n    object=Field(\"target\", encoding=Encoding.SEMANTIC),\n)\n</code></pre> <p>Supported queries: <code>find()</code>, <code>traverse()</code>, <code>search()</code>, <code>neighbors()</code>, <code>path()</code></p>"},{"location":"api/compose/molecules/#hybi.compose.Triple","title":"<code>hybi.compose.Triple</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseMolecule</code></p> <p>Three-element binding: Subject \u229b Predicate \u229b Object.</p> <p>Triple encodes knowledge graph facts and relationships. Optimized for queries that retrieve by any slot combination.</p> <p>Slots can be Fields or nested Molecules:</p> <pre><code># Simple: all slots are Fields\nTriple(\n    subject=Field(\"entity\"),\n    predicate=Field(\"relation\", encoding=Encoding.EXACT),\n    object=Field(\"target\"),\n)\n\n# Nested: subject is a typed entity (Pair)\nTriple(\n    subject=Pair(\n        left=Field(\"entity_type\", encoding=Encoding.EXACT),\n        right=Field(\"entity_name\"),\n    ),\n    predicate=Field(\"relation\"),\n    object=Field(\"target\"),\n)\n# Encoding: (type \u229b name) \u229b relation \u229b target\n</code></pre> Encoding <p>subject \u229b predicate \u229b object</p> Supported Queries <ul> <li>find(subject=X): Find predicates and objects for X</li> <li>find(object=Y): Find subjects and predicates pointing to Y</li> <li>find(predicate=P): Find all facts with relation P</li> <li>find(subject=X, predicate=P): Find objects</li> <li>traverse(start, path): Multi-hop graph traversal</li> <li>search(): Semantic similarity search</li> </ul> Example <p>schema = Triple( ...     subject=Field(\"entity\", encoding=Encoding.SEMANTIC), ...     predicate=Field(\"relation\", encoding=Encoding.EXACT), ...     object=Field(\"target\", encoding=Encoding.SEMANTIC), ... ) hb.ingest(facts_df, collection=\"knowledge\", schema=schema)</p>"},{"location":"api/compose/molecules/#hybi.compose.Triple--query-who-does-alice-work-with","title":"Query: Who does Alice work with?","text":"<p>results = hb.query(\"knowledge\").find( ...     subject=\"Alice\", ...     predicate=\"works_with\", ... )</p>"},{"location":"api/compose/molecules/#hybi.compose.Triple--multi-hop-alice-works_at-located_in-","title":"Multi-hop: Alice -&gt; works_at -&gt; ? -&gt; located_in -&gt; ?","text":"<p>locations = hb.query(\"knowledge\").traverse( ...     start={\"subject\": \"Alice\"}, ...     path=[\"works_at\", \"located_in\"], ... )</p>"},{"location":"api/compose/molecules/#hybi.compose.Triple.molecule_type","title":"<code>molecule_type</code>  <code>property</code>","text":""},{"location":"api/compose/molecules/#hybi.compose.Triple.subject","title":"<code>subject</code>  <code>instance-attribute</code>","text":"<p>Configuration for the subject (Field or nested Molecule).</p>"},{"location":"api/compose/molecules/#hybi.compose.Triple.predicate","title":"<code>predicate</code>  <code>instance-attribute</code>","text":"<p>Configuration for the predicate (Field or nested Molecule).</p>"},{"location":"api/compose/molecules/#hybi.compose.Triple.object","title":"<code>object</code>  <code>instance-attribute</code>","text":"<p>Configuration for the object (Field or nested Molecule).</p>"},{"location":"api/compose/molecules/#hybi.compose.Triple.__init__","title":"<code>__init__(subject, predicate, object, _skip_validation=False)</code>","text":""},{"location":"api/compose/molecules/#hybi.compose.Triple.slots","title":"<code>slots()</code>","text":""},{"location":"api/compose/molecules/#bundle","title":"Bundle","text":"<p>Multi-field structure with user-defined fields.</p> <pre><code>from hybi.compose import Bundle, Field, Encoding\n\nschema = Bundle(\n    fields={\n        \"name\": Field(encoding=Encoding.SEMANTIC, weight=1.5),\n        \"category\": Field(encoding=Encoding.EXACT),\n        \"price\": Field(encoding=Encoding.NUMERIC, similar_within=50),\n    }\n)\n</code></pre> <p>Bundle limitations</p> <p>Bundle uses search-optimized encoding. This means:</p> <ul> <li>Similarity scores decrease with field count</li> <li>Individual fields cannot be reliably extracted</li> <li>Bundles cannot be nested inside other molecules</li> </ul> <p>Supported queries: <code>search()</code>, <code>filter()</code>, <code>select()</code></p>"},{"location":"api/compose/molecules/#hybi.compose.Bundle","title":"<code>hybi.compose.Bundle</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseMolecule</code></p> <p>Bundled field-value bindings: \u03a3(role_i \u229b value_i).</p> <p>Bundle is the default encoding used by HyperBinder for structured data. Each field is bound with its role vector and all are bundled.</p> <p>This molecule makes the implicit Bundle encoding explicit and configurable with per-field settings.</p> <p>Composable Bundles:</p> <p>By default, Bundle is terminal \u2014 it cannot be nested inside other molecules. Set <code>composable=True</code> to enable nesting. Composable bundles use the bundle\u2192repair_unitarity\u2192braid pattern:</p> <ol> <li>Encode each field and bind with its role vector</li> <li>Weighted bundle (circular mean) all role-bound fillers</li> <li>repair_unitarity (QR projection back to unitary group)</li> <li>braid (bind with deterministic level key)</li> </ol> <p>The result is a unitary vector that can safely participate in further bind/unbind chains. See <code>atoms.braided_bundle()</code>.</p> Encoding <p>bundle(role_1 \u229b value_1, role_2 \u229b value_2, ...)</p> Supported Queries <ul> <li>search(): Semantic similarity search</li> <li>filter(where=[...]): Exact/range filtering</li> <li>select(fields=[...]): Projection</li> </ul> Example <p>schema = Bundle(fields={ ...     \"name\": Field(encoding=Encoding.SEMANTIC, weight=1.5), ...     \"description\": Field(encoding=Encoding.SEMANTIC, weight=2.0), ...     \"category\": Field(encoding=Encoding.EXACT), ...     \"price\": Field(encoding=Encoding.NUMERIC, similar_within=50), ... }) hb.ingest(products_df, collection=\"products\", schema=schema)</p>"},{"location":"api/compose/molecules/#hybi.compose.Bundle--composable-bundle-nested-inside-a-pair","title":"Composable bundle nested inside a Pair:","text":"<p>product_info = Bundle(composable=True, fields={ ...     \"name\": Field(encoding=Encoding.SEMANTIC), ...     \"price\": Field(encoding=Encoding.NUMERIC), ... }) schema = Pair(left=product_info, right=Field(encoding=Encoding.SEMANTIC))</p>"},{"location":"api/compose/molecules/#hybi.compose.Bundle.molecule_type","title":"<code>molecule_type</code>  <code>property</code>","text":""},{"location":"api/compose/molecules/#hybi.compose.Bundle.fields","title":"<code>fields = dataclass_field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mapping of field names to their configurations.</p>"},{"location":"api/compose/molecules/#hybi.compose.Bundle.__init__","title":"<code>__init__(fields=dict(), composable=False)</code>","text":""},{"location":"api/compose/molecules/#hybi.compose.Bundle.slots","title":"<code>slots()</code>","text":""},{"location":"api/compose/molecules/#sequence","title":"Sequence","text":"<p>Ordered items with positional encoding.</p> <pre><code>from hybi.compose import Sequence, Field\n\nschema = Sequence(\n    item=Field(\"token\", encoding=Encoding.SEMANTIC),\n    max_length=512,\n    position_encoding=\"random\",  # or \"sinusoidal\"\n)\n</code></pre>"},{"location":"api/compose/molecules/#parameters","title":"Parameters","text":"<ul> <li><code>item</code>: Field configuration for sequence elements</li> <li><code>max_length</code>: Maximum sequence length (default: 512)</li> <li><code>position_encoding</code>: How positions are encoded - \"random\" (default) or \"sinusoidal\"</li> </ul> <p>Supported queries: <code>search()</code>, <code>at(position)</code>, <code>contains()</code>, <code>prefix()</code></p>"},{"location":"api/compose/molecules/#hybi.compose.Sequence","title":"<code>hybi.compose.Sequence</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseMolecule</code></p> <p>Ordered elements with positional encoding: item \u229b position_vec(pos).</p> <p>Sequence encodes ordered data where position matters, like text tokens, time series, or ordered lists. Each row represents one item at a specific position. The item is bound with a deterministic position vector.</p> <p>The item slot can contain nested molecules:</p> <pre><code># Simple: item is a Field\nSequence(\n    item=Field(\"token\"),\n    position=Field(\"position\"),\n)\n\n# Nested: items are Pairs\nSequence(\n    item=Pair(\n        left=Field(\"word\"),\n        right=Field(\"pos_tag\", encoding=Encoding.EXACT),\n    ),\n    position=Field(\"position\"),\n)\n# Encoding: (word \u229b pos_tag) \u229b position_vec\n</code></pre> <p>Data Format (one row per item):     | position | token   |     |----------|---------|     | 0        | apple   |     | 1        | banana  |     | 2        | cherry  |</p> Encoding <p>item_vec \u229b position_vec(pos)</p> Supported Queries <ul> <li>search(): Semantic similarity search on items</li> <li>at(position=N): Find items at position N</li> </ul> Example <p>schema = Sequence( ...     item=Field(\"token\", encoding=Encoding.SEMANTIC), ...     position=Field(\"position\"), ... ) hb.ingest(tokens_df, collection=\"corpus\", schema=schema)</p>"},{"location":"api/compose/molecules/#hybi.compose.Sequence--query-what-items-are-at-position-0","title":"Query: What items are at position 0?","text":"<p>results = hb.query(\"corpus\").at(position=0)</p>"},{"location":"api/compose/molecules/#hybi.compose.Sequence--semantic-search-on-items","title":"Semantic search on items","text":"<p>results = hb.query(\"corpus\").search(\"fruit\")</p>"},{"location":"api/compose/molecules/#hybi.compose.Sequence.molecule_type","title":"<code>molecule_type</code>  <code>property</code>","text":""},{"location":"api/compose/molecules/#hybi.compose.Sequence.item","title":"<code>item</code>  <code>instance-attribute</code>","text":"<p>Configuration for the sequence elements (Field or nested Molecule).</p>"},{"location":"api/compose/molecules/#hybi.compose.Sequence.__init__","title":"<code>__init__(item, position=None, position_encoding='random', max_length=512, _skip_validation=False)</code>","text":""},{"location":"api/compose/molecules/#hybi.compose.Sequence.slots","title":"<code>slots()</code>","text":""},{"location":"api/compose/molecules/#tree","title":"Tree","text":"<p>Parent-child relationships with <code>child</code> and <code>parent</code> slots.</p> <pre><code>from hybi.compose import Tree, Field\n\nschema = Tree(\n    child=Field(\"employee\"),\n    parent=Field(\"manager\"),\n    level=Field(\"depth\"),  # optional\n)\n</code></pre>"},{"location":"api/compose/molecules/#parameters_1","title":"Parameters","text":"<ul> <li><code>child</code>: Field for child/node identifier</li> <li><code>parent</code>: Field for parent identifier</li> <li><code>level</code>: Optional Field for depth/level in hierarchy</li> </ul> <p>Supported queries: <code>search()</code>, <code>find()</code>, <code>children()</code>, <code>parent()</code>, <code>ancestors()</code>, <code>descendants()</code>, <code>siblings()</code></p>"},{"location":"api/compose/molecules/#hybi.compose.Tree","title":"<code>hybi.compose.Tree</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseMolecule</code></p> <p>Hierarchical parent-child relationships: child \u229b parent \u229b level(n).</p> <p>Tree encodes hierarchical structures like org charts, file systems, or taxonomies. Enables traversal queries up and down the hierarchy.</p> <p>Slots can contain nested molecules:</p> <pre><code># Simple: all slots are Fields\nTree(\n    child=Field(\"employee\"),\n    parent=Field(\"manager\"),\n)\n\n# Nested: nodes are typed entities\nTree(\n    child=Pair(\n        left=Field(\"dept\", encoding=Encoding.EXACT),\n        right=Field(\"employee_name\"),\n    ),\n    parent=Pair(\n        left=Field(\"dept\", encoding=Encoding.EXACT),\n        right=Field(\"manager_name\"),\n    ),\n)\n# Encoding: (dept \u229b employee) \u229b (dept \u229b manager) \u229b level\n</code></pre> Encoding <p>child \u229b parent \u229b level(depth)</p> Supported Queries <ul> <li>search(): Semantic similarity search</li> <li>find(child=X): Find parent of X</li> <li>find(parent=Y): Find children of Y</li> <li>children(node): Direct children of a node</li> <li>parent(node): Direct parent of a node</li> <li>ancestors(node, depth): N levels up</li> <li>descendants(node, depth): N levels down</li> <li>siblings(node): Nodes with same parent</li> </ul> Example <p>schema = Tree( ...     child=Field(\"employee\"), ...     parent=Field(\"manager\"), ... ) hb.ingest(org_df, collection=\"org\", schema=schema)</p>"},{"location":"api/compose/molecules/#hybi.compose.Tree--query-who-reports-to-alice","title":"Query: Who reports to Alice?","text":"<p>reports = hb.query(\"org\").children(\"Alice\")</p>"},{"location":"api/compose/molecules/#hybi.compose.Tree--query-full-reporting-chain-for-bob","title":"Query: Full reporting chain for Bob","text":"<p>chain = hb.query(\"org\").ancestors(\"Bob\")</p>"},{"location":"api/compose/molecules/#hybi.compose.Tree.molecule_type","title":"<code>molecule_type</code>  <code>property</code>","text":""},{"location":"api/compose/molecules/#hybi.compose.Tree.child","title":"<code>child</code>  <code>instance-attribute</code>","text":"<p>Configuration for the child node (Field or nested Molecule).</p>"},{"location":"api/compose/molecules/#hybi.compose.Tree.parent","title":"<code>parent</code>  <code>instance-attribute</code>","text":"<p>Configuration for the parent node (Field or nested Molecule).</p>"},{"location":"api/compose/molecules/#hybi.compose.Tree.__init__","title":"<code>__init__(child, parent, level=None, _skip_validation=False)</code>","text":""},{"location":"api/compose/molecules/#hybi.compose.Tree.slots","title":"<code>slots()</code>","text":""},{"location":"api/compose/molecules/#graph","title":"Graph","text":"<p>Node-edge-node structure with <code>source</code>, <code>edge</code>, and <code>target</code> slots.</p> <pre><code>from hybi.compose import Graph, Field\n\n# Define with a single node Field (used for both source and target)\nschema = Graph(\n    node=Field(\"entity\"),\n    edge=Field(\"relation\", encoding=Encoding.EXACT),\n    directed=True,\n)\n</code></pre>"},{"location":"api/compose/molecules/#querying-graph","title":"Querying Graph","text":"<p>Graph has three slots (<code>source</code>, <code>edge</code>, <code>target</code>) but only two Field configurations (<code>node</code>, <code>edge</code>). The <code>node</code> Field applies to both source and target. You can query using either:</p> <pre><code>q = hb.query(\"social\", schema=schema)\n\n# By column name (what appears in your DataFrame)\nq.find(entity=\"Alice\")     # Matches both source and target\n\n# By slot name (the structural role)\nq.find(source=\"Alice\")     # Only source nodes\nq.find(target=\"Bob\")       # Only target nodes\n</code></pre> <p>Both column names and slot names are valid query keys. This lets you distinguish between finding rows where a node appears as source vs target.</p> <p>Supported queries: <code>neighbors()</code>, <code>path()</code>, <code>subgraph()</code>, <code>traverse()</code></p>"},{"location":"api/compose/molecules/#hybi.compose.Graph","title":"<code>hybi.compose.Graph</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseMolecule</code></p> <p>General graph structure: node \u229b edge \u229b node.</p> <p>Graph encodes network relationships with typed edges. Supports both directed and undirected graphs, and enables traversal, path finding, and neighborhood queries.</p> <p>The node and edge slots can contain nested molecules:</p> <pre><code># Simple: all slots are Fields\nGraph(\n    node=Field(\"entity\"),\n    edge=Field(\"relation\", encoding=Encoding.EXACT),\n)\n\n# Nested: nodes are typed entities\nGraph(\n    node=Pair(\n        left=Field(\"node_type\", encoding=Encoding.EXACT),\n        right=Field(\"node_name\"),\n    ),\n    edge=Field(\"relation\"),\n)\n# Encoding: (type \u229b name) \u229b relation \u229b (type \u229b name)\n</code></pre> Encoding <p>source_node \u229b edge \u229b target_node</p> Supported Queries <ul> <li>search(): Semantic similarity search</li> <li>find(source=X): Find edges and targets from X</li> <li>find(target=Y): Find sources and edges pointing to Y</li> <li>find(edge=E): Find all connections with edge type E</li> <li>neighbors(node, edge): Connected nodes via edge type</li> <li>path(from, to, max_hops): Path finding</li> <li>subgraph(seed, radius): Local neighborhood</li> <li>traverse(start, pattern): Pattern matching traversal</li> </ul> Example <p>schema = Graph( ...     node=Field(\"entity\"), ...     edge=Field(\"relation\", encoding=Encoding.EXACT), ...     directed=True, ... ) hb.ingest(network_df, collection=\"social\", schema=schema)</p>"},{"location":"api/compose/molecules/#hybi.compose.Graph--query-who-are-alices-friends","title":"Query: Who are Alice's friends?","text":"<p>friends = hb.query(\"social\").neighbors(\"Alice\", edge=\"friends_with\")</p>"},{"location":"api/compose/molecules/#hybi.compose.Graph--query-path-from-alice-to-charlie","title":"Query: Path from Alice to Charlie","text":"<p>path = hb.query(\"social\").path(from_node=\"Alice\", to_node=\"Charlie\", max_hops=3)</p>"},{"location":"api/compose/molecules/#hybi.compose.Graph.molecule_type","title":"<code>molecule_type</code>  <code>property</code>","text":""},{"location":"api/compose/molecules/#hybi.compose.Graph.node","title":"<code>node</code>  <code>instance-attribute</code>","text":"<p>Configuration for node values (Field or nested Molecule).</p> <p>Note: In wire format, this is used for both source and target nodes.</p>"},{"location":"api/compose/molecules/#hybi.compose.Graph.edge","title":"<code>edge</code>  <code>instance-attribute</code>","text":"<p>Configuration for edge/relationship types (Field or nested Molecule).</p>"},{"location":"api/compose/molecules/#hybi.compose.Graph.directed","title":"<code>directed = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether edges are directed.</p> <p>If True, source -&gt; target (asymmetric). If False, connections are symmetric.</p>"},{"location":"api/compose/molecules/#hybi.compose.Graph.__init__","title":"<code>__init__(node, edge, directed=True, _skip_validation=False)</code>","text":""},{"location":"api/compose/molecules/#hybi.compose.Graph.slots","title":"<code>slots()</code>","text":""},{"location":"api/compose/molecules/#row","title":"Row","text":"<p>Primary-key addressed fields for SQL-like CRUD operations.</p> <p>Row enables SQL-like CRUD operations by using structured encoding instead of search-optimized encoding. This makes individual fields extractable and updatable without affecting other fields.</p> <pre><code>from hybi.compose import Row, Field, Encoding\n\nschema = Row(\n    primary_key=Field(\"user_id\", encoding=Encoding.EXACT),\n    fields={\n        \"email\": Field(encoding=Encoding.EXACT),\n        \"name\": Field(encoding=Encoding.SEMANTIC),\n        \"salary\": Field(encoding=Encoding.NUMERIC, similar_within=10000),\n    },\n    field_order=[\"name\", \"email\", \"salary\"],  # optional explicit ordering\n)\n</code></pre>"},{"location":"api/compose/molecules/#parameters_2","title":"Parameters","text":"<ul> <li><code>primary_key</code>: Field for the primary key (must use EXACT encoding)</li> <li><code>fields</code>: Dict mapping field names to Field configurations</li> <li><code>field_order</code>: Optional list specifying field encoding order</li> </ul> <p>Use RelationalTable instead</p> <p>Row is the underlying molecule, but most users should use the RelationalTable compound which provides a more intuitive column-based API.</p> <p>Supported queries: <code>get(pk=X)</code>, <code>update(pk=X, set={...})</code>, <code>delete(pk=X)</code>, <code>search()</code>, <code>filter()</code></p>"},{"location":"api/compose/molecules/#hybi.compose.Row","title":"<code>hybi.compose.Row</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseMolecule</code></p> <p>Primary-key addressed row with named fields: pk \u229b (f1 \u229b v1) \u229b (f2 \u229b v2) \u229b ...</p> <p>Row encodes database-like records with a primary key for addressing and named fields for data. Unlike Bundle (which uses lossy superposition), Row uses chain binding which is lossless - any field can be extracted cleanly by unbinding with its role vector.</p> <p>This enables SQL-like CRUD operations: - Read individual fields without noise from other fields - Update specific fields without re-encoding entire row - Delete rows by primary key</p> <p>The primary key must use EXACT encoding for deterministic lookups.</p> Encoding <p>pk_value \u229b (field1_role \u229b field1_value) \u229b (field2_role \u229b field2_value) \u229b ...</p> Supported Queries <ul> <li>get(pk=X): O(1) lookup by primary key</li> <li>filter(where=[...]): Filter by field values</li> <li>search(): Semantic similarity search</li> <li>update(pk=X, set={...}): Update field values</li> <li>delete(pk=X): Delete row</li> </ul> Example <p>schema = Row( ...     primary_key=Field(\"user_id\", encoding=Encoding.EXACT), ...     fields={ ...         \"email\": Field(encoding=Encoding.EXACT), ...         \"name\": Field(encoding=Encoding.SEMANTIC), ...         \"salary\": Field(encoding=Encoding.NUMERIC), ...     }, ... )</p> <p>Note: Row is typically used via the RelationalTable compound, which provides a more user-friendly API with column-based definition.</p>"},{"location":"api/compose/molecules/#hybi.compose.Row.molecule_type","title":"<code>molecule_type</code>  <code>property</code>","text":""},{"location":"api/compose/molecules/#hybi.compose.Row.primary_key","title":"<code>primary_key</code>  <code>instance-attribute</code>","text":"<p>Field configuration for the primary key (must use EXACT encoding).</p>"},{"location":"api/compose/molecules/#hybi.compose.Row.fields","title":"<code>fields = dataclass_field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Mapping of field names to their configurations.</p>"},{"location":"api/compose/molecules/#hybi.compose.Row.__init__","title":"<code>__init__(primary_key, fields=dict(), field_order=None)</code>","text":""},{"location":"api/compose/molecules/#hybi.compose.Row.slots","title":"<code>slots()</code>","text":"<p>Return PK name followed by field names in order.</p>"},{"location":"api/compose/molecules/#nesting-molecules","title":"Nesting Molecules","text":"<p>Structured molecules can be nested:</p> <pre><code># Typed entity knowledge graph\nschema = Triple(\n    subject=Pair(\n        left=Field(\"entity_type\", encoding=Encoding.EXACT),\n        right=Field(\"entity_name\"),\n    ),\n    predicate=Field(\"relation\", encoding=Encoding.EXACT),\n    object=Pair(\n        left=Field(\"target_type\", encoding=Encoding.EXACT),\n        right=Field(\"target_name\"),\n    ),\n)\n</code></pre> <p>Nesting rules:</p> <ul> <li>Structured molecules (Pair, Triple, Row, Tree, Graph, Sequence) can nest inside each other</li> <li>Bundle cannot be nested (uses search-optimized encoding)</li> <li>Row is typically used at the top level (not nested) for table schemas</li> <li>Validation happens at construction time</li> </ul>"},{"location":"api/compose/molecules/#querying-nested-schemas","title":"Querying Nested Schemas","text":"<p>When querying nested schemas, you can use column names directly instead of navigating the slot hierarchy.</p> <pre><code># For the schema above, all of these work:\nq = hb.query(\"entities\", schema=schema)\n\n# By column name (recommended for nested schemas)\nresults = q.find(entity_type=\"Person\", entity_name=\"Alice\")\n\n# By top-level slot (backward compatible)\nresults = q.find(subject=\"Alice\")\n\n# By dot notation (explicit path)\nresults = q.find(**{\"subject.left\": \"Person\"})\n</code></pre>"},{"location":"api/compose/molecules/#field-resolution","title":"Field Resolution","text":"<p>The <code>resolve_field()</code> method maps query field names to their schema paths:</p> Input Resolves To Example Column name Leaf field <code>\"entity_type\"</code> \u2192 <code>subject.left</code> Top-level slot First matching field <code>\"subject\"</code> \u2192 <code>subject.left</code> Dot notation Explicit path <code>\"subject.left\"</code> \u2192 <code>subject.left</code>"},{"location":"api/compose/molecules/#valid-query-fields","title":"Valid Query Fields","text":"<p>Use <code>valid_query_fields()</code> to see all accepted field names:</p> <pre><code>&gt;&gt;&gt; schema.valid_query_fields()\n['entity_type', 'entity_name', 'relation', 'target_type', 'target_name',\n 'subject', 'predicate', 'object']\n</code></pre>"},{"location":"api/compose/molecules/#ambiguous-field-names","title":"Ambiguous Field Names","text":"<p>If the same column name appears in multiple nested locations, use dot notation to disambiguate:</p> <pre><code># If both subject and object have a \"name\" field with the same column name,\n# an AmbiguousFieldError is raised. Use dot notation instead:\nresults = q.find(**{\"subject.right\": \"Alice\"})\n</code></pre>"},{"location":"api/compose/query/","title":"Query Builder","text":"<p>The <code>ComposeQuery</code> class provides schema-aware query operations.</p>"},{"location":"api/compose/query/#getting-a-query-builder","title":"Getting a Query Builder","text":"<pre><code># From client with schema\nq = hb.query(\"facts\", schema=schema)\n\n# From collection (schema loaded from server)\nq = hb.collection(\"facts\").query()\n</code></pre>"},{"location":"api/compose/query/#universal-methods","title":"Universal Methods","text":"<p>Available on all molecule types.</p>"},{"location":"api/compose/query/#search","title":"search()","text":"<p>Semantic similarity search.</p> <pre><code>results = q.search(\"machine learning\", top_k=10)\n\n# Slot-specific search (chain molecules only)\nresults = q.search(\"Einstein\", slot=\"subject\")\n</code></pre>"},{"location":"api/compose/query/#search_slots","title":"search_slots()","text":"<p>Multi-slot weighted search.</p> <pre><code>results = q.search_slots({\n    \"subject\": (\"Einstein\", 2.0),  # Query, weight\n    \"object\": (\"physics\", 1.0),\n})\n</code></pre>"},{"location":"api/compose/query/#search_prototype","title":"search_prototype()","text":"<p>Find items similar to any of the examples.</p> <pre><code>results = q.search_prototype(\n    examples=[\"Dune\", \"Foundation\", \"Neuromancer\"],\n    top_k=10\n)\n</code></pre>"},{"location":"api/compose/query/#all","title":"all()","text":"<p>Fetch all rows.</p> <pre><code>results = q.all(top_k=100)\n</code></pre>"},{"location":"api/compose/query/#slot-based-methods","title":"Slot-Based Methods","text":"<p>For chain-encoded molecules (Pair, Triple, Tree, Graph).</p>"},{"location":"api/compose/query/#find","title":"find()","text":"<p>Find by field values.</p> <pre><code># Find all facts about Einstein\nresults = q.find(subject=\"Einstein\")\n\n# Find all \"works_at\" relationships\nresults = q.find(predicate=\"works_at\")\n\n# Combined\nresults = q.find(subject=\"Einstein\", predicate=\"works_at\")\n</code></pre> <p>Nested schema support: For nested schemas, use column names directly:</p> <pre><code># Schema: Triple(subject=Pair(left=Field(\"universe\"), right=Field(\"name\")), ...)\nschema = Triple(\n    subject=Pair(\n        left=Field(\"subject_universe\", encoding=Encoding.EXACT),\n        right=Field(\"subject_name\", encoding=Encoding.SEMANTIC),\n    ),\n    predicate=Field(\"relation\", encoding=Encoding.EXACT),\n    object=Field(\"target\"),\n)\n\nq = hb.query(\"characters\", schema=schema)\n\n# Query by column name (recommended)\nresults = q.find(subject_universe=\"Marvel\", subject_name=\"Thor\")\n\n# Query by top-level slot (backward compatible)\nresults = q.find(subject=\"Thor\")\n\n# Query by dot notation (explicit path)\nresults = q.find(**{\"subject.left\": \"Marvel\"})\n</code></pre>"},{"location":"api/compose/query/#get","title":"get()","text":"<p>Exact single-row lookup.</p> <pre><code>result = q.get(subject=\"Einstein\", predicate=\"born_in\")\n# Returns single result or raises NotFoundError\n</code></pre>"},{"location":"api/compose/query/#traversal-methods","title":"Traversal Methods","text":"<p>For Triple, Tree, and Graph molecules.</p>"},{"location":"api/compose/query/#traverse","title":"traverse()","text":"<p>Multi-hop path following.</p> <pre><code># Exact traversal\nresults = q.traverse(\n    start={\"subject\": \"Einstein\"},\n    path=[\"worked_at\", \"located_in\"],\n)\n</code></pre>"},{"location":"api/compose/query/#traverse_fuzzy","title":"traverse_fuzzy()","text":"<p>Semantic path following.</p> <pre><code>results = q.traverse_fuzzy(\n    start=\"Albert Einstein\",\n    start_slot=\"subject\",\n    path=[\"employment\", \"location\"],\n    hop_threshold=0.6,  # Minimum similarity per hop\n)\n</code></pre>"},{"location":"api/compose/query/#tree-specific-methods","title":"Tree-Specific Methods","text":"<p>For Tree and Hierarchy molecules.</p>"},{"location":"api/compose/query/#children","title":"children()","text":"<p>Get direct children of a node.</p> <pre><code>results = q.children(\"Alice\", top_k=10)\n</code></pre>"},{"location":"api/compose/query/#parent","title":"parent()","text":"<p>Get parent of a node.</p> <pre><code>result = q.parent(\"Bob\")\n</code></pre>"},{"location":"api/compose/query/#ancestors","title":"ancestors()","text":"<p>Get all ancestors up the tree.</p> <pre><code>results = q.ancestors(\"Bob\", depth=3)\n</code></pre>"},{"location":"api/compose/query/#descendants","title":"descendants()","text":"<p>Get all descendants down the tree.</p> <pre><code>results = q.descendants(\"Alice\", depth=2)\n</code></pre>"},{"location":"api/compose/query/#siblings","title":"siblings()","text":"<p>Get nodes with same parent.</p> <pre><code>results = q.siblings(\"Bob\")\n</code></pre>"},{"location":"api/compose/query/#graph-specific-methods","title":"Graph-Specific Methods","text":"<p>For Graph and Network molecules.</p>"},{"location":"api/compose/query/#neighbors","title":"neighbors()","text":"<p>Get connected nodes.</p> <pre><code>results = q.neighbors(\"Alice\", radius=1)\n</code></pre>"},{"location":"api/compose/query/#path","title":"path()","text":"<p>Find path between nodes.</p> <pre><code>results = q.path(source=\"Alice\", target=\"Bob\", max_hops=3)\n</code></pre>"},{"location":"api/compose/query/#subgraph","title":"subgraph()","text":"<p>Extract local neighborhood.</p> <pre><code>results = q.subgraph(center=\"Alice\", radius=2)\n</code></pre>"},{"location":"api/compose/query/#filter-select-methods","title":"Filter &amp; Select Methods","text":"<p>SQL-like operations.</p>"},{"location":"api/compose/query/#filter","title":"filter()","text":"<p>Apply conditions.</p> <pre><code>results = q.filter(\n    where=[\n        (\"price\", \"&lt;\", 1000),\n        (\"category\", \"==\", \"electronics\"),\n    ],\n    top_k=50\n)\n</code></pre>"},{"location":"api/compose/query/#select","title":"select()","text":"<p>Column projection.</p> <pre><code>results = q.select(\n    fields=[\"name\", \"price\"],\n    where=[(\"status\", \"==\", \"active\")],\n)\n</code></pre>"},{"location":"api/compose/query/#aggregate","title":"aggregate()","text":"<p>GROUP BY aggregation.</p> <pre><code>results = q.aggregate(\n    group_by=\"category\",\n    field=\"price\",\n    function=\"avg\",\n)\n</code></pre>"},{"location":"api/compose/query/#method-chaining","title":"Method Chaining","text":"<p>Methods can be chained:</p> <pre><code>results = (\n    q.search(\"laptop\")\n    .filter(where=[(\"price\", \"&lt;\", 1000)])\n    .top(5)\n)\n</code></pre>"},{"location":"api/compose/query/#result-types","title":"Result Types","text":""},{"location":"api/compose/query/#hybi.compose.ComposeResult","title":"<code>hybi.compose.ComposeResult</code>  <code>dataclass</code>","text":"<p>A single result from a Compose query.</p> <p>ComposeResult wraps search results with schema-aware slot accessors. When a schema is available, you can access slot values directly as attributes (e.g., result.subject, result.predicate).</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Dict[str, Any]</code> <p>The raw result data as a dictionary</p> <code>score</code> <code>float</code> <p>Similarity score (0-1, higher is better)</p> <code>id</code> <code>int</code> <p>Row identifier in the collection</p> Example"},{"location":"api/compose/query/#hybi.compose.ComposeResult--with-triple-schema","title":"With Triple schema","text":"<p>results = hb.query(\"facts\").find(subject=\"Alice\") for r in results: ...     print(f\"{r.subject} {r.predicate} {r.object}\") ...     print(f\"Score: {r.score:.3f}\")</p>"},{"location":"api/compose/query/#hybi.compose.ComposeResult--dict-like-access-also-works","title":"Dict-like access also works","text":"<p>print(r[\"subject\"]) print(r.get(\"missing_field\", \"default\"))</p>"},{"location":"api/compose/query/#hybi.compose.ComposeResult.data","title":"<code>data</code>  <code>instance-attribute</code>","text":"<p>The raw result data as a dictionary.</p>"},{"location":"api/compose/query/#hybi.compose.ComposeResult.score","title":"<code>score</code>  <code>instance-attribute</code>","text":"<p>Similarity score (0-1, higher is better).</p>"},{"location":"api/compose/query/#hybi.compose.ComposeResult.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Allow dict-like access: result['name']</p>"},{"location":"api/compose/query/#hybi.compose.ComposeResult.get","title":"<code>get(key, default=None)</code>","text":"<p>Dict-like get with default.</p>"},{"location":"api/compose/query/#hybi.compose.ComposeResult.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to a plain dictionary.</p> <p>Returns the data dict plus score and id.</p>"},{"location":"api/compose/query/#hybi.compose.ComposeResultSet","title":"<code>hybi.compose.ComposeResultSet</code>  <code>dataclass</code>","text":"<p>A collection of ComposeResults with convenience methods.</p> <p>Supports iteration, indexing, and bulk operations.</p> Example <p>results = hb.query(\"facts\").find(subject=\"Alice\") print(f\"Found {len(results)} results\") for r in results: ...     print(r.object)</p>"},{"location":"api/compose/query/#hybi.compose.ComposeResultSet--get-top-result","title":"Get top result","text":"<p>best = results[0]</p>"},{"location":"api/compose/query/#hybi.compose.ComposeResultSet--convert-all-to-dicts","title":"Convert all to dicts","text":"<p>dicts = results.to_list()</p>"},{"location":"api/compose/query/#hybi.compose.ComposeResultSet.__iter__","title":"<code>__iter__()</code>","text":""},{"location":"api/compose/query/#hybi.compose.ComposeResultSet.__len__","title":"<code>__len__()</code>","text":""},{"location":"api/compose/query/#hybi.compose.ComposeResultSet.first","title":"<code>first()</code>","text":"<p>Get the first result, or None if empty.</p>"},{"location":"api/compose/query/#hybi.compose.ComposeResultSet.to_list","title":"<code>to_list()</code>","text":"<p>Convert all results to plain dictionaries.</p>"},{"location":"api/compose/query/#hybi.compose.ComposeResultSet.to_dataframe","title":"<code>to_dataframe()</code>","text":"<p>Convert results to a pandas DataFrame.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame with columns from data plus _score and _id</p>"},{"location":"api/compose/query/#hybi.compose.ComposeResultSet.filter","title":"<code>filter(predicate)</code>","text":"<p>Filter results by a predicate function.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[ComposeResult], bool]</code> <p>Function that takes ComposeResult, returns bool</p> required <p>Returns:</p> Type Description <code>ComposeResultSet</code> <p>New ComposeResultSet with filtered results</p>"},{"location":"api/compose/validation/","title":"Validation","text":"<p>Schema validation utilities for ensuring data matches your compose schemas.</p>"},{"location":"api/compose/validation/#overview","title":"Overview","text":"<p>The validation module provides tools to:</p> <ul> <li>Verify DataFrame columns match schema fields</li> <li>Check encoding-specific type constraints</li> <li>Infer schemas from DataFrames automatically</li> <li>Validate queries against schema capabilities</li> </ul>"},{"location":"api/compose/validation/#quick-start","title":"Quick Start","text":"<pre><code>from hybi.compose import Triple, Field, validate_schema_against_dataframe\nimport pandas as pd\n\n# Define schema\nschema = Triple(\n    subject=Field(\"person\"),\n    predicate=Field(\"relation\"),\n    object=Field(\"company\"),\n)\n\n# Check if DataFrame matches\ndf = pd.DataFrame({\n    \"person\": [\"Alice\", \"Bob\"],\n    \"relation\": [\"works_at\", \"works_at\"],\n    \"company\": [\"Acme\", \"Globex\"],\n})\n\nerrors = validate_schema_against_dataframe(schema, df)\nif errors:\n    for e in errors:\n        print(f\"{e.severity}: {e.field} - {e.message}\")\nelse:\n    print(\"Validation passed!\")\n</code></pre>"},{"location":"api/compose/validation/#validationresult","title":"ValidationResult","text":"<p>Result object returned by validation functions.</p> <pre><code>from hybi.compose import ValidationResult\n</code></pre>"},{"location":"api/compose/validation/#hybi.compose.ValidationResult","title":"<code>hybi.compose.ValidationResult</code>  <code>dataclass</code>","text":"<p>Result of schema validation.</p>"},{"location":"api/compose/validation/#hybi.compose.ValidationResult.field","title":"<code>field</code>  <code>instance-attribute</code>","text":"<p>Field name that was validated.</p>"},{"location":"api/compose/validation/#hybi.compose.ValidationResult.message","title":"<code>message</code>  <code>instance-attribute</code>","text":"<p>Description of the issue or success.</p>"},{"location":"api/compose/validation/#hybi.compose.ValidationResult.severity","title":"<code>severity = 'error'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Severity level: 'error' or 'warning'.</p>"},{"location":"api/compose/validation/#hybi.compose.ValidationResult.is_error","title":"<code>is_error</code>  <code>property</code>","text":""},{"location":"api/compose/validation/#hybi.compose.ValidationResult.is_warning","title":"<code>is_warning</code>  <code>property</code>","text":""},{"location":"api/compose/validation/#validationstrategy","title":"ValidationStrategy","text":"<p>Control how thoroughly validation checks data.</p> <pre><code>from hybi.compose import ValidationStrategy\n</code></pre> Strategy Description Speed <code>FULL</code> Check every row Slowest, most thorough <code>SAMPLED</code> Check random sample (default) Good balance <code>SCHEMA_ONLY</code> Only check column existence Fastest"},{"location":"api/compose/validation/#hybi.compose.ValidationStrategy","title":"<code>hybi.compose.ValidationStrategy</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Strategy for validating schema against DataFrame.</p> <p>Different strategies trade off thoroughness vs performance.</p>"},{"location":"api/compose/validation/#hybi.compose.ValidationStrategy.FULL","title":"<code>FULL = 'full'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Check every row (current behavior). Most thorough but slowest.</p>"},{"location":"api/compose/validation/#hybi.compose.ValidationStrategy.SAMPLED","title":"<code>SAMPLED = 'sampled'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Check a random sample of rows. Good balance of speed and coverage.</p>"},{"location":"api/compose/validation/#hybi.compose.ValidationStrategy.SCHEMA_ONLY","title":"<code>SCHEMA_ONLY = 'schema_only'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Only check column existence. Fastest but least thorough.</p>"},{"location":"api/compose/validation/#validationconfig","title":"ValidationConfig","text":"<p>Configuration for validation behavior.</p> <pre><code>from hybi.compose import ValidationConfig, ValidationStrategy\n\n# Fast validation for large datasets\nconfig = ValidationConfig(\n    strategy=ValidationStrategy.SAMPLED,\n    sample_size=1000,\n)\n\n# Thorough validation for critical data\nconfig = ValidationConfig(\n    strategy=ValidationStrategy.FULL,\n)\n</code></pre>"},{"location":"api/compose/validation/#hybi.compose.ValidationConfig","title":"<code>hybi.compose.ValidationConfig</code>  <code>dataclass</code>","text":"<p>Configuration for schema validation.</p> Example <p>config = ValidationConfig( ...     strategy=ValidationStrategy.SAMPLED, ...     sample_size=1000, ... ) errors = validate_schema_against_dataframe(schema, df, config=config)</p>"},{"location":"api/compose/validation/#hybi.compose.ValidationConfig.strategy","title":"<code>strategy = ValidationStrategy.SAMPLED</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Validation strategy to use. Default: SAMPLED for good balance.</p>"},{"location":"api/compose/validation/#hybi.compose.ValidationConfig.sample_size","title":"<code>sample_size = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Number of rows to sample for SAMPLED strategy. Default: 1000.</p>"},{"location":"api/compose/validation/#hybi.compose.ValidationConfig.sample_seed","title":"<code>sample_seed = 42</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random seed for reproducible sampling. Default: 42.</p>"},{"location":"api/compose/validation/#validation-functions","title":"Validation Functions","text":""},{"location":"api/compose/validation/#validate_schema_against_dataframe","title":"validate_schema_against_dataframe","text":"<p>Main validation function that checks schema compatibility.</p> <pre><code>from hybi.compose import (\n    Triple, Field, Encoding,\n    validate_schema_against_dataframe,\n    ValidationConfig,\n    ValidationStrategy,\n)\n\nschema = Triple(\n    subject=Field(\"entity\", encoding=Encoding.SEMANTIC),\n    predicate=Field(\"relation\", encoding=Encoding.EXACT),\n    object=Field(\"target\", encoding=Encoding.SEMANTIC),\n)\n\n# Basic validation (uses SAMPLED strategy by default)\nerrors = validate_schema_against_dataframe(schema, df)\n\n# Fast validation for large datasets\nerrors = validate_schema_against_dataframe(\n    schema, df,\n    config=ValidationConfig(strategy=ValidationStrategy.SCHEMA_ONLY),\n)\n\n# Thorough validation\nerrors = validate_schema_against_dataframe(\n    schema, df,\n    config=ValidationConfig(strategy=ValidationStrategy.FULL),\n)\n</code></pre> <p>Checks performed:</p> <ol> <li>Column existence: All schema field names exist as DataFrame columns</li> <li>Null values: Required fields have no null values (SAMPLED/FULL)</li> <li>Type constraints: NUMERIC fields are numeric, TEMPORAL fields are datetime (SAMPLED/FULL)</li> </ol>"},{"location":"api/compose/validation/#hybi.compose.validate_schema_against_dataframe","title":"<code>hybi.compose.validate_schema_against_dataframe(schema, df, strict=True, config=None)</code>","text":"<p>Validate that a schema matches a DataFrame.</p> <p>Checks: - All schema field names exist as DataFrame columns - Required fields have no null values (if strategy allows) - Encoding-specific type constraints (if strategy allows)</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>BaseMolecule</code> <p>The molecule schema to validate</p> required <code>df</code> <code>DataFrame</code> <p>DataFrame to validate against</p> required <code>strict</code> <code>bool</code> <p>If True (default), all errors are blocking.     If False, collect all errors without stopping.</p> <code>True</code> <code>config</code> <code>Optional[ValidationConfig]</code> <p>Validation configuration. Default uses SAMPLED strategy     with 1000 rows for good balance of speed and coverage.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[ValidationResult]</code> <p>List of ValidationResult objects (empty if valid)</p> Example <p>schema = Triple( ...     subject=Field(\"person\"), ...     predicate=Field(\"relation\"), ...     object=Field(\"company\"), ... ) errors = validate_schema_against_dataframe(schema, df) if errors: ...     for e in errors: ...         print(f\"{e.severity}: {e.message}\")</p>"},{"location":"api/compose/validation/#validate_query_for_schema","title":"validate_query_for_schema","text":"<p>Validate that a query is valid for a given schema type.</p> <pre><code>from hybi.compose import Triple, Field, validate_query_for_schema\n\nschema = Triple(\n    subject=Field(\"entity\"),\n    predicate=Field(\"relation\"),\n    object=Field(\"target\"),\n)\n\n# Valid queries\nvalidate_query_for_schema(schema, \"find\", entity=\"Alice\")  # OK\nvalidate_query_for_schema(schema, \"search\", top_k=10)       # OK\n\n# Invalid query method\nvalidate_query_for_schema(schema, \"at\", position=5)\n# Raises SchemaError: 'at' not supported by Triple\n</code></pre>"},{"location":"api/compose/validation/#hybi.compose.validate_query_for_schema","title":"<code>hybi.compose.validate_query_for_schema(schema, query_method, **kwargs)</code>","text":"<p>Validate that a query is valid for a schema.</p> <p>Checks: - Query method is supported by the schema type - Field names in kwargs are valid for the schema (including nested fields)</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>BaseMolecule</code> <p>The molecule schema</p> required <code>query_method</code> <code>str</code> <p>Name of the query method (e.g., 'find', 'traverse')</p> required <code>**kwargs</code> <code>Any</code> <p>Query parameters (field values, options)</p> <code>{}</code> <p>Raises:</p> Type Description <code>SchemaError</code> <p>If query method is not supported by schema</p> <code>SlotError</code> <p>If query uses invalid field names</p> <code>AmbiguousFieldError</code> <p>If field name appears in multiple nested paths</p> Example <p>schema = Triple(subject=Field(\"entity\"), predicate=Field(\"relation\"), object=Field(\"target\")) validate_query_for_schema(schema, \"find\", entity=\"Alice\")  # OK - by column name validate_query_for_schema(schema, \"find\", subject=\"Alice\")  # OK - by slot name validate_query_for_schema(schema, \"at\", position=5)  # Raises SchemaError</p> For nested schemas <p>schema = Triple( ...     subject=Pair(left=Field(\"subject_type\"), right=Field(\"subject_name\")), ...     predicate=Field(\"relation\"), ...     object=Field(\"target\"), ... ) validate_query_for_schema(schema, \"find\", subject_type=\"Person\")  # OK - nested field</p>"},{"location":"api/compose/validation/#infer_bundle_schema","title":"infer_bundle_schema","text":"<p>Automatically infer a Bundle schema from a DataFrame.</p> <pre><code>from hybi.compose import infer_bundle_schema\nimport pandas as pd\n\ndf = pd.DataFrame({\n    \"name\": [\"Alice\", \"Bob\", \"Carol\"],\n    \"age\": [30, 25, 35],\n    \"department\": [\"Engineering\", \"Engineering\", \"Design\"],\n    \"hire_date\": pd.to_datetime([\"2020-01-15\", \"2021-03-20\", \"2019-08-10\"]),\n})\n\nschema = infer_bundle_schema(df)\n\n# Inferred encodings:\n# - name: SEMANTIC (high cardinality string)\n# - age: NUMERIC (numeric type)\n# - department: EXACT (low cardinality - 2 unique values)\n# - hire_date: TEMPORAL (datetime type)\n</code></pre> <p>Inference rules:</p> Column Type Cardinality Inferred Encoding Numeric - <code>NUMERIC</code> Datetime - <code>TEMPORAL</code> Categorical - <code>EXACT</code> Object (string) &lt; 50 unique, &lt; 10% of rows <code>EXACT</code> Object (string) Otherwise <code>SEMANTIC</code>"},{"location":"api/compose/validation/#hybi.compose.infer_bundle_schema","title":"<code>hybi.compose.infer_bundle_schema(df)</code>","text":"<p>Infer a Bundle schema from a DataFrame.</p> <p>Creates a Bundle schema by inferring appropriate encodings based on column types.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame to infer schema from</p> required <p>Returns:</p> Type Description <code>Bundle</code> <p>Bundle schema with inferred field configurations</p> Example <p>schema = infer_bundle_schema(df) print(schema.slots())  # Column names</p>"},{"location":"api/compose/validation/#collect_validation_errors","title":"collect_validation_errors","text":"<p>Convenience function that returns None if valid, or combined error message.</p> <pre><code>from hybi.compose import collect_validation_errors\n\nerror_message = collect_validation_errors(schema, df)\nif error_message:\n    raise ValueError(f\"Schema validation failed: {error_message}\")\n</code></pre>"},{"location":"api/compose/validation/#hybi.compose.collect_validation_errors","title":"<code>hybi.compose.collect_validation_errors(schema, df)</code>","text":"<p>Validate schema and return error message if invalid.</p> <p>Convenience function that returns None if valid, or a combined error message if validation fails.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>BaseMolecule</code> <p>Schema to validate</p> required <code>df</code> <code>DataFrame</code> <p>DataFrame to validate against</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>None if valid, error message string if invalid</p>"},{"location":"api/compose/validation/#error-handling","title":"Error Handling","text":"<p>Validation functions return <code>ValidationResult</code> objects rather than raising exceptions, allowing you to collect all errors before deciding how to handle them.</p> <pre><code>errors = validate_schema_against_dataframe(schema, df)\n\n# Separate errors and warnings\ncritical = [e for e in errors if e.is_error]\nwarnings = [e for e in errors if e.is_warning]\n\nif critical:\n    # Handle blocking errors\n    for e in critical:\n        print(f\"ERROR: {e.field} - {e.message}\")\n    raise ValueError(\"Validation failed\")\n\nif warnings:\n    # Log warnings but proceed\n    for w in warnings:\n        print(f\"WARNING: {w.field} - {w.message}\")\n</code></pre> <p>For validation errors raised as exceptions, see:</p> <ul> <li>SchemaError - Query operation not supported</li> <li>SlotError - Invalid field name</li> <li>FieldValidationError - Field validation failed</li> </ul>"},{"location":"api/compose/validation/#best-practices","title":"Best Practices","text":""},{"location":"api/compose/validation/#1-validate-early","title":"1. Validate Early","text":"<p>Validate schemas against sample data before ingesting large datasets:</p> <pre><code># Validate with small sample first\nsample = df.head(1000)\nerrors = validate_schema_against_dataframe(schema, sample)\nif errors:\n    raise ValueError(f\"Schema mismatch: {errors}\")\n\n# Then ingest full dataset\nhb.ingest(df, collection=\"data\", schema=schema)\n</code></pre>"},{"location":"api/compose/validation/#2-choose-appropriate-strategy","title":"2. Choose Appropriate Strategy","text":"<pre><code># Development: Use FULL for thoroughness\nconfig = ValidationConfig(strategy=ValidationStrategy.FULL)\n\n# Production with large data: Use SAMPLED\nconfig = ValidationConfig(\n    strategy=ValidationStrategy.SAMPLED,\n    sample_size=10000,  # Larger sample for production\n)\n\n# Quick checks: Use SCHEMA_ONLY\nconfig = ValidationConfig(strategy=ValidationStrategy.SCHEMA_ONLY)\n</code></pre>"},{"location":"api/compose/validation/#3-use-inferred-schemas-as-starting-point","title":"3. Use Inferred Schemas as Starting Point","text":"<pre><code># Start with inferred schema\nschema = infer_bundle_schema(df)\n\n# Then customize as needed\n# (convert to explicit schema definition for production)\n</code></pre>"},{"location":"concepts/","title":"Concepts","text":"<p>Understanding HyperBinder's core concepts will help you use it effectively.</p>"},{"location":"concepts/#key-ideas","title":"Key Ideas","text":""},{"location":"concepts/#neurosymbolic-computing","title":"Neurosymbolic Computing","text":"<p>HyperBinder combines two AI paradigms:</p> <ul> <li>Symbolic AI: Logic, rules, exact matching (like SQL or graph databases)</li> <li>Neural AI: Embeddings, similarity, semantic understanding</li> </ul> <p>Most queries blend both - find similar items, then filter by exact criteria.</p>"},{"location":"concepts/#hyperdimensional-computing-hdc","title":"Hyperdimensional Computing (HDC)","text":"<p>Unlike traditional vector databases that treat embeddings as opaque blobs, HyperBinder uses Hyperdimensional Computing - a compositional encoding system where:</p> <ul> <li>Structured data is encoded preserving relationships</li> <li>Components can be extracted from composed structures</li> <li>Sets can be represented in single vectors</li> <li>Similarity can be measured between structures</li> </ul> <p>This enables queries that decompose structure, not just measure similarity.</p>"},{"location":"concepts/#the-compose-system","title":"The Compose System","text":"<p>HyperBinder's schema system uses a chemistry metaphor:</p> Layer What it is Examples Molecules Composable structures <code>Pair</code>, <code>Triple</code>, <code>Bundle</code> Compounds Domain-specific templates <code>KnowledgeGraph</code>, <code>TimeSeries</code> <p>Users typically define schemas using Molecules or Compounds. </p>"},{"location":"concepts/#topics","title":"Topics","text":"Topic Description The Compose System Deep dive into Molecules and Compounds Molecules vs Compounds When to use each type of schema Embeddings Choosing and configuring embedding models Intersections Connecting collections with cross-collection queries"},{"location":"concepts/compose/","title":"The Compose System","text":"<p>Compose is HyperBinder's schema system that exposes the power of Hyperdimensional Computing (HDC) through a clean, typed API.</p>"},{"location":"concepts/compose/#why-compose","title":"Why Compose?","text":""},{"location":"concepts/compose/#the-problem-with-traditional-vector-dbs","title":"The Problem with Traditional Vector DBs","text":"<p>Traditional vector databases treat embeddings as black boxes:</p> <pre><code>Data \u2192 Embedding \u2192 Similarity Search\n</code></pre> <p>You can ask \"what's similar?\" but you cannot:</p> <ul> <li>Decompose a vector to extract components</li> <li>Query specific structural slots</li> <li>Perform analogical reasoning</li> <li>Traverse relationships semantically</li> </ul>"},{"location":"concepts/compose/#what-hdc-enables","title":"What HDC Enables","text":"<p>Hyperdimensional Computing provides compositional operations on vectors that preserve structural relationships:</p> <ul> <li>Structure encoding: Combine vectors while preserving their relationship</li> <li>Structural decomposition: Extract components from composed structures</li> <li>Set representation: Represent collections of items in a single vector</li> </ul> <p>Key insight: Unlike traditional embeddings, HyperBinder's encoding is compositional. If you encode a triple (Subject, Predicate, Object), you can later decompose it to extract individual components.</p>"},{"location":"concepts/compose/#the-layers","title":"The Layers","text":"<pre><code>flowchart LR\n    subgraph atoms [ATOMS - Advanced]\n        a[\"bind, unbind,&lt;br/&gt;bundle, similarity\"]\n    end\n\n    subgraph molecules [MOLECULES]\n        m[\"Pair, Triple, Bundle,&lt;br/&gt;Sequence, Tree, Graph\"]\n    end\n\n    subgraph compounds [COMPOUNDS]\n        c[\"KnowledgeGraph, TimeSeries,&lt;br/&gt;Hierarchy, Document, Network\"]\n    end\n\n    atoms -.-&gt; molecules --&gt; compounds</code></pre> <p>Atoms are an internal implementation detail, described here for completeness.</p> <p>Atoms (bind, unbind, bundle) are low-level HDC primitives that molecules are built from.</p>"},{"location":"concepts/compose/#molecules-building-blocks","title":"Molecules (Building Blocks)","text":"<p>The core structures you define schemas with. Each molecule defines:</p> <ol> <li>Structure: The shape of your data</li> <li>Slots: Named positions in the structure</li> <li>Queries: What operations are supported</li> </ol> Molecule Slots Best For Pair left, right Key-value, edges Triple subject, predicate, object Knowledge graphs Bundle User-defined fields Tabular data Sequence item Ordered data Tree child, parent Hierarchies Graph source, edge, target Networks <pre><code>from hybi.compose import Triple, Field, Encoding\n\nschema = Triple(\n    subject=Field(\"entity\", encoding=Encoding.SEMANTIC),\n    predicate=Field(\"relation\", encoding=Encoding.EXACT),\n    object=Field(\"target\", encoding=Encoding.SEMANTIC),\n)\n</code></pre>"},{"location":"concepts/compose/#compounds-domain-templates","title":"Compounds (Domain Templates)","text":"<p>Pre-configured molecules optimized for common use cases. They expand to molecules at definition time.</p> Compound Expands To Use Case KnowledgeGraph Triple Entity-relation-entity facts TimeSeries Sequence Time-ordered data Hierarchy Tree Org charts, taxonomies Document Bundle Document chunks with metadata Network Graph Social graphs, citation networks Catalog Bundle Generic tabular data <pre><code>from hybi.compose import KnowledgeGraph\n\n# This is equivalent to defining a Triple with sensible defaults\nschema = KnowledgeGraph(\n    entity_field=\"entity\",\n    relation_field=\"relation\",\n)\n</code></pre>"},{"location":"concepts/compose/#structured-vs-search-optimized-encoding","title":"Structured vs Search-Optimized Encoding","text":"<p>Molecules use different encoding strategies optimized for different use cases:</p>"},{"location":"concepts/compose/#structured-encoding","title":"Structured Encoding","text":"<p>Used by: Pair, Triple, Tree, Graph, Sequence</p> <ul> <li>Fully decomposable: Extract individual components from queries</li> <li>High precision: Exact matches score ~1.0</li> <li>Enables: Slot-specific queries, traversal, structural decomposition</li> </ul>"},{"location":"concepts/compose/#search-optimized-encoding","title":"Search-Optimized Encoding","text":"<p>Used by: Bundle</p> <ul> <li>Multi-field search: Search across many fields simultaneously</li> <li>Similarity-based: Optimized for semantic similarity matching</li> <li>Trade-off: Lower precision for faster multi-field search</li> </ul> <p>Bundle limitations</p> <p>Bundle uses search-optimized encoding, which means:</p> <ul> <li>Individual fields cannot be reliably extracted</li> <li>Bundles cannot be nested inside other molecules</li> <li>Similarity scores decrease with field count</li> </ul>"},{"location":"concepts/compose/#encoding-types","title":"Encoding Types","text":"<p>Fields can have different encoding strategies:</p> Encoding Behavior Use When <code>SEMANTIC</code> Similar values \u2192 similar vectors Names, descriptions, text <code>EXACT</code> Each unique value \u2192 distinct vector IDs, categories, relations <code>NUMERIC</code> Numbers close in value \u2192 similar vectors Prices, counts, ratings <pre><code>Field(\"description\", encoding=Encoding.SEMANTIC)  # Semantic similarity\nField(\"category\", encoding=Encoding.EXACT)        # Exact matching\nField(\"price\", encoding=Encoding.NUMERIC, similar_within=50)  # $50 = similar\n</code></pre>"},{"location":"concepts/compose/#nesting-molecules","title":"Nesting Molecules","text":"<p>Structured molecules can be nested inside each other:</p> <pre><code># Typed entity knowledge graph\nschema = Triple(\n    subject=Pair(\n        left=Field(\"entity_type\", encoding=Encoding.EXACT),\n        right=Field(\"entity_name\"),\n    ),\n    predicate=Field(\"relation\", encoding=Encoding.EXACT),\n    object=Pair(\n        left=Field(\"target_type\", encoding=Encoding.EXACT),\n        right=Field(\"target_name\"),\n    ),\n)\n# Nested structure is fully decomposable!\n</code></pre> <p>Nesting rules</p> <ul> <li>Structured molecules (Pair, Triple, Tree, Graph, Sequence) can nest</li> <li>Bundle cannot be nested (uses search-optimized encoding)</li> <li>Validation happens at construction time</li> </ul>"},{"location":"concepts/compose/#unique-capabilities","title":"Unique Capabilities","text":"<p>These operations are impossible with traditional vector databases:</p>"},{"location":"concepts/compose/#analogical-reasoning","title":"Analogical Reasoning","text":"<p>Find D where A:B :: C:D</p> <pre><code># Einstein:Relativity :: Darwin:?\nresults = hb.analogy(\"Einstein\", \"Relativity\", \"Darwin\",\n                     field_name=\"subject\", collection=\"facts\")\n# Finds \"Evolution\" - the relation Darwin has like Einstein\u2192Relativity\n</code></pre>"},{"location":"concepts/compose/#slot-specific-search","title":"Slot-Specific Search","text":"<p>Search within a single structural slot:</p> <pre><code>q = hb.query(\"facts\", schema=schema)\n\n# Search only in the subject slot\nresults = q.search(\"physicist\", slot=\"subject\")\n\n# Multi-slot with different weights\nresults = q.search_slots({\n    \"subject\": (\"Einstein\", 2.0),  # Double weight\n    \"object\": (\"physics\", 1.0),\n})\n</code></pre>"},{"location":"concepts/compose/#fuzzy-graph-traversal","title":"Fuzzy Graph Traversal","text":"<p>Semantic path following (not just exact matching):</p> <pre><code>results = q.traverse_fuzzy(\n    start=\"Albert Einstein\",\n    start_slot=\"subject\",\n    path=[\"worked_at\", \"located_in\"],\n    hop_threshold=0.6,  # Minimum similarity per hop\n)\n</code></pre>"},{"location":"concepts/compose/#prototype-search","title":"Prototype Search","text":"<p>Find items similar to ANY of multiple examples:</p> <pre><code>results = hb.search_prototype(\n    examples=[\"Dune\", \"Foundation\", \"Neuromancer\"],\n    field_name=\"title\",\n    collection=\"books\"\n)\n</code></pre>"},{"location":"concepts/compose/#intersections-the-glue-layer","title":"Intersections: The Glue Layer","text":"<p>Collections are isolated by default. Intersections declare relationships between collections, enabling cross-collection queries via <code>.join()</code>.</p> <pre><code>flowchart LR\n    E[Employees] &lt;--&gt;|identity| X[Expertise] &lt;--&gt;|identity| P[Projects]</code></pre> <p><code>employees.id = expertise.employee_id</code> \u00b7 <code>expertise.project_id = projects.id</code></p>"},{"location":"concepts/compose/#declaring-intersections","title":"Declaring Intersections","text":"<pre><code># Connect employees to their expertise\nhb.intersect(\"employees.employee_id\", \"expertise.subject\")\n\n# Connect expertise to projects\nhb.intersect(\"expertise.project_id\", \"projects.id\")\n</code></pre>"},{"location":"concepts/compose/#querying-across-collections","title":"Querying Across Collections","text":"<pre><code># Start in employees, join through expertise to projects\nresults = (\n    hb.query(\"employees\")\n    .search(\"senior engineer\")\n    .join(\"expertise\")\n    .join(\"projects\")\n)\n\nfor r in results:\n    print(f\"{r.source['name']} \u2192 {r.target['project_name']}\")\n</code></pre>"},{"location":"concepts/compose/#relation-types","title":"Relation Types","text":"Relation Matching Use Case <code>\"identity\"</code> Exact value equality IDs, foreign keys <code>\"semantic\"</code> Embedding similarity Text content, descriptions <code>\"link\"</code> Explicit value mappings Cross-encoding fields (flexible mode)"},{"location":"concepts/compose/#the-bridge-pattern","title":"The Bridge Pattern","text":"<p>Intersections enable a powerful pattern for connecting heterogeneous data:</p> <pre><code>flowchart LR\n    D[\"Documents&lt;br/&gt;(Fuzzy)\"] &lt;--&gt;|semantic| K[\"Knowledge Graph&lt;br/&gt;(Entity Hub)\"] &lt;--&gt;|identity| T[\"Catalogs&lt;br/&gt;(Exact)\"]</code></pre> <p>The Knowledge Graph acts as a semantic index bridging fuzzy text mentions to exact structured lookups.</p> <p>See Intersections API for full documentation.</p>"},{"location":"concepts/compose/#schema-contract","title":"Schema = Contract","text":"<p>A schema isn't just metadata - it's a contract that determines:</p> <ol> <li>What queries are valid: <code>find(subject=X)</code> only works on Triple</li> <li>How data is encoded: Chain vs bundle, semantic vs exact</li> <li>What results contain: Schema-aware result objects</li> </ol> <p>Invalid queries fail with clear errors:</p> <pre><code>q = hb.query(\"facts\", schema=triple_schema)\nq.children(\"Alice\")  # SchemaError: 'children' requires Tree schema\n</code></pre>"},{"location":"concepts/compose/#next-steps","title":"Next Steps","text":"<ul> <li>Molecules vs Compounds - Choosing the right schema</li> <li>API Reference: Molecules - Full molecule documentation</li> <li>API Reference: Fields - Field configuration options</li> <li>API Reference: Intersections - Cross-collection queries</li> </ul>"},{"location":"concepts/embeddings/","title":"Embedding Models","text":"<p>HyperBinder uses embedding models to encode <code>SEMANTIC</code> fields, that is fields where similar text should produce similar results in search.</p> <p>Any embedding model works. HyperBinder adapts automatically. The default is <code>all-MiniLM-L6-v2</code> (384 dimensions).</p> <p>HyperBinder does NOT store raw embeddings</p> <p>Embeddings are an input to HyperBinder's encoding pipeline. At ingest time, they are transformed into an internal representation, and only that internal representation is stored. At query time, the same transformation runs on the query embedding. Your choice of embedding model affects the quality of this encoding.</p> <p>Same model for ingest and query</p> <p>You must use the same embedding model for both ingest and query. Mixing models will produce meaningless results because the internal representation is calibrated to the model used at ingest time.</p>"},{"location":"concepts/embeddings/#how-embedding-dimensions-work","title":"How Embedding Dimensions Work","text":"<p>HyperBinder's internal representation has a fixed capacity (256 dimensions by default for semantic fields). When your embedding model produces vectors of a different size, HyperBinder adapts automatically:</p> <ul> <li>Smaller embeddings (embed_dim \u2264 internal capacity): No fidelity loss. HyperBinder interpolates to fill the representation.</li> <li>Larger embeddings (embed_dim &gt; internal capacity): Some compression occurs. HyperBinder auto-detects your model's characteristics and uses the best strategy, but information is necessarily lost.</li> </ul> <p>The compression ratio (<code>embed_dim / internal_dim</code>) determines how much information is preserved:</p> Compression Ratio Quality Effect \u2264 1.0\u00d7 Lossless No information lost 1\u20132\u00d7 Excellent Semantic ranking well preserved 2\u20134\u00d7 Good Slight degradation in fine-grained ranking 4\u00d7+ Moderate Consider using a lower-dimensional model or pre-truncating (see MRL models)"},{"location":"concepts/embeddings/#recommended-models","title":"Recommended Models","text":"Model Dimensions Compression @256 Quality Notes <code>all-MiniLM-L6-v2</code> 384 1.5\u00d7 Excellent Default, fast, good quality <code>nomic-embed-text-v1.5</code> 768 3\u00d7 Good MRL-trained, compresses well <code>text-embedding-3-small</code> 1536 6\u00d7 Moderate Use MRL truncation to 256 for best results <code>text-embedding-3-large</code> 3072 12\u00d7 Lower Use MRL truncation to 256\u2013768 first <p>Lower-dimensional models often give better end-to-end results because less compression means higher fidelity in HyperBinder's internal representation.</p>"},{"location":"concepts/embeddings/#bringing-your-own-embedding-model","title":"Bringing Your Own Embedding Model","text":"<p>There are two ways to provide embeddings to HyperBinder.</p>"},{"location":"concepts/embeddings/#encode_fn-callback-recommended","title":"<code>encode_fn</code> callback (recommended)","text":"<p>Register a function that maps text to embeddings. HyperBinder calls this automatically for both ingest encoding and query encoding.</p> <pre><code>from sentence_transformers import SentenceTransformer\nfrom hybi import HyperBinder\n\nmodel = SentenceTransformer(\"all-MiniLM-L6-v2\")\n\nhb = HyperBinder(local=True, encode_fn=model.encode)\nhb.ingest(df, collection=\"docs\")\n\n# Queries are automatically encoded using your encode_fn\nresults = hb.search(\"machine learning\", collection=\"docs\")\n</code></pre> <p>The <code>encode_fn</code> should accept a list of strings and return a numpy array (or list of lists) of embeddings:</p> <pre><code>def my_encode_fn(texts: list[str]) -&gt; np.ndarray:\n    # Your embedding logic here\n    return embeddings  # shape: (len(texts), embed_dim)\n</code></pre>"},{"location":"concepts/embeddings/#vector_col-parameter","title":"<code>vector_col</code> parameter","text":"<p>For pipelines that pre-compute embeddings externally, pass a column name containing embedding vectors at ingest time:</p> <pre><code>import pandas as pd\n\n# DataFrame with pre-computed embeddings\ndf = pd.DataFrame({\n    \"text\": [\"doc one\", \"doc two\"],\n    \"my_embeddings\": [embedding_1, embedding_2],  # list[float] per row\n})\n\nhb.ingest(df, collection=\"docs\", vector_col=\"my_embeddings\")\n</code></pre> <p>Note</p> <p>With <code>vector_col</code>, you are responsible for encoding query vectors yourself. The <code>encode_fn</code> approach handles this automatically and is preferred for most use cases.</p>"},{"location":"concepts/embeddings/#mrl-matryoshka-models","title":"MRL (Matryoshka) Models","text":"<p>Some embedding models are trained with Matryoshka Representation Learning (MRL), which means you can safely truncate their output to shorter dimensions without retraining. The first N dimensions of an MRL-trained model contain a valid, lower-dimensional embedding.</p> <p>HyperBinder auto-detects MRL structure \u2014 no configuration is needed.</p> <p>For high-dimensional MRL models, you can pre-truncate embeddings before passing them to HyperBinder. This reduces the compression ratio and preserves more fidelity:</p> <pre><code>from sentence_transformers import SentenceTransformer\nimport numpy as np\n\n# text-embedding-3-small produces 1536-dim vectors\n# but supports MRL truncation\nmodel = SentenceTransformer(\"text-embedding-3-small\")\n\ndef truncated_encode(texts, target_dim=256):\n    embeddings = model.encode(texts)\n    truncated = embeddings[:, :target_dim]\n    # Re-normalize after truncation\n    norms = np.linalg.norm(truncated, axis=1, keepdims=True)\n    return truncated / norms\n\nhb = HyperBinder(local=True, encode_fn=truncated_encode)\n# Now compression ratio is 256/256 = 1.0\u00d7 (lossless)\n</code></pre> <p>Not all models support MRL truncation. Check your model's documentation before truncating. Models that support it include:</p> <ul> <li>OpenAI <code>text-embedding-3-small</code> and <code>text-embedding-3-large</code></li> <li><code>nomic-embed-text-v1.5</code></li> <li>Any model explicitly documented as MRL-trained</li> </ul> <p>Encoding quality over time</p> <p>HyperBinder's encoding quality improves as it sees more data. The first few rows use a general-purpose encoding strategy. After accumulating statistics about your data distribution, the encoding automatically adapts for better fidelity. No action is needed \u2014 this is fully automatic.</p>"},{"location":"concepts/embeddings/#best-practices","title":"Best Practices","text":"<ul> <li>Always use the same embedding model for ingest and query. Switching models invalidates the internal representation.</li> <li>Lower-dimensional models often give better end-to-end results because less compression means higher fidelity.</li> <li>For high-dimensional models, pre-truncate if the model supports MRL. This is the single most effective optimization.</li> <li>Don't mix embedding models within a single collection. Each collection should use one consistent model.</li> </ul>"},{"location":"concepts/intersections/","title":"Intersections","text":"<p>Intersections are the glue that connects collections, enabling cross-collection queries. They enable you to seamlessly pipe queries across collections specialized for different cases such as semantic search, fuzzy matching, and exact lookups, as specified by composition schemas.</p> <p>Intersections allow you to easily create sophisticated logic that would normally require complex custom code across multiple database types. </p>"},{"location":"concepts/intersections/#the-problem","title":"The Problem","text":"<p>By default, collections are isolated islands:</p> <pre><code>flowchart LR\n    E[Employees] ~~~ X[Expertise] ~~~ P[Projects]</code></pre> <p>You can query each independently, but you can't ask questions that span them\u2014like \"What skills does the ML team have?\" or \"Which projects need Python experts?\"</p>"},{"location":"concepts/intersections/#the-solution","title":"The Solution","text":"<p>Intersections declare relationships between collections:</p> <pre><code># Declare: employees.employee_id links to expertise.subject\nhb.intersect(\"employees.employee_id\", \"expertise.subject\")\n</code></pre> <p>Now the collections are connected:</p> <pre><code>flowchart LR\n    E[Employees] &lt;--&gt;|employee_id = subject| X[Expertise]</code></pre> <p>And you can query across them:</p> <pre><code>results = (\n    hb.query(\"employees\")\n    .search(\"ML engineer\")\n    .join(\"expertise\")\n)\n\nfor r in results:\n    print(f\"{r.source['name']} knows {r.target['skill']}\")\n</code></pre>"},{"location":"concepts/intersections/#two-types-of-matching","title":"Two Types of Matching","text":"Relation How it matches Use for <code>identity</code> Exact value equality IDs, foreign keys, categories <code>semantic</code> Embedding similarity Text content, descriptions <pre><code># Identity: exact match on IDs\nhb.intersect(\"orders.customer_id\", \"customers.id\")\n\n# Semantic: fuzzy match on text\nhb.intersect(\"emails.content\", \"projects.description\", relation=\"semantic\")\n</code></pre>"},{"location":"concepts/intersections/#strict-vs-flexible-mode","title":"Strict vs Flexible Mode","text":"<p>By default, intersections use strict mode, which only allows connections between fields of the same encoding type (EXACT\u2194EXACT, SEMANTIC\u2194SEMANTIC).</p> <p>Flexible mode enables cross-encoding intersections using explicit links\u2014declared mappings that tell HyperBinder exactly which values correspond.</p> Mode Allowed Pairs Use When <code>STRICT</code> (default) Same encoding types Fields share natural equality <code>FLEXIBLE</code> Any encoding types Need explicit value mappings"},{"location":"concepts/intersections/#when-to-use-flexible-mode","title":"When to Use Flexible Mode","text":"<p>Flexible mode solves the cross-encoding problem:</p> <pre><code># Problem: EXACT employee IDs don't match SEMANTIC topic descriptions\nemployees.employee_id = \"EMP001\"       # EXACT encoding\nexpertise.topic = \"machine learning\"   # SEMANTIC encoding\n\n# \"EMP001\" and \"machine learning\" are semantically unrelated,\n# but we need to connect them for queries!\n</code></pre> <p>The solution: Explicitly declare which values link together.</p> <pre><code># 1. Declare flexible intersection\nix = hb.intersect_flexible(\"employees.employee_id\", \"expertise.topic\")\n\n# 2. Provide the link mappings\nlinks_df = pd.DataFrame({\n    \"emp_id\": [\"EMP001\", \"EMP002\", \"EMP003\"],\n    \"topic\": [\"machine learning\", \"databases\", \"cloud computing\"]\n})\nhb.populate_links(ix, links_df, \"emp_id\", \"topic\")\n\n# 3. Now cross-type joins work!\nresults = hb.query(\"employees\").filter(employee_id=\"EMP001\").join(\"expertise\")\n# Returns: EMP001 \u2192 machine learning\n</code></pre>"},{"location":"concepts/intersections/#links-as-first-class-citizens","title":"Links as First-Class Citizens","text":"<p>Links are bidirectional by default\u2014you can join in either direction:</p> <pre><code># Forward: employees \u2192 expertise\nresults = hb.query(\"employees\").search(\"Alice\").join(\"expertise\")\n\n# Reverse: expertise \u2192 employees\nresults = hb.query(\"expertise\").search(\"machine learning\").join(\"employees\")\n</code></pre> <p>See Intersections API for full reference on <code>Link</code>, <code>LinkSet</code>, and <code>populate_links()</code>.</p>"},{"location":"concepts/intersections/#chaining-joins","title":"Chaining Joins","text":"<p>Connect multiple collections in one query:</p> <pre><code>results = (\n    hb.query(\"employees\")\n    .search(\"senior engineer\")\n    .join(\"expertise\")      # employees \u2192 expertise\n    .join(\"projects\")       # expertise \u2192 projects\n    .join(\"budgets\")        # projects \u2192 budgets\n)\n</code></pre> <pre><code>flowchart LR\n    E[Employees] --&gt; X[Expertise] --&gt; P[Projects] --&gt; B[Budgets]</code></pre>"},{"location":"concepts/intersections/#the-bridge-pattern","title":"The Bridge Pattern","text":"<p>A powerful architecture for connecting heterogeneous data:</p> <pre><code>flowchart LR\n    D[\"Documents&lt;br/&gt;(fuzzy text)\"] &lt;--&gt;|semantic| K[\"Knowledge Graph&lt;br/&gt;(entities)\"] &lt;--&gt;|identity| T[\"Tables&lt;br/&gt;(exact data)\"]</code></pre> <p>The Knowledge Graph acts as an index\u2014semantic search finds relevant entities, which link to exact structured records.</p> <p>Example: Find budget info for projects mentioned in emails:</p> <pre><code>hb.intersect(\"emails.content\", \"projects.description\", relation=\"semantic\")\nhb.intersect(\"projects.project_id\", \"budgets.project_id\", relation=\"identity\")\n\nresults = (\n    hb.query(\"emails\")\n    .search(\"Q2 budget concerns\")\n    .join(\"projects\")   # semantic: email text \u2192 project\n    .join(\"budgets\")    # identity: project ID \u2192 budget\n)\n</code></pre>"},{"location":"concepts/intersections/#match-quality","title":"Match Quality","text":"<p>Each joined result has a status:</p> Status Meaning <code>MATCHED</code> Confident match found <code>NULL</code> Ambiguous (multiple close candidates) <code>NO_MATCH</code> No match above threshold <pre><code>for r in results:\n    if r.is_matched:\n        # Safe to use r.target\n        print(f\"{r.source['name']} \u2192 {r.target['skill']}\")\n    elif r.is_no_match:\n        print(f\"{r.source['name']} has no matching expertise\")\n</code></pre>"},{"location":"concepts/intersections/#when-to-use-intersections","title":"When to Use Intersections","text":"<p>Use intersections when:</p> <ul> <li>Data naturally lives in separate collections (different schemas)</li> <li>You need to answer questions spanning multiple data types</li> <li>You want to connect fuzzy (semantic) and exact (symbolic) data</li> </ul> <p>Don't use intersections when:</p> <ul> <li>All data fits in one collection</li> <li>Relationships are within the same collection (use multihop instead)</li> </ul>"},{"location":"concepts/intersections/#next-steps","title":"Next Steps","text":"<ul> <li>Intersections API - Full reference</li> <li>Intersections Tutorial - Step-by-step guide</li> <li>Enterprise Knowledge Example - Complex multi-collection patterns</li> </ul>"},{"location":"concepts/molecules-vs-compounds/","title":"Molecules vs Compounds","text":"<p>Both molecules and compounds define schemas, but they serve different purposes. You can think of these elements as the \"building blocks\" for composing your knowledge layer.</p> <p>HyperBinder comes with several prebuilt molecules and compounds for common use cases, and we plan to add more in future releases.</p>"},{"location":"concepts/molecules-vs-compounds/#quick-comparison","title":"Quick Comparison","text":"Aspect Molecules Compounds What they are Core building blocks Convenience wrappers Flexibility Full control over slots Pre-configured defaults When to use Custom structures Common patterns Examples Pair, Triple, Bundle KnowledgeGraph, Catalog"},{"location":"concepts/molecules-vs-compounds/#molecules-full-control","title":"Molecules: Full Control","text":"<p>Molecules give you complete control over structure:</p> <pre><code>from hybi.compose import Triple, Field, Encoding\n\n# You define every slot\nschema = Triple(\n    subject=Field(\"entity\", encoding=Encoding.SEMANTIC),\n    predicate=Field(\"relation\", encoding=Encoding.EXACT),\n    object=Field(\"target\", encoding=Encoding.SEMANTIC, weight=1.5),\n)\n</code></pre> <p>Use molecules when:</p> <ul> <li>You need custom field names</li> <li>You want specific encoding per field</li> <li>You're nesting structures</li> <li>You need fine-grained control</li> </ul>"},{"location":"concepts/molecules-vs-compounds/#available-molecules","title":"Available Molecules","text":"Molecule Slots Best For Pair <code>left</code>, <code>right</code> Key-value, edges Triple <code>subject</code>, <code>predicate</code>, <code>object</code> Knowledge graphs Bundle User-defined Tabular data Sequence <code>item</code> Ordered data Tree <code>child</code>, <code>parent</code> Hierarchies Graph <code>source</code>, <code>edge</code>, <code>target</code> Networks"},{"location":"concepts/molecules-vs-compounds/#compounds-quick-setup","title":"Compounds: Quick Setup","text":"<p>Compounds are pre-configured molecules for common domains:</p> <pre><code>from hybi.compose import KnowledgeGraph\n\n# Sensible defaults, less code\nschema = KnowledgeGraph(\n    entity_field=\"entity\",\n    relation_field=\"relation\",\n)\n</code></pre> <p>Use compounds when:</p> <ul> <li>Your data fits a common pattern</li> <li>You want sensible defaults</li> <li>You're prototyping quickly</li> <li>You don't need custom encodings</li> </ul>"},{"location":"concepts/molecules-vs-compounds/#available-compounds","title":"Available Compounds","text":"Compound Based On Default Fields KnowledgeGraph Triple entity, relation, target Catalog Bundle User-specified TimeSeries Sequence timestamp, value Hierarchy Tree node, parent Document Bundle content, metadata Network Graph source, target, edge"},{"location":"concepts/molecules-vs-compounds/#side-by-side-examples","title":"Side-by-Side Examples","text":""},{"location":"concepts/molecules-vs-compounds/#knowledge-graph","title":"Knowledge Graph","text":"Using Triple (Molecule)Using KnowledgeGraph (Compound) <pre><code>from hybi.compose import Triple, Field, Encoding\n\nschema = Triple(\n    subject=Field(\"person\", encoding=Encoding.SEMANTIC),\n    predicate=Field(\"relation\", encoding=Encoding.EXACT),\n    object=Field(\"organization\", encoding=Encoding.SEMANTIC),\n)\n</code></pre> <pre><code>from hybi.compose import KnowledgeGraph\n\nschema = KnowledgeGraph(\n    entity_field=\"person\",\n    relation_field=\"relation\",\n    # Uses SEMANTIC for entities, EXACT for relations by default\n)\n</code></pre>"},{"location":"concepts/molecules-vs-compounds/#tabular-data","title":"Tabular Data","text":"Using Bundle (Molecule)Using Catalog (Compound) <pre><code>from hybi.compose import Bundle, Field, Encoding\n\nschema = Bundle(\n    fields={\n        \"name\": Field(encoding=Encoding.SEMANTIC, weight=1.5),\n        \"category\": Field(encoding=Encoding.EXACT),\n        \"price\": Field(encoding=Encoding.NUMERIC, similar_within=50),\n    }\n)\n</code></pre> <pre><code>from hybi.compose import Catalog, Field, Encoding\n\nschema = Catalog(\n    columns={\n        \"name\": Field(encoding=Encoding.SEMANTIC, weight=1.5),\n        \"category\": Field(encoding=Encoding.EXACT),\n        \"price\": Field(encoding=Encoding.NUMERIC, similar_within=50),\n    }\n)\n</code></pre>"},{"location":"concepts/molecules-vs-compounds/#organizational-hierarchy","title":"Organizational Hierarchy","text":"Using Tree (Molecule)Using Hierarchy (Compound) <pre><code>from hybi.compose import Tree, Field\n\nschema = Tree(\n    child=Field(\"employee\"),\n    parent=Field(\"manager\"),\n)\n</code></pre> <pre><code>from hybi.compose import Hierarchy\n\nschema = Hierarchy(\n    node_field=\"employee\",\n    parent_field=\"manager\",\n)\n</code></pre>"},{"location":"concepts/molecules-vs-compounds/#when-compounds-arent-enough","title":"When Compounds Aren't Enough","text":"<p>Use molecules directly when you need:</p>"},{"location":"concepts/molecules-vs-compounds/#custom-encodings-per-slot","title":"Custom Encodings Per Slot","text":"<pre><code># Compounds use defaults; molecules let you customize each slot\nTriple(\n    subject=Field(\"entity\", encoding=Encoding.SEMANTIC),\n    predicate=Field(\"type\", encoding=Encoding.EXACT),  # Exact match for types\n    object=Field(\"value\", encoding=Encoding.NUMERIC),  # Numeric for values\n)\n</code></pre>"},{"location":"concepts/molecules-vs-compounds/#nested-structures","title":"Nested Structures","text":"<pre><code># Compounds don't support nesting; molecules do\nTriple(\n    subject=Pair(\n        left=Field(\"entity_type\", encoding=Encoding.EXACT),\n        right=Field(\"entity_name\"),\n    ),\n    predicate=Field(\"relation\"),\n    object=Field(\"target\"),\n)\n</code></pre>"},{"location":"concepts/molecules-vs-compounds/#field-weights","title":"Field Weights","text":"<pre><code># Fine-grained relevance control\nBundle(\n    fields={\n        \"title\": Field(encoding=Encoding.SEMANTIC, weight=2.0),  # 2x importance\n        \"description\": Field(encoding=Encoding.SEMANTIC, weight=1.0),\n        \"category\": Field(encoding=Encoding.EXACT, weight=0.5),  # Half weight\n    }\n)\n</code></pre>"},{"location":"concepts/molecules-vs-compounds/#decision-guide","title":"Decision Guide","text":"<pre><code>flowchart LR\n    Q1{Custom encodings?} --&gt;|Yes| M[Molecule]\n    Q1 --&gt;|No| Q2{Common pattern?}\n    Q2 --&gt;|No| M\n    Q2 --&gt;|Yes| C[Compound]</code></pre> If your data is... Use Knowledge facts (entity-relation-entity) <code>KnowledgeGraph</code> Time-ordered events <code>TimeSeries</code> Parent-child relationships <code>Hierarchy</code> Node-edge networks <code>Network</code> Documents with metadata <code>Document</code> Generic tabular <code>Catalog</code>"},{"location":"concepts/molecules-vs-compounds/#summary","title":"Summary","text":"<ul> <li>Start with compounds for common patterns</li> <li>Switch to molecules when you need more control</li> <li>Compounds expand to molecules internally - same capabilities once defined</li> <li>Both produce schema-aware queries with the same <code>ComposeQuery</code> interface</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Complete, runnable examples demonstrating HyperBinder's capabilities.</p>"},{"location":"examples/#where-to-start","title":"Where to Start","text":"Example Best For Concepts Covered Unified Intelligence Unique capabilities Fuzzy-to-exact traversal, cross-encoding joins, multi-hop chains Fictional Universes First-time users Nested molecules, cross-domain analogies, typed entities E-Commerce Platform Practical applications Multi-collection, hierarchies, recommendations Enterprise Knowledge Production patterns 6 collection types, HDC queries, knowledge graphs Intersections Tutorial Understanding joins Step-by-step cross-collection mechanics, cross-encoding links Fuzzy-to-Exact Bridge Search + CRUD Catalog/RelationalTable separation, safe mutations"},{"location":"examples/#unified-intelligence-demo","title":"Unified Intelligence Demo","text":"<p>The power showcase. See what makes HyperBinder unique: seamless traversal across semantic and exact data in a single query chain.</p> <pre><code># Traditional approach: 200+ lines across 3+ systems\n# HyperBinder approach: ~10 lines, one system\n\nresults = (\n    hb.query(\"employees\")\n    .search(\"machine learning expert\")     # SEMANTIC: fuzzy bio search\n    .filter(department=\"Engineering\")      # EXACT: department filter\n    .join(\"expertise\")                     # CROSS-ENCODING: ID \u2192 topic\n    .join(\"projects\")                      # SEMANTIC: topic \u2192 focus area\n    .join(\"budgets\")                       # EXACT: project_id match\n)\n\n# Traversed: Fuzzy \u2192 Exact \u2192 Cross-Encoding \u2192 Semantic \u2192 Exact\n# All in one declarative query!\n</code></pre> <p>View full example \u2192</p>"},{"location":"examples/#fictional-universes","title":"Fictional Universes","text":"<p>The fun introduction. Model characters from Marvel, DC, Star Wars, Lord of the Rings, and Harry Potter using nested molecule composition.</p> <pre><code># Characters as typed entities: (Universe, Name)\nschema = Triple(\n    subject=Pair(\n        left=Field(\"universe\", encoding=Encoding.EXACT),\n        right=Field(\"name\", encoding=Encoding.SEMANTIC),\n    ),\n    predicate=Field(\"relation\", encoding=Encoding.EXACT),\n    object=Pair(...)\n)\n\n# Cross-universe analogy: Luke:Yoda :: Harry:?\nresults = hb.analogy(\"Luke Skywalker\", \"Yoda\", \"Harry Potter\", ...)\n# \u2192 Dumbledore (wise mentor archetype)\n</code></pre> <p>View full example \u2192</p>"},{"location":"examples/#e-commerce-platform","title":"E-Commerce Platform","text":"<p>The practical example. Build a complete e-commerce knowledge system with products, categories, purchases, and recommendations.</p> <pre><code># Four interconnected collections\nproduct_schema = Document(content_field=\"description\", ...)\ncategory_schema = Hierarchy(node_field=\"category\", parent_field=\"parent\")\npurchase_schema = Document(content_field=\"product_id\", ...)\nrecommendation_schema = Network(source_field=\"source\", target_field=\"target\")\n\n# Cross-collection query: Products in \"Computers\" and subcategories\ndescendants = categories.query(schema).descendants(node=\"Computers\")\nfor cat in descendants:\n    products = products.query(schema).filter(where=[(\"category\", \"==\", cat)])\n</code></pre> <p>View full example \u2192</p>"},{"location":"examples/#enterprise-knowledge-management","title":"Enterprise Knowledge Management","text":"<p>The comprehensive example. Model an entire enterprise with employees, organization hierarchy, expertise graphs, projects, documents, and collaboration networks.</p> <pre><code># Six compound types working together\nemployees = Catalog(columns={...})\norganization = Hierarchy(node_field=\"department\", ...)\nexpertise = KnowledgeGraph(entity_field=\"subject\", ...)\nprojects = Catalog(columns={...})\ndocuments = Document(content_field=\"content\", ...)\ncollaboration = Network(source_field=\"source\", ...)\n\n# HDC-specific: Analogical reasoning\n# \"Alice is our ML expert in Data Science. Who plays a similar role in Platform?\"\nresults = hb.analogy(\"Alice Zhang\", \"Data Science\", \"Platform\", ...)\n</code></pre> <p>View full example \u2192</p>"},{"location":"examples/#intersections-tutorial","title":"Intersections Tutorial","text":"<p>The mechanics deep-dive. Understand exactly how cross-collection joins work, step by step. Includes cross-encoding joins using flexible mode.</p> <pre><code># Strict mode: same-encoding fields\nhb.intersect(\"employees.employee_id\", \"expertise.subject\")\n\n# Flexible mode: cross-encoding fields (EXACT \u2194 SEMANTIC)\nix = hb.intersect_flexible(\"employees.employee_id\", \"expertise.topic\")\nhb.populate_links(ix, links_df, \"emp_id\", \"topic\")\n\n# Join works for both modes\nfor result in hb.query(\"employees\").search(\"...\").join(\"expertise\"):\n    if result.is_matched:\n        print(f\"{result.source['name']} \u2192 {result.target['skill']}\")\n</code></pre> <p>View full example \u2192</p>"},{"location":"examples/#fuzzy-to-exact-bridge","title":"Fuzzy-to-Exact Bridge","text":"<p>The pattern for combining search and CRUD. Learn how to bridge semantic discovery with deterministic mutations using Catalog and RelationalTable together.</p> <pre><code># Dual-schema architecture\nsearch_schema = Catalog(fields={...})        # Optimized for search\ncrud_schema = RelationalTable(columns={...}) # Optimized for CRUD\n\n# Bridge pattern: fuzzy discovery \u2192 exact mutations\ncandidates = hb.query(\"users_search\", search_schema).search(\"ML expert\")\nfor r in candidates:\n    if r.data[\"department\"] == \"Engineering\":  # Exact filter\n        pk = r.data[\"user_id\"]\n        hb.update(\"users\", where={\"user_id\": pk}, set={...}, schema=crud_schema)\n</code></pre> <p>View full example \u2192</p>"},{"location":"examples/#running-the-examples","title":"Running the Examples","text":"<p>Examples can run in either client mode (with server) or local mode (embedded):</p>"},{"location":"examples/#client-mode-with-server","title":"Client Mode (with server)","text":"<pre><code># Install the SDK\npip install hybi\n\n# Start the server (see server documentation)\nhyperbinder serve\n\n# Run an example\npython examples/compose/fictional_universe_demo.py\n</code></pre>"},{"location":"examples/#local-mode-embedded-no-docker","title":"Local Mode (embedded, no Docker)","text":"<pre><code># Install SDK with local support\npip install hybi hre\n\n# Examples will detect local mode if server is unavailable\n# Or modify examples to use: hb = HyperBinder(local=True)\npython examples/compose/fictional_universe_demo.py\n</code></pre> <p>The examples are also available in the SDK repository under <code>examples/compose/</code>.</p>"},{"location":"examples/ecommerce/","title":"E-Commerce Platform","text":"<p>A practical example building a complete e-commerce knowledge system with multiple interconnected collections.</p> <p>What you'll learn:</p> <ul> <li>Multiple compound types working together</li> <li>Hierarchy traversal for category trees</li> <li>Network graphs for recommendations</li> <li>Cross-collection queries</li> </ul>"},{"location":"examples/ecommerce/#architecture","title":"Architecture","text":"<pre><code>flowchart LR\n    P[\"Products&lt;br/&gt;(Document)\"] --&gt; C[\"Categories&lt;br/&gt;(Hierarchy)\"]\n    P --&gt; PU[\"Purchases&lt;br/&gt;(Document)\"]\n    P &lt;--&gt; R[\"Recommendations&lt;br/&gt;(Network)\"]</code></pre> <p>Four collections, each optimized for its data shape:</p> Collection Compound Purpose Products Document Catalog with semantic descriptions Categories Hierarchy Category tree with parent-child Purchases Document User purchase history Recommendations Network Product relationships"},{"location":"examples/ecommerce/#the-data","title":"The Data","text":""},{"location":"examples/ecommerce/#products","title":"Products","text":"<pre><code>products = pd.DataFrame([\n    {\"product_id\": \"LAP001\", \"name\": \"ProBook 15\",\n     \"description\": \"15-inch professional laptop with Intel i7, 16GB RAM\",\n     \"category\": \"Laptops\", \"price\": 1299.99, \"stock\": 45},\n    {\"product_id\": \"LAP002\", \"name\": \"UltraSlim Air\",\n     \"description\": \"Ultra-thin 13-inch laptop, all-day battery\",\n     \"category\": \"Laptops\", \"price\": 1499.99, \"stock\": 30},\n    {\"product_id\": \"PHN001\", \"name\": \"Galaxy Ultra\",\n     \"description\": \"Flagship smartphone with 200MP camera\",\n     \"category\": \"Phones\", \"price\": 1199.99, \"stock\": 100},\n    {\"product_id\": \"ACC001\", \"name\": \"Wireless Earbuds Pro\",\n     \"description\": \"Active noise cancellation, premium sound\",\n     \"category\": \"Accessories\", \"price\": 249.99, \"stock\": 200},\n    # ... more products\n])\n</code></pre>"},{"location":"examples/ecommerce/#category-hierarchy","title":"Category Hierarchy","text":"<pre><code>categories = pd.DataFrame([\n    {\"category\": \"Electronics\", \"parent\": None, \"level\": 0},\n    {\"category\": \"Computers\", \"parent\": \"Electronics\", \"level\": 1},\n    {\"category\": \"Mobile\", \"parent\": \"Electronics\", \"level\": 1},\n    {\"category\": \"Laptops\", \"parent\": \"Computers\", \"level\": 2},\n    {\"category\": \"Tablets\", \"parent\": \"Computers\", \"level\": 2},\n    {\"category\": \"Phones\", \"parent\": \"Mobile\", \"level\": 2},\n    {\"category\": \"Wearables\", \"parent\": \"Mobile\", \"level\": 2},\n    {\"category\": \"Accessories\", \"parent\": \"Electronics\", \"level\": 1},\n])\n</code></pre>"},{"location":"examples/ecommerce/#recommendations-network","title":"Recommendations Network","text":"<pre><code>recommendations = pd.DataFrame([\n    (\"LAP001\", \"bought_together\", \"ACC002\"),  # Laptop + USB Hub\n    (\"LAP001\", \"bought_together\", \"ACC003\"),  # Laptop + Stand\n    (\"PHN001\", \"bought_together\", \"ACC004\"),  # Phone + Charger\n    (\"LAP001\", \"also_viewed\", \"LAP002\"),      # Similar laptops\n    (\"LAP003\", \"upgrade_from\", \"LAP001\"),     # Upgrade path\n], columns=[\"source\", \"relation\", \"target\"])\n</code></pre>"},{"location":"examples/ecommerce/#schema-definitions","title":"Schema Definitions","text":"<pre><code>from hybi.compose import Document, Hierarchy, Network, Field, Encoding\n\n# Products: semantic search on descriptions\nproduct_schema = Document(\n    content_field=\"description\",\n    content_encoding=Encoding.SEMANTIC,\n    content_weight=2.0,\n    metadata_fields={\n        \"product_id\": Field(encoding=Encoding.EXACT),\n        \"name\": Field(encoding=Encoding.SEMANTIC, weight=1.5),\n        \"category\": Field(encoding=Encoding.EXACT),\n        \"price\": Field(encoding=Encoding.NUMERIC),\n        \"stock\": Field(encoding=Encoding.NUMERIC),\n    },\n)\n\n# Categories: tree structure\ncategory_schema = Hierarchy(\n    node_field=\"category\",\n    parent_field=\"parent\",\n    level_field=\"level\",\n    node_encoding=Encoding.EXACT,\n)\n\n# Recommendations: product graph\nrecommendation_schema = Network(\n    node_field=\"source\",\n    edge_field=\"relation\",\n    source_field=\"source\",\n    target_field=\"target\",\n    node_encoding=Encoding.EXACT,\n    edge_encoding=Encoding.EXACT,\n)\n</code></pre>"},{"location":"examples/ecommerce/#ingesting-the-data","title":"Ingesting the Data","text":"<pre><code>from hybi import HyperBinder\n\nhb = HyperBinder(\"http://localhost:8000\")\n\nhb.ingest(products, collection=\"ecom_products\", schema=product_schema)\nhb.ingest(categories, collection=\"ecom_categories\", schema=category_schema)\nhb.ingest(recommendations, collection=\"ecom_recommendations\", schema=recommendation_schema)\n</code></pre>"},{"location":"examples/ecommerce/#cross-collection-queries","title":"Cross-Collection Queries","text":""},{"location":"examples/ecommerce/#1-products-in-a-category-and-subcategories","title":"1. Products in a Category and Subcategories","text":"<p>Find all products in \"Computers\" including Laptops and Tablets:</p> <pre><code>products_coll = hb.collection(\"ecom_products\")\ncategories_coll = hb.collection(\"ecom_categories\")\n\n# Get all descendant categories\ndescendants = categories_coll.query(category_schema).descendants(\n    node=\"Computers\", top_k=20\n)\nsubcategories = [\"Computers\"] + [r[\"category\"] for r in descendants]\n# \u2192 [\"Computers\", \"Laptops\", \"Tablets\"]\n\n# Find products in those categories\nfor cat in subcategories:\n    cat_products = products_coll.query(product_schema).filter(\n        where=[(\"category\", \"==\", cat)], top_k=10\n    )\n    for p in cat_products:\n        print(f\"[{cat}] {p['name']}: ${p['price']}\")\n</code></pre> <p>Output: <pre><code>[Laptops] ProBook 15: $1299.99\n[Laptops] UltraSlim Air: $1499.99\n[Laptops] GamerX Pro: $1899.99\n[Tablets] iPad Pro 12.9: $1099.99\n[Tablets] Galaxy Tab S9: $849.99\n</code></pre></p>"},{"location":"examples/ecommerce/#2-product-recommendations","title":"2. Product Recommendations","text":"<p>Get \"frequently bought together\" recommendations:</p> <pre><code>recommendations_coll = hb.collection(\"ecom_recommendations\")\n\n# What do people buy with ProBook 15?\nbought_together = recommendations_coll.query(recommendation_schema).find(\n    source=\"LAP001\", edge=\"bought_together\", top_k=10\n)\n\nfor rec in bought_together:\n    target_id = rec[\"target\"]\n\n    # Look up product details\n    product = products_coll.query(product_schema).filter(\n        where=[(\"product_id\", \"==\", target_id)], top_k=1\n    )\n    for p in product:\n        print(f\"+ {p['name']} (${p['price']})\")\n</code></pre> <p>Output: <pre><code>+ USB-C Hub ($79.99)\n+ Laptop Stand ($49.99)\n</code></pre></p>"},{"location":"examples/ecommerce/#3-upgrade-paths","title":"3. Upgrade Paths","text":"<p>Find upgrade recommendations:</p> <pre><code>upgrades = recommendations_coll.query(recommendation_schema).find(\n    edge=\"upgrade_from\", top_k=10\n)\n\nfor rec in upgrades:\n    # Get both products\n    source = list(products_coll.query(product_schema).filter(\n        where=[(\"product_id\", \"==\", rec[\"source\"])], top_k=1\n    ))[0]\n    target = list(products_coll.query(product_schema).filter(\n        where=[(\"product_id\", \"==\", rec[\"target\"])], top_k=1\n    ))[0]\n\n    price_diff = float(source[\"price\"]) - float(target[\"price\"])\n    print(f\"{target['name']} \u2192 {source['name']} (+${price_diff:.2f})\")\n</code></pre> <p>Output: <pre><code>ProBook 15 \u2192 GamerX Pro (+$600.00)\nPixel 8 \u2192 iPhone Pro Max (+$600.00)\n</code></pre></p>"},{"location":"examples/ecommerce/#4-category-navigation","title":"4. Category Navigation","text":"<p>Navigate the category tree:</p> <pre><code># Get path to root\nancestors = categories_coll.query(category_schema).ancestors(\n    node=\"Phones\", top_k=10\n)\npath = [a[\"category\"] for a in ancestors]\nprint(f\"Path: {' \u2192 '.join(reversed(path))}\")\n# \u2192 Electronics \u2192 Mobile \u2192 Phones\n\n# Get sibling categories\nsiblings = categories_coll.query(category_schema).siblings(\n    node=\"Phones\", top_k=10\n)\nsibling_names = [s[\"category\"] for s in siblings]\nprint(f\"Siblings: {sibling_names}\")\n# \u2192 [\"Wearables\"]\n</code></pre>"},{"location":"examples/ecommerce/#5-low-stock-alert","title":"5. Low Stock Alert","text":"<p>Find low-stock items in the Mobile category:</p> <pre><code># Get Mobile subcategories\nmobile_descendants = categories_coll.query(category_schema).descendants(\n    node=\"Mobile\", top_k=10\n)\nmobile_cats = [\"Mobile\"] + [r[\"category\"] for r in mobile_descendants]\n\nfor cat in mobile_cats:\n    low_stock = products_coll.query(product_schema).filter(\n        where=[(\"category\", \"==\", cat), (\"stock\", \"&lt;\", 50)],\n        top_k=10\n    )\n    for p in low_stock:\n        print(f\"\u26a0\ufe0f {p['name']}: {p['stock']} units left\")\n</code></pre>"},{"location":"examples/ecommerce/#semantic-product-search","title":"Semantic Product Search","text":"<p>The Document compound enables semantic search on descriptions:</p> <pre><code># Find products matching a natural language query\nresults = products_coll.query(product_schema).search(\n    \"lightweight laptop for travel with long battery\",\n    top_k=5\n)\n\nfor r in results:\n    print(f\"{r['name']} (score: {r.score:.2f})\")\n    print(f\"  {r['description'][:60]}...\")\n</code></pre> <p>Output: <pre><code>UltraSlim Air (score: 0.87)\n  Ultra-thin 13-inch laptop, weighs only 2.5lbs. All-day batt...\nProBook 15 (score: 0.72)\n  15-inch professional laptop with Intel i7, 16GB RAM, 512GB...\n</code></pre></p>"},{"location":"examples/ecommerce/#complete-code","title":"Complete Code","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"E-Commerce Platform Demo\"\"\"\n\nimport pandas as pd\nfrom hybi import HyperBinder\nfrom hybi.compose import Document, Hierarchy, Network, Field, Encoding\n\n\ndef main():\n    # Create data\n    products = pd.DataFrame([\n        {\"product_id\": \"LAP001\", \"name\": \"ProBook 15\",\n         \"description\": \"15-inch professional laptop, Intel i7, 16GB RAM\",\n         \"category\": \"Laptops\", \"price\": 1299.99, \"stock\": 45},\n        {\"product_id\": \"LAP002\", \"name\": \"UltraSlim Air\",\n         \"description\": \"Ultra-thin 13-inch, all-day battery, M2 chip\",\n         \"category\": \"Laptops\", \"price\": 1499.99, \"stock\": 30},\n        {\"product_id\": \"PHN001\", \"name\": \"Galaxy Ultra\",\n         \"description\": \"Flagship smartphone, 200MP camera\",\n         \"category\": \"Phones\", \"price\": 1199.99, \"stock\": 100},\n        {\"product_id\": \"ACC001\", \"name\": \"USB-C Hub\",\n         \"description\": \"7-in-1 hub with HDMI, USB-A, SD card\",\n         \"category\": \"Accessories\", \"price\": 79.99, \"stock\": 150},\n    ])\n\n    categories = pd.DataFrame([\n        {\"category\": \"Electronics\", \"parent\": None, \"level\": 0},\n        {\"category\": \"Computers\", \"parent\": \"Electronics\", \"level\": 1},\n        {\"category\": \"Laptops\", \"parent\": \"Computers\", \"level\": 2},\n        {\"category\": \"Mobile\", \"parent\": \"Electronics\", \"level\": 1},\n        {\"category\": \"Phones\", \"parent\": \"Mobile\", \"level\": 2},\n        {\"category\": \"Accessories\", \"parent\": \"Electronics\", \"level\": 1},\n    ])\n\n    recommendations = pd.DataFrame([\n        (\"LAP001\", \"bought_together\", \"ACC001\"),\n        (\"LAP001\", \"also_viewed\", \"LAP002\"),\n    ], columns=[\"source\", \"relation\", \"target\"])\n\n    # Schemas\n    product_schema = Document(\n        content_field=\"description\",\n        content_encoding=Encoding.SEMANTIC,\n        metadata_fields={\n            \"product_id\": Field(encoding=Encoding.EXACT),\n            \"name\": Field(encoding=Encoding.SEMANTIC),\n            \"category\": Field(encoding=Encoding.EXACT),\n            \"price\": Field(encoding=Encoding.NUMERIC),\n        },\n    )\n\n    category_schema = Hierarchy(\n        node_field=\"category\",\n        parent_field=\"parent\",\n        level_field=\"level\",\n    )\n\n    rec_schema = Network(\n        source_field=\"source\",\n        edge_field=\"relation\",\n        target_field=\"target\",\n    )\n\n    # Ingest\n    hb = HyperBinder(\"http://localhost:8000\")\n    hb.ingest(products, collection=\"ecom_products\", schema=product_schema)\n    hb.ingest(categories, collection=\"ecom_categories\", schema=category_schema)\n    hb.ingest(recommendations, collection=\"ecom_recs\", schema=rec_schema)\n\n    # Query: Semantic search\n    print(\"Semantic search: 'lightweight laptop'\")\n    for r in hb.collection(\"ecom_products\").query(product_schema).search(\n        \"lightweight laptop for travel\", top_k=3\n    ):\n        print(f\"  {r['name']}: ${r['price']}\")\n\n    # Query: Category descendants\n    print(\"\\nProducts in Computers category:\")\n    descendants = hb.collection(\"ecom_categories\").query(category_schema).descendants(\n        node=\"Computers\", top_k=10\n    )\n    for cat in [\"Computers\"] + [d[\"category\"] for d in descendants]:\n        for p in hb.collection(\"ecom_products\").query(product_schema).filter(\n            where=[(\"category\", \"==\", cat)], top_k=5\n        ):\n            print(f\"  [{cat}] {p['name']}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/ecommerce/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Right compound for the job - Document for semantic, Hierarchy for trees, Network for graphs</li> <li>Cross-collection queries - Navigate categories, then find products</li> <li>Semantic search - Natural language queries on product descriptions</li> <li>Graph traversal - Recommendations, upgrades, frequently bought together</li> <li>Tree operations - Ancestors, descendants, siblings for category navigation</li> </ol>"},{"location":"examples/enterprise-knowledge/","title":"Enterprise Knowledge Management","text":"<p>A comprehensive example modeling an entire enterprise with six interconnected collections.</p> <p>What you'll learn:</p> <ul> <li>Multiple compound types orchestrated together</li> <li>HDC-specific capabilities (analogy, bundle search)</li> <li>Knowledge graph traversal</li> <li>Cross-collection intelligence patterns</li> </ul>"},{"location":"examples/enterprise-knowledge/#architecture","title":"Architecture","text":"<pre><code>flowchart TB\n    E[\"Employees&lt;br/&gt;(Catalog)\"] --&gt;|has_skill| S[\"Skills&lt;br/&gt;(KnowledgeGraph)\"]\n    E --&gt;|belongs_to| D[\"Departments&lt;br/&gt;(Hierarchy)\"]\n    S --&gt;|requires| P[\"Projects&lt;br/&gt;(Catalog)\"]\n    P --&gt;|owns| D\n    P --&gt;|produces| DOC[\"Documents&lt;br/&gt;(Document)\"]\n    DOC --&gt;|references| C[\"Collaboration&lt;br/&gt;(Network)\"]</code></pre>"},{"location":"examples/enterprise-knowledge/#the-six-collections","title":"The Six Collections","text":"Collection Compound Purpose Employees Catalog Employee records with semantic bios Organization Hierarchy Department tree structure Expertise KnowledgeGraph Skills, certifications, requirements Projects Catalog Project portfolio with metadata Documents Document Policies, guides, procedures Collaboration Network Reporting and working relationships"},{"location":"examples/enterprise-knowledge/#schema-definitions","title":"Schema Definitions","text":"<pre><code>from hybi.compose import (\n    Catalog, Hierarchy, KnowledgeGraph, Document, Network,\n    Field, Encoding\n)\n\n# Employees: structured catalog with semantic bio\nemployees_schema = Catalog(\n    columns={\n        \"employee_id\": Field(encoding=Encoding.EXACT),\n        \"name\": Field(encoding=Encoding.SEMANTIC),\n        \"title\": Field(encoding=Encoding.SEMANTIC),\n        \"department\": Field(encoding=Encoding.EXACT),\n        \"location\": Field(encoding=Encoding.EXACT),\n        \"bio\": Field(encoding=Encoding.SEMANTIC, weight=2.0),\n    },\n    primary_key=\"employee_id\",\n)\n\n# Organization: department hierarchy\norg_schema = Hierarchy(\n    node_field=\"department\",\n    parent_field=\"parent\",\n    level_field=\"level\",\n    node_encoding=Encoding.EXACT,\n)\n\n# Expertise: knowledge graph of skills\nexpertise_schema = KnowledgeGraph(\n    entity_field=\"subject\",\n    relation_field=\"relation\",\n    subject_field=\"subject\",\n    object_field=\"object\",\n    entity_encoding=Encoding.SEMANTIC,  # Fuzzy skill matching\n    relation_encoding=Encoding.EXACT,   # Precise relation types\n)\n\n# Projects: project portfolio\nprojects_schema = Catalog(\n    columns={\n        \"project_id\": Field(encoding=Encoding.EXACT),\n        \"name\": Field(encoding=Encoding.SEMANTIC),\n        \"description\": Field(encoding=Encoding.SEMANTIC, weight=2.0),\n        \"status\": Field(encoding=Encoding.EXACT),\n        \"department\": Field(encoding=Encoding.EXACT),\n        \"lead_id\": Field(encoding=Encoding.EXACT),\n        \"budget\": Field(encoding=Encoding.NUMERIC),\n    },\n    primary_key=\"project_id\",\n)\n\n# Documents: searchable content\ndocuments_schema = Document(\n    content_field=\"content\",\n    content_encoding=Encoding.SEMANTIC,\n    content_weight=2.0,\n    metadata_fields={\n        \"doc_id\": Field(encoding=Encoding.EXACT),\n        \"title\": Field(encoding=Encoding.SEMANTIC, weight=1.5),\n        \"doc_type\": Field(encoding=Encoding.EXACT),\n        \"author_id\": Field(encoding=Encoding.EXACT),\n        \"department\": Field(encoding=Encoding.EXACT),\n    },\n)\n\n# Collaboration: relationship network\ncollaboration_schema = Network(\n    source_field=\"source\",\n    edge_field=\"relation\",\n    target_field=\"target\",\n    node_encoding=Encoding.EXACT,\n    edge_encoding=Encoding.EXACT,\n)\n</code></pre>"},{"location":"examples/enterprise-knowledge/#sample-data","title":"Sample Data","text":""},{"location":"examples/enterprise-knowledge/#employees","title":"Employees","text":"<pre><code>employees = pd.DataFrame([\n    {\n        \"employee_id\": \"EMP001\",\n        \"name\": \"Sarah Chen\",\n        \"title\": \"VP of Engineering\",\n        \"department\": \"Engineering\",\n        \"location\": \"San Francisco\",\n        \"bio\": \"Engineering leader with 20+ years building distributed systems. \"\n               \"Expert in Kubernetes, cloud-native, and platform engineering.\"\n    },\n    {\n        \"employee_id\": \"EMP002\",\n        \"name\": \"Alice Zhang\",\n        \"title\": \"Senior ML Engineer\",\n        \"department\": \"Data Science\",\n        \"location\": \"San Francisco\",\n        \"bio\": \"ML engineer specializing in NLP and transformers. \"\n               \"Expert in PyTorch, vector databases, and semantic search.\"\n    },\n    # ... more employees\n])\n</code></pre>"},{"location":"examples/enterprise-knowledge/#expertise-graph","title":"Expertise Graph","text":"<pre><code>expertise = pd.DataFrame([\n    # Employee skills\n    (\"EMP002\", \"expert_in\", \"Natural Language Processing\"),\n    (\"EMP002\", \"expert_in\", \"PyTorch\"),\n    (\"EMP002\", \"expert_in\", \"Vector Databases\"),\n\n    # Skill relationships\n    (\"Machine Learning\", \"related_to\", \"Deep Learning\"),\n    (\"NLP\", \"related_to\", \"Transformers\"),\n\n    # Project requirements\n    (\"PROJ001\", \"requires\", \"Machine Learning\"),\n    (\"PROJ001\", \"requires\", \"Vector Databases\"),\n], columns=[\"subject\", \"relation\", \"object\"])\n</code></pre>"},{"location":"examples/enterprise-knowledge/#collaboration-network","title":"Collaboration Network","text":"<pre><code>collaboration = pd.DataFrame([\n    # Reporting\n    (\"EMP002\", \"reports_to\", \"EMP001\"),\n    (\"EMP003\", \"reports_to\", \"EMP001\"),\n\n    # Mentorship\n    (\"EMP004\", \"mentored_by\", \"EMP002\"),\n\n    # Working together\n    (\"EMP002\", \"collaborates_with\", \"EMP003\"),\n], columns=[\"source\", \"relation\", \"target\"])\n</code></pre>"},{"location":"examples/enterprise-knowledge/#query-examples","title":"Query Examples","text":""},{"location":"examples/enterprise-knowledge/#1-semantic-employee-search","title":"1. Semantic Employee Search","text":"<p>Find employees with relevant expertise:</p> <pre><code>employees_coll = hb.collection(\"ekm_employees\")\n\nresults = employees_coll.query(employees_schema).search(\n    \"machine learning infrastructure and MLOps\",\n    top_k=5\n)\n\nfor r in results:\n    print(f\"{r['name']} - {r['title']}\")\n    print(f\"  Department: {r['department']}\")\n</code></pre>"},{"location":"examples/enterprise-knowledge/#2-find-experts-for-a-project","title":"2. Find Experts for a Project","text":"<pre><code>expertise_coll = hb.collection(\"ekm_expertise\")\n\n# Get project requirements\nreqs = expertise_coll.query(expertise_schema).find(\n    subject=\"PROJ001\", predicate=\"requires\", top_k=10\n)\nrequired_skills = [r[\"object\"] for r in reqs]\nprint(f\"Required: {required_skills}\")\n\n# Find employees with those skills\nfor skill in required_skills:\n    experts = expertise_coll.query(expertise_schema).find(\n        predicate=\"expert_in\", object=skill, top_k=5\n    )\n    for e in experts:\n        if e[\"subject\"].startswith(\"EMP\"):\n            print(f\"  {skill}: {e['subject']}\")\n</code></pre>"},{"location":"examples/enterprise-knowledge/#3-department-expertise-profile","title":"3. Department Expertise Profile","text":"<pre><code># Get department members\ndept_members = employees_coll.query(employees_schema).filter(\n    where=[(\"department\", \"==\", \"Data Science\")], top_k=20\n)\nmember_ids = [m[\"employee_id\"] for m in dept_members]\n\n# Aggregate skills\nskill_counts = {}\nfor emp_id in member_ids:\n    skills = expertise_coll.query(expertise_schema).find(\n        subject=emp_id, predicate=\"expert_in\", top_k=20\n    )\n    for s in skills:\n        skill = s[\"object\"]\n        skill_counts[skill] = skill_counts.get(skill, 0) + 1\n\nprint(\"Team expertise:\")\nfor skill, count in sorted(skill_counts.items(), key=lambda x: -x[1]):\n    print(f\"  {skill}: {count} experts\")\n</code></pre>"},{"location":"examples/enterprise-knowledge/#hdc-specific-capabilities","title":"HDC-Specific Capabilities","text":"<p>These queries are impossible with traditional databases.</p>"},{"location":"examples/enterprise-knowledge/#analogical-reasoning","title":"Analogical Reasoning","text":"<p>\"Alice is our ML expert in Data Science. Who plays a similar role in Platform?\"</p> <pre><code>results = hb.analogy(\n    a=\"Alice Zhang\",\n    b=\"Data Science\",\n    c=\"Platform\",\n    field_name=\"name\",\n    collection=\"ekm_employees\",\n    top_k=3,\n)\n\nfor r in results:\n    print(f\"\u2192 {r['name']} - {r['title']}\")\n</code></pre>"},{"location":"examples/enterprise-knowledge/#bundle-search","title":"Bundle Search","text":"<p>Find employees with ANY of multiple skills:</p> <pre><code>results = hb.bundle_search(\n    values=[\"Python\", \"Kubernetes\", \"Machine Learning\"],\n    field_name=\"object\",\n    collection=\"ekm_expertise\",\n    top_k=15,\n)\n\nemployees_found = set()\nfor r in results:\n    emp_id = r[\"subject\"]\n    if emp_id.startswith(\"EMP\"):\n        employees_found.add(emp_id)\n\nprint(f\"Found {len(employees_found)} employees with any of those skills\")\n</code></pre>"},{"location":"examples/enterprise-knowledge/#unified-semantic-search","title":"Unified Semantic Search","text":"<p>Search across all entity types with one concept:</p> <pre><code>query = \"machine learning production deployment\"\n\nprint(\"Employees:\")\nfor r in employees_coll.query(employees_schema).search(query, top_k=3):\n    print(f\"  {r['name']}\")\n\nprint(\"Documents:\")\nfor r in hb.collection(\"ekm_documents\").query(documents_schema).search(query, top_k=3):\n    print(f\"  {r['title']}\")\n\nprint(\"Projects:\")\nfor r in hb.collection(\"ekm_projects\").query(projects_schema).search(query, top_k=2):\n    print(f\"  {r['name']}\")\n</code></pre>"},{"location":"examples/enterprise-knowledge/#advanced-scenarios","title":"Advanced Scenarios","text":""},{"location":"examples/enterprise-knowledge/#knowledge-risk-assessment","title":"Knowledge Risk Assessment","text":"<p>Find skills concentrated in a single person:</p> <pre><code># Get all expertise facts\nall_expertise = expertise_coll.query(expertise_schema).find(\n    predicate=\"expert_in\", top_k=100\n)\n\n# Count experts per skill\nskill_experts = {}\nfor e in all_expertise:\n    skill = e[\"object\"]\n    emp = e[\"subject\"]\n    if emp.startswith(\"EMP\"):\n        skill_experts.setdefault(skill, []).append(emp)\n\n# Find single-expert skills\nprint(\"Knowledge risk (single expert):\")\nfor skill, experts in skill_experts.items():\n    if len(experts) == 1:\n        emp_name = get_employee_name(experts[0])\n        print(f\"  {skill} \u2192 only {emp_name}\")\n</code></pre>"},{"location":"examples/enterprise-knowledge/#cross-team-collaboration","title":"Cross-Team Collaboration","text":"<p>Find bridges between departments:</p> <pre><code># Get team members\nds_team = {e[\"employee_id\"] for e in employees_coll.query(employees_schema).filter(\n    where=[(\"department\", \"==\", \"Data Science\")], top_k=20\n)}\nplatform_team = {e[\"employee_id\"] for e in employees_coll.query(employees_schema).filter(\n    where=[(\"department\", \"==\", \"Platform\")], top_k=20\n)}\n\n# Find cross-team collaborations\ncollabs = collaboration_coll.query(collaboration_schema).find(\n    edge=\"collaborates_with\", top_k=50\n)\n\nprint(\"Cross-team bridges:\")\nfor c in collabs:\n    src, tgt = c[\"source\"], c[\"target\"]\n    if (src in ds_team and tgt in platform_team) or \\\n       (src in platform_team and tgt in ds_team):\n        print(f\"  {src} \u2194 {tgt}\")\n</code></pre>"},{"location":"examples/enterprise-knowledge/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Six compounds, one unified system - Each optimized for its data shape</li> <li>Cross-collection intelligence - Navigate relationships across collections</li> <li>HDC enables the impossible - Analogies, bundle search, semantic traversal</li> <li>Production patterns - Knowledge risk, staffing gaps, collaboration analysis</li> <li>Semantic + symbolic - Natural language queries with structured filters</li> </ol>"},{"location":"examples/fictional-universes/","title":"Fictional Universes","text":"<p>A fun introduction to HyperBinder using characters from Marvel, DC, Star Wars, Lord of the Rings, and Harry Potter.</p> <p>What you'll learn:</p> <ul> <li>Nested molecule composition (typed entities)</li> <li>Cross-universe analogical reasoning</li> <li>Bundle search for prototype matching</li> <li>Why structure matters in vector encoding</li> </ul>"},{"location":"examples/fictional-universes/#the-key-insight","title":"The Key Insight","text":"<p>Traditional vector databases encode \"Thor\" as a single vector. But which Thor?</p> <ul> <li>Marvel's Thor (Avengers)</li> <li>Norse mythology Thor</li> <li>God of War's Thor</li> </ul> <p>With nested molecules, we encode characters as typed entities:</p> <pre><code>Character = (Universe, Name)\nMarvel:Thor \u2260 Norse:Thor\n</code></pre> <p>These are different vectors, but they're related\u2014more similar to each other than Marvel:Thor is to Marvel:Hulk.</p>"},{"location":"examples/fictional-universes/#the-data","title":"The Data","text":"<p>We'll model character relationships across five fictional universes:</p> <pre><code>import pandas as pd\n\n# Format: (subject_universe, subject_name, relation, object_universe, object_name)\nfacts = [\n    # Star Wars mentorship chain\n    (\"StarWars\", \"Rey\", \"mentored_by\", \"StarWars\", \"Luke Skywalker\"),\n    (\"StarWars\", \"Luke Skywalker\", \"mentored_by\", \"StarWars\", \"Yoda\"),\n    (\"StarWars\", \"Luke Skywalker\", \"mentored_by\", \"StarWars\", \"Obi-Wan Kenobi\"),\n    (\"StarWars\", \"Anakin Skywalker\", \"mentored_by\", \"StarWars\", \"Obi-Wan Kenobi\"),\n\n    # Harry Potter mentorship\n    (\"HarryPotter\", \"Harry Potter\", \"mentored_by\", \"HarryPotter\", \"Albus Dumbledore\"),\n    (\"HarryPotter\", \"Harry Potter\", \"mentored_by\", \"HarryPotter\", \"Sirius Black\"),\n\n    # Lord of the Rings\n    (\"LotR\", \"Frodo Baggins\", \"mentored_by\", \"LotR\", \"Gandalf\"),\n    (\"LotR\", \"Bilbo Baggins\", \"mentored_by\", \"LotR\", \"Gandalf\"),\n\n    # Marvel\n    (\"Marvel\", \"Peter Parker\", \"mentored_by\", \"Marvel\", \"Tony Stark\"),\n    (\"Marvel\", \"Wanda Maximoff\", \"mentored_by\", \"Marvel\", \"Doctor Strange\"),\n\n    # DC\n    (\"DC\", \"Dick Grayson\", \"mentored_by\", \"DC\", \"Bruce Wayne\"),\n    (\"DC\", \"Tim Drake\", \"mentored_by\", \"DC\", \"Bruce Wayne\"),\n\n    # Team leadership\n    (\"Marvel\", \"Tony Stark\", \"leads\", \"Marvel\", \"Avengers\"),\n    (\"DC\", \"Superman\", \"leads\", \"DC\", \"Justice League\"),\n    (\"Marvel\", \"Charles Xavier\", \"leads\", \"Marvel\", \"X-Men\"),\n\n    # Rivalries\n    (\"Marvel\", \"Thor\", \"enemy_of\", \"Marvel\", \"Loki\"),\n    (\"DC\", \"Batman\", \"enemy_of\", \"DC\", \"Joker\"),\n    (\"StarWars\", \"Luke Skywalker\", \"enemy_of\", \"StarWars\", \"Darth Vader\"),\n    (\"HarryPotter\", \"Harry Potter\", \"enemy_of\", \"HarryPotter\", \"Voldemort\"),\n    (\"LotR\", \"Gandalf\", \"enemy_of\", \"LotR\", \"Sauron\"),\n]\n\ndf = pd.DataFrame(facts, columns=[\n    \"subject_universe\", \"subject_name\",\n    \"relation\",\n    \"object_universe\", \"object_name\"\n])\n</code></pre>"},{"location":"examples/fictional-universes/#the-schema-nested-molecules","title":"The Schema: Nested Molecules","text":"<p>Here's where it gets interesting. We define characters as Pair(universe, name):</p> <pre><code>from hybi import HyperBinder\nfrom hybi.compose import Triple, Pair, Field, Encoding\n\nschema = Triple(\n    subject=Pair(\n        left=Field(\"subject_universe\", encoding=Encoding.EXACT),\n        right=Field(\"subject_name\", encoding=Encoding.SEMANTIC),\n    ),\n    predicate=Field(\"relation\", encoding=Encoding.EXACT),\n    object=Pair(\n        left=Field(\"object_universe\", encoding=Encoding.EXACT),\n        right=Field(\"object_name\", encoding=Encoding.SEMANTIC),\n    ),\n)\n</code></pre> <p>What this encodes:</p> <pre><code>((universe, name), relation, (universe, name))\n</code></pre> <p>This creates a composite structure where:</p> <ul> <li><code>Marvel:Thor</code> and <code>Norse:Thor</code> are different vectors</li> <li>But they share the \"Thor\" component, so they're similar</li> <li>You can query by just the universe or just the name</li> </ul>"},{"location":"examples/fictional-universes/#ingest-and-query","title":"Ingest and Query","text":"<pre><code>hb = HyperBinder(\"http://localhost:8000\")\n\n# Ingest with our nested schema\nhb.ingest(df, collection=\"fictional_universe\", schema=schema)\n\n# Get a query builder\nq = hb.query(\"fictional_universe\", schema=schema)\n</code></pre>"},{"location":"examples/fictional-universes/#find-by-typed-entity","title":"Find by Typed Entity","text":"<pre><code># Find all relationships for Marvel's Tony Stark\nresults = q.find(\n    subject_universe=\"Marvel\",\n    subject_name=\"Tony Stark\",\n    top_k=10\n)\n\nfor r in results:\n    print(f\"{r['subject_universe']}:{r['subject_name']} \"\n          f\"--[{r['relation']}]--&gt; \"\n          f\"{r['object_universe']}:{r['object_name']}\")\n</code></pre> <p>Column names work directly</p> <p>Even though <code>subject_universe</code> is nested inside <code>subject.left</code> in the schema, you can query using the column name directly. HyperBinder automatically resolves field names to their schema paths. You can also use:</p> <ul> <li>Dot notation: <code>q.find(**{\"subject.left\": \"Marvel\"})</code></li> <li>Top-level slot: <code>q.find(subject=\"Tony Stark\")</code> (matches any nested field)</li> </ul> <p>Output: <pre><code>Marvel:Tony Stark --[leads]--&gt; Marvel:Avengers\nMarvel:Peter Parker --[mentored_by]--&gt; Marvel:Tony Stark\n</code></pre></p>"},{"location":"examples/fictional-universes/#find-all-mentorships","title":"Find All Mentorships","text":"<pre><code>results = q.find(relation=\"mentored_by\", top_k=20)\n\nfor r in results:\n    print(f\"{r['subject_name']} was mentored by {r['object_name']} ({r['object_universe']})\")\n</code></pre> <p>Output: <pre><code>Rey was mentored by Luke Skywalker (StarWars)\nLuke Skywalker was mentored by Yoda (StarWars)\nHarry Potter was mentored by Albus Dumbledore (HarryPotter)\nFrodo Baggins was mentored by Gandalf (LotR)\nPeter Parker was mentored by Tony Stark (Marvel)\nDick Grayson was mentored by Bruce Wayne (DC)\n...\n</code></pre></p>"},{"location":"examples/fictional-universes/#cross-universe-analogies","title":"Cross-Universe Analogies","text":"<p>This is impossible with traditional databases.</p> <p>Question: \"Luke was mentored by Yoda. Who plays a similar role for Harry?\"</p> <pre><code>results = hb.analogy(\n    a=\"Luke Skywalker\",\n    b=\"Yoda\",\n    c=\"Harry Potter\",\n    field_name=\"subject_name\",\n    collection=\"fictional_universe\",\n    top_k=3,\n)\n\nfor r in results:\n    print(f\"\u2192 {r['object_name']} ({r['object_universe']})\")\n</code></pre> <p>Output: <pre><code>\u2192 Albus Dumbledore (HarryPotter)\n\u2192 Sirius Black (HarryPotter)\n</code></pre></p> <p>The system found Dumbledore\u2014the wise elder mentor archetype that matches Yoda's role for Luke.</p>"},{"location":"examples/fictional-universes/#another-analogy","title":"Another Analogy","text":"<p>Question: \"Batman mentored Robin. Who did Obi-Wan mentor similarly?\"</p> <pre><code>results = hb.analogy(\n    a=\"Bruce Wayne\",\n    b=\"Dick Grayson\",\n    c=\"Obi-Wan Kenobi\",\n    field_name=\"subject_name\",\n    collection=\"fictional_universe\",\n    top_k=3,\n)\n</code></pre> <p>Output: <pre><code>\u2192 Anakin Skywalker\n</code></pre></p> <p>Anakin was Obi-Wan's primary apprentice, just as Robin was Batman's.</p>"},{"location":"examples/fictional-universes/#bundle-search-find-similar-characters","title":"Bundle Search: Find Similar Characters","text":"<p>Find characters that match ANY of multiple examples:</p> <pre><code># Find characters like Superman, Thor, Wonder Woman (powerful hero archetypes)\nresults = hb.bundle_search(\n    values=[\"Superman\", \"Thor\", \"Wonder Woman\"],\n    field_name=\"subject_name\",\n    collection=\"fictional_universe\",\n    top_k=10,\n)\n</code></pre> <p>Or find mentor figures:</p> <pre><code># Find wise elders like Yoda, Gandalf, Dumbledore\nresults = hb.bundle_search(\n    values=[\"Yoda\", \"Gandalf\", \"Albus Dumbledore\"],\n    field_name=\"object_name\",\n    collection=\"fictional_universe\",\n    top_k=10,\n)\n</code></pre>"},{"location":"examples/fictional-universes/#why-nesting-matters","title":"Why Nesting Matters","text":"<p>Without nesting (flat encoding): <pre><code>encode(\"Thor\") = same vector everywhere\nNo distinction between universes\n</code></pre></p> <p>With nesting (typed entities): <pre><code>encode(\"Marvel\", \"Thor\") = different from encode(\"Norse\", \"Thor\")\n</code></pre></p> <p>These are DIFFERENT but RELATED vectors: - <code>similarity(Marvel:Thor, Norse:Thor) &gt; 0.5</code> (same name) - <code>similarity(Marvel:Thor, Marvel:Hulk) &lt; 0.3</code> (different character)</p> <p>This enables:</p> <ol> <li>Disambiguation - Which Thor do you mean?</li> <li>Cross-domain analogies - Similar characters across universes</li> <li>Component extraction - Query by universe or name independently</li> <li>Typed queries - \"Find all Marvel mentors\"</li> </ol>"},{"location":"examples/fictional-universes/#complete-code","title":"Complete Code","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"Fictional Universe Knowledge Graph Demo\"\"\"\n\nimport pandas as pd\nfrom hybi import HyperBinder\nfrom hybi.compose import Triple, Pair, Field, Encoding\n\n\ndef create_data():\n    facts = [\n        # Star Wars\n        (\"StarWars\", \"Rey\", \"mentored_by\", \"StarWars\", \"Luke Skywalker\"),\n        (\"StarWars\", \"Luke Skywalker\", \"mentored_by\", \"StarWars\", \"Yoda\"),\n        (\"StarWars\", \"Luke Skywalker\", \"mentored_by\", \"StarWars\", \"Obi-Wan Kenobi\"),\n        (\"StarWars\", \"Anakin Skywalker\", \"mentored_by\", \"StarWars\", \"Obi-Wan Kenobi\"),\n        (\"StarWars\", \"Luke Skywalker\", \"enemy_of\", \"StarWars\", \"Darth Vader\"),\n\n        # Harry Potter\n        (\"HarryPotter\", \"Harry Potter\", \"mentored_by\", \"HarryPotter\", \"Albus Dumbledore\"),\n        (\"HarryPotter\", \"Harry Potter\", \"mentored_by\", \"HarryPotter\", \"Sirius Black\"),\n        (\"HarryPotter\", \"Harry Potter\", \"enemy_of\", \"HarryPotter\", \"Voldemort\"),\n\n        # Lord of the Rings\n        (\"LotR\", \"Frodo Baggins\", \"mentored_by\", \"LotR\", \"Gandalf\"),\n        (\"LotR\", \"Gandalf\", \"enemy_of\", \"LotR\", \"Sauron\"),\n\n        # Marvel\n        (\"Marvel\", \"Peter Parker\", \"mentored_by\", \"Marvel\", \"Tony Stark\"),\n        (\"Marvel\", \"Tony Stark\", \"leads\", \"Marvel\", \"Avengers\"),\n        (\"Marvel\", \"Thor\", \"enemy_of\", \"Marvel\", \"Loki\"),\n\n        # DC\n        (\"DC\", \"Dick Grayson\", \"mentored_by\", \"DC\", \"Bruce Wayne\"),\n        (\"DC\", \"Batman\", \"enemy_of\", \"DC\", \"Joker\"),\n        (\"DC\", \"Superman\", \"leads\", \"DC\", \"Justice League\"),\n    ]\n    return pd.DataFrame(facts, columns=[\n        \"subject_universe\", \"subject_name\", \"relation\",\n        \"object_universe\", \"object_name\"\n    ])\n\n\ndef main():\n    hb = HyperBinder(\"http://localhost:8000\")\n\n    # Nested schema: Character = Pair(Universe, Name)\n    schema = Triple(\n        subject=Pair(\n            left=Field(\"subject_universe\", encoding=Encoding.EXACT),\n            right=Field(\"subject_name\", encoding=Encoding.SEMANTIC),\n        ),\n        predicate=Field(\"relation\", encoding=Encoding.EXACT),\n        object=Pair(\n            left=Field(\"object_universe\", encoding=Encoding.EXACT),\n            right=Field(\"object_name\", encoding=Encoding.SEMANTIC),\n        ),\n    )\n\n    # Ingest\n    df = create_data()\n    hb.ingest(df, collection=\"fictional_universe\", schema=schema)\n\n    # Query\n    q = hb.query(\"fictional_universe\", schema=schema)\n\n    # Find all mentorships\n    print(\"Mentorship relationships:\")\n    for r in q.find(relation=\"mentored_by\", top_k=10):\n        print(f\"  {r['subject_name']} \u2190 {r['object_name']}\")\n\n    # Cross-universe analogy\n    print(\"\\nAnalogy: Luke:Yoda :: Harry:?\")\n    results = hb.analogy(\"Luke Skywalker\", \"Yoda\", \"Harry Potter\",\n                         field_name=\"subject_name\",\n                         collection=\"fictional_universe\")\n    for r in results:\n        print(f\"  \u2192 {r['object_name']}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/fictional-universes/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Nested molecules encode structure - Characters as (Universe, Name) pairs</li> <li>Typed entities enable disambiguation - Marvel:Thor \u2260 Norse:Thor</li> <li>Cross-universe analogies find similar roles - Yoda\u2194Dumbledore as mentor archetypes</li> <li>Bundle search matches prototypes - Find characters like ANY of multiple examples</li> <li>The structure IS the semantics - Nesting encodes meaning into vector space</li> </ol>"},{"location":"examples/fuzzy-to-exact/","title":"Fuzzy-to-Exact Bridge Pattern","text":"<p>Combine semantic search (fuzzy) with exact filtering to get deterministic results safe for CRUD operations.</p>"},{"location":"examples/fuzzy-to-exact/#the-problem","title":"The Problem","text":"<p>Semantic search is powerful for discovery but inherently non-deterministic:</p> <pre><code># Same query, different runs = potentially different results\nresults = hb.query(\"users\", catalog_schema).search(\"ML expert\")\n# Run 1: [Alice, Bob, Carol]\n# Run 2: [Alice, Carol, David]  # Bob dropped below threshold\n</code></pre> <p>This makes semantic search unsafe for mutations. You don't want to accidentally update/delete the wrong rows because similarity scores shifted.</p>"},{"location":"examples/fuzzy-to-exact/#the-solution-bridge-pattern","title":"The Solution: Bridge Pattern","text":"<p>Use fuzzy search to narrow the search space, then exact filters to define deterministic boundaries:</p> <pre><code>flowchart TB\n    subgraph Catalog[\"CATALOG (Search)\"]\n        C1[Semantic Index]\n        C2[Fuzzy Discovery]\n        C1 --&gt; C2\n    end\n\n    subgraph RelationalTable[\"RELATIONAL TABLE (CRUD)\"]\n        R1[Chain Binding]\n        R2[PK Lookups]\n        R1 --&gt; R2\n    end\n\n    C2 --&gt; Bridge\n    R2 --&gt; Bridge\n    Bridge[BRIDGE&lt;br/&gt;Primary Keys] --&gt; Mutations[Deterministic Mutations]</code></pre> <p>Key insight: Each compound does what it's optimized for. Catalog handles search, RelationalTable handles CRUD, and primary keys bridge between them.</p>"},{"location":"examples/fuzzy-to-exact/#separation-of-concerns","title":"Separation of Concerns","text":"Compound Encoding Optimized For Use In Pattern Catalog Search-optimized Fast semantic search Discovery stage RelationalTable Structured CRUD operations Mutation stage <p>This respects the design intent: - Catalog's search-optimized encoding enables fast similarity search - RelationalTable's structured encoding enables exact field updates</p>"},{"location":"examples/fuzzy-to-exact/#implementation","title":"Implementation","text":""},{"location":"examples/fuzzy-to-exact/#fuzzytoexactbridge-class","title":"FuzzyToExactBridge Class","text":"<pre><code>from typing import List, Dict, Any, Optional\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass RefinedResult:\n    \"\"\"Result from fuzzy-to-exact refinement.\"\"\"\n    pk_field: str\n    pk_value: str\n    data: Dict[str, Any]\n    semantic_score: float\n    exact_matches: Dict[str, bool]\n\n\nclass FuzzyToExactBridge:\n    \"\"\"\n    Bridge that connects semantic search to exact filtering.\n\n    Usage:\n        bridge = FuzzyToExactBridge(hb, \"users\", users_schema)\n\n        results = (bridge\n            .fuzzy(\"machine learning expertise\", top_k=50)\n            .exact(department=\"Engineering\")\n            .exact(status=\"active\")\n            .numeric(salary__gt=100000)\n            .execute())\n\n        # Results are deterministic - safe for CRUD\n        for r in results:\n            hb.update(\"users\", where={r.pk_field: r.pk_value}, set={...})\n    \"\"\"\n\n    def __init__(self, client, collection: str, schema):\n        self.client = client\n        self.collection = collection\n        self.schema = schema\n        self.pk_field = schema.primary_key\n\n        # Query state\n        self._fuzzy_query: Optional[str] = None\n        self._fuzzy_top_k: int = 50\n        self._exact_filters: Dict[str, Any] = {}\n        self._numeric_filters: List[tuple] = []\n\n    def fuzzy(self, query: str, top_k: int = 50) -&gt; \"FuzzyToExactBridge\":\n        \"\"\"Stage 1: Semantic search to find candidates.\"\"\"\n        self._fuzzy_query = query\n        self._fuzzy_top_k = top_k\n        return self\n\n    def exact(self, **kwargs) -&gt; \"FuzzyToExactBridge\":\n        \"\"\"Stage 2a: Exact field match filter.\"\"\"\n        self._exact_filters.update(kwargs)\n        return self\n\n    def numeric(self, **kwargs) -&gt; \"FuzzyToExactBridge\":\n        \"\"\"\n        Stage 2b: Numeric range filter.\n\n        Supports: field__gt, field__lt, field__gte, field__lte\n        \"\"\"\n        for key, value in kwargs.items():\n            if \"__\" in key:\n                field, op = key.rsplit(\"__\", 1)\n                self._numeric_filters.append((field, op, value))\n            else:\n                self._numeric_filters.append((key, \"eq\", value))\n        return self\n\n    def execute(self) -&gt; List[RefinedResult]:\n        \"\"\"Execute the fuzzy-to-exact pipeline.\"\"\"\n        # Stage 1: Fuzzy search\n        if self._fuzzy_query:\n            candidates = self._semantic_search()\n        else:\n            candidates = self._get_all_candidates()\n\n        # Stage 2: Exact + Numeric filtering\n        refined = []\n        for candidate in candidates:\n            data = candidate[\"data\"]\n            score = candidate.get(\"score\", 1.0)\n\n            # Check exact filters\n            exact_matches = {}\n            passes_exact = True\n            for field, expected in self._exact_filters.items():\n                actual = data.get(field)\n                matches = str(actual) == str(expected)\n                exact_matches[field] = matches\n                if not matches:\n                    passes_exact = False\n\n            if not passes_exact:\n                continue\n\n            # Check numeric filters\n            passes_numeric = self._check_numeric_filters(data)\n            if not passes_numeric:\n                continue\n\n            refined.append(RefinedResult(\n                pk_field=self.pk_field,\n                pk_value=str(data.get(self.pk_field)),\n                data=data,\n                semantic_score=score,\n                exact_matches=exact_matches,\n            ))\n\n        return refined\n\n    def _semantic_search(self) -&gt; List[Dict]:\n        \"\"\"Perform semantic search via query interface.\"\"\"\n        results = self.client.query(self.collection, self.schema).search(\n            self._fuzzy_query,\n            top_k=self._fuzzy_top_k,\n        )\n        return [{\"data\": r.data, \"score\": getattr(r, \"score\", 1.0)} for r in results]\n\n    def _get_all_candidates(self) -&gt; List[Dict]:\n        \"\"\"Get all rows when no fuzzy query specified.\"\"\"\n        results = self.client.select(self.collection, limit=1000)\n        return [{\"data\": r, \"score\": 1.0} for r in results.rows]\n\n    def _check_numeric_filters(self, data: Dict) -&gt; bool:\n        \"\"\"Check all numeric filter conditions.\"\"\"\n        for field, op, threshold in self._numeric_filters:\n            try:\n                actual = float(data.get(field, 0))\n                threshold = float(threshold)\n\n                if op == \"gt\" and not (actual &gt; threshold):\n                    return False\n                elif op == \"lt\" and not (actual &lt; threshold):\n                    return False\n                elif op == \"gte\" and not (actual &gt;= threshold):\n                    return False\n                elif op == \"lte\" and not (actual &lt;= threshold):\n                    return False\n                elif op == \"eq\" and not (actual == threshold):\n                    return False\n            except (ValueError, TypeError):\n                return False\n        return True\n</code></pre>"},{"location":"examples/fuzzy-to-exact/#complete-example-dual-schema-pattern","title":"Complete Example: Dual-Schema Pattern","text":"<p>This example shows the recommended architecture: Catalog for search, RelationalTable for CRUD.</p> <pre><code>from hybi import HyperBinder\nfrom hybi.compose import Catalog, RelationalTable, Field, Encoding\nimport pandas as pd\n\n# ----- SCHEMA DEFINITIONS -----\n\n# Catalog schema: Optimized for semantic search (Bundle encoding)\nusers_search_schema = Catalog(\n    fields={\n        \"user_id\": {\"encoding\": \"exact\"},              # For bridging to CRUD\n        \"name\": {\"encoding\": \"semantic\", \"weight\": 1.0},\n        \"bio\": {\"encoding\": \"semantic\", \"weight\": 1.5},  # Boost bio matches\n        \"department\": {\"encoding\": \"exact\"},\n        \"status\": {\"encoding\": \"exact\"},\n    }\n)\n\n# RelationalTable schema: Optimized for CRUD (Row encoding)\nusers_crud_schema = RelationalTable(\n    columns={\n        \"user_id\": Field(encoding=Encoding.EXACT),\n        \"name\": Field(encoding=Encoding.SEMANTIC),\n        \"bio\": Field(encoding=Encoding.SEMANTIC),\n        \"department\": Field(encoding=Encoding.EXACT),\n        \"status\": Field(encoding=Encoding.EXACT),\n        \"salary\": Field(encoding=Encoding.NUMERIC, similar_within=10000),\n    },\n    primary_key=\"user_id\",\n)\n\n# ----- DATA -----\n\nusers_data = pd.DataFrame([\n    {\"user_id\": \"U001\", \"name\": \"Alice Chen\",\n     \"bio\": \"Machine learning engineer with NLP expertise\",\n     \"department\": \"Engineering\", \"status\": \"active\", \"salary\": 150000},\n    {\"user_id\": \"U002\", \"name\": \"Bob Smith\",\n     \"bio\": \"Backend developer focusing on APIs\",\n     \"department\": \"Engineering\", \"status\": \"active\", \"salary\": 120000},\n    {\"user_id\": \"U003\", \"name\": \"Carol White\",\n     \"bio\": \"ML researcher specializing in computer vision\",\n     \"department\": \"Research\", \"status\": \"active\", \"salary\": 140000},\n    {\"user_id\": \"U004\", \"name\": \"David Lee\",\n     \"bio\": \"Data scientist with machine learning background\",\n     \"department\": \"Engineering\", \"status\": \"inactive\", \"salary\": 130000},\n    {\"user_id\": \"U005\", \"name\": \"Eve Johnson\",\n     \"bio\": \"Deep learning specialist in NLP\",\n     \"department\": \"Engineering\", \"status\": \"active\", \"salary\": 160000},\n])\n\n# ----- INITIALIZATION -----\n\nhb = HyperBinder(local=True, db_path=\"./fuzzy_exact_demo_db\")\n\n# Ingest into BOTH collections\n# Search collection: Uses Catalog (fast semantic search)\nhb.ingest(users_data, collection=\"users_search\", schema=users_search_schema)\n\n# CRUD collection: Uses RelationalTable (exact field updates)\nhb.ingest(users_data, collection=\"users\", schema=users_crud_schema)\n\n# ----- BRIDGE PATTERN -----\n\n# Stage 1: Semantic search via Catalog (fast, fuzzy)\ncandidates = hb.query(\"users_search\", users_search_schema).search(\n    \"machine learning NLP expert\",\n    top_k=10,\n)\n\nprint(f\"Stage 1 - Fuzzy search found {len(candidates)} candidates\")\n\n# Stage 2: Exact filtering on candidate data\nrefined = []\nfor r in candidates:\n    data = r.data\n    if (data.get(\"department\") == \"Engineering\" and\n        data.get(\"status\") == \"active\"):\n        refined.append({\n            \"pk\": data[\"user_id\"],\n            \"data\": data,\n            \"score\": getattr(r, \"score\", 1.0),\n        })\n\nprint(f\"Stage 2 - After exact filters: {len(refined)} results\")\n\n# Stage 3: CRUD via RelationalTable (deterministic)\nfor r in refined:\n    pk = r[\"pk\"]\n\n    # Get current row from CRUD collection (has salary field)\n    current = hb.query(\"users\", users_crud_schema).get(user_id=pk)\n\n    if current and current.data.get(\"salary\", 0) &gt; 125000:\n        print(f\"  {pk}: {r['data']['name']} - eligible for update\")\n\n        # Safe to mutate - we have a deterministic PK\n        hb.update(\n            \"users\",\n            where={\"user_id\": pk},\n            set={\"salary\": int(current.data[\"salary\"] * 1.1)},  # 10% raise\n            schema=users_crud_schema,\n        )\n</code></pre> <p>Output: <pre><code>Stage 1 - Fuzzy search found 5 candidates\nStage 2 - After exact filters: 3 results\n  U001: Alice Chen - eligible for update\n  U005: Eve Johnson - eligible for update\n</code></pre></p>"},{"location":"examples/fuzzy-to-exact/#single-schema-alternative","title":"Single-Schema Alternative","text":"<p>If you don't need separate optimization, RelationalTable can do both (with some search overhead):</p> <pre><code># Single schema handles both search and CRUD\nusers_schema = RelationalTable(\n    columns={\n        \"user_id\": Field(encoding=Encoding.EXACT),\n        \"name\": Field(encoding=Encoding.SEMANTIC),\n        \"bio\": Field(encoding=Encoding.SEMANTIC),\n        \"department\": Field(encoding=Encoding.EXACT),\n        \"status\": Field(encoding=Encoding.EXACT),\n        \"salary\": Field(encoding=Encoding.NUMERIC, similar_within=10000),\n    },\n    primary_key=\"user_id\",\n)\n\n# Ingest once\nhb.ingest(users_data, collection=\"users\", schema=users_schema)\n\n# Search and CRUD on same collection\ncandidates = hb.query(\"users\", users_schema).search(\"ML expert\", top_k=10)\n# ... filter and mutate ...\n</code></pre> <p>Trade-off: Simpler setup, but search is slower than dedicated Catalog.</p>"},{"location":"examples/fuzzy-to-exact/#when-to-use-this-pattern","title":"When to Use This Pattern","text":"<p>Use the bridge pattern when:</p> <ul> <li>You need semantic discovery (\"find people like X\")</li> <li>But require deterministic results for mutations</li> <li>Your data has both semantic fields (name, bio) and exact fields (department, status)</li> </ul> <p>Don't use this pattern when:</p> <ul> <li>You already know the exact primary keys</li> <li>Pure exact matching suffices (use <code>filter()</code> directly)</li> <li>Read-only semantic search (no mutations needed)</li> </ul>"},{"location":"examples/fuzzy-to-exact/#architecture-notes","title":"Architecture Notes","text":""},{"location":"examples/fuzzy-to-exact/#dual-schema-architecture-recommended","title":"Dual-Schema Architecture (Recommended)","text":"Collection Compound Encoding Purpose <code>users_search</code> Catalog Search-optimized Fast semantic discovery <code>users</code> RelationalTable Structured CRUD operations <p>Benefits: - Each compound is optimized for its use case - Search performance isn't degraded by CRUD overhead - Clear separation of concerns</p> <p>Trade-off: Data is stored twice (search index + CRUD collection). Keep them in sync by re-ingesting when source data changes.</p>"},{"location":"examples/fuzzy-to-exact/#single-schema-architecture","title":"Single-Schema Architecture","text":"<p>If storage/sync overhead is a concern, use RelationalTable for both:</p> Collection Compound Encoding Purpose <code>users</code> RelationalTable Row Both search and CRUD <p>Benefits: - Single source of truth - No sync issues</p> <p>Trade-off: Search is slower than dedicated Catalog.</p>"},{"location":"examples/fuzzy-to-exact/#sync-strategy","title":"Sync Strategy","text":"<p>When using dual-schema, keep collections in sync:</p> <pre><code># Option 1: Full re-ingest (simple, slower)\ndef sync_collections(data, hb):\n    hb.ingest(data, collection=\"users_search\", schema=search_schema)\n    hb.ingest(data, collection=\"users\", schema=crud_schema)\n\n# Option 2: Incremental (complex, faster)\n# - CRUD changes go to RelationalTable only\n# - Periodic batch sync to Catalog for search\n# - Accept that search may be slightly stale\n</code></pre> <p>The bridge pattern works regardless of sync strategy because it always reads current PKs from the search index, then operates on the CRUD collection.</p>"},{"location":"examples/fuzzy-to-exact/#see-also","title":"See Also","text":"<ul> <li>RelationalTable - Schema definition</li> <li>CRUD Operations - Client methods</li> <li>Intersections Tutorial - Cross-collection joins</li> </ul>"},{"location":"examples/intersections-tutorial/","title":"Intersections Tutorial","text":"<p>A step-by-step guide to understanding how cross-collection joins work in HyperBinder.</p> <p>What you'll learn:</p> <ul> <li>Declaring intersections between collections</li> <li>How the join mechanics work internally</li> <li>Working with JoinedResult and match status</li> <li>Output formats and filtering</li> </ul>"},{"location":"examples/intersections-tutorial/#the-problem","title":"The Problem","text":"<p>You have two collections:</p> <ul> <li>employees: <code>{employee_id, name, dept}</code></li> <li>expertise: <code>{subject, skill, level}</code></li> </ul> <p>They're connected: <code>employees.employee_id</code> links to <code>expertise.subject</code>.</p> <p>How do you query employees and get their skills in one operation?</p>"},{"location":"examples/intersections-tutorial/#step-1-declare-the-intersection","title":"Step 1: Declare the Intersection","text":"<p>An intersection declares the relationship between two collections:</p> <pre><code>from hybi import HyperBinder\n\nhb = HyperBinder(\"http://localhost:8000\")\n\n# Declare: employees.employee_id links to expertise.subject\nintersection = hb.intersect(\"employees.employee_id\", \"expertise.subject\")\n</code></pre> <p>This tells HyperBinder:</p> <p>\"When I query 'employees' and join to 'expertise', match rows where <code>employees.employee_id = expertise.subject</code>\"</p> <p>The intersection is stored in a registry and can be reused.</p>"},{"location":"examples/intersections-tutorial/#step-2-sample-data","title":"Step 2: Sample Data","text":"<pre><code># Employees\nemployees = [\n    {\"employee_id\": \"EMP001\", \"name\": \"Alice\", \"dept\": \"Engineering\"},\n    {\"employee_id\": \"EMP002\", \"name\": \"Bob\", \"dept\": \"Engineering\"},\n    {\"employee_id\": \"EMP003\", \"name\": \"Charlie\", \"dept\": \"Sales\"},\n]\n\n# Expertise (skills held by employees)\nexpertise = [\n    {\"subject\": \"EMP001\", \"skill\": \"Python\", \"level\": \"Expert\"},\n    {\"subject\": \"EMP001\", \"skill\": \"Rust\", \"level\": \"Intermediate\"},\n    {\"subject\": \"EMP002\", \"skill\": \"JavaScript\", \"level\": \"Expert\"},\n    {\"subject\": \"EMP002\", \"skill\": \"Python\", \"level\": \"Beginner\"},\n    # Note: EMP003 has no expertise records\n]\n</code></pre>"},{"location":"examples/intersections-tutorial/#step-3-understanding-the-join-mechanics","title":"Step 3: Understanding the Join Mechanics","text":"<p>When you use <code>.join()</code>, HyperBinder matches rows based on the declared intersection:</p> <p>What happens:</p> Employee Matching Expertise Status Alice (EMP001) Python (Expert), Rust (Intermediate) MATCHED Bob (EMP002) JavaScript (Expert), Python (Beginner) MATCHED Charlie (EMP003) (none) NO_MATCH <p>Alice and Bob each match multiple expertise rows, so they appear multiple times in the results.</p>"},{"location":"examples/intersections-tutorial/#step-4-working-with-joinedresult","title":"Step 4: Working with JoinedResult","text":"<p>Each result has helpful properties:</p> <pre><code>for result in joined_results:\n    # Check match status\n    if result.is_matched:\n        # Confident match - safe to access target\n        print(f\"MATCHED: {result.source['name']} knows {result.target['skill']}\")\n\n    elif result.is_null:\n        # Ambiguous match (multiple close candidates with similar scores)\n        print(f\"AMBIGUOUS: {result.source['name']} - unclear match\")\n\n    elif result.is_no_match:\n        # No matching row found\n        print(f\"NO MATCH: {result.source['name']} - no expertise on file\")\n</code></pre> <p>Output: <pre><code>MATCHED: Alice knows Python\nMATCHED: Alice knows Rust\nMATCHED: Bob knows JavaScript\nMATCHED: Bob knows Python\nNO MATCH: Charlie - no expertise on file\n</code></pre></p>"},{"location":"examples/intersections-tutorial/#match-status-values","title":"Match Status Values","text":"Status Meaning When it happens <code>MATCHED</code> Confident match found Clear best match above threshold <code>NULL</code> Ambiguous match Multiple candidates with similar scores <code>NO_MATCH</code> No match found No candidates above threshold"},{"location":"examples/intersections-tutorial/#step-5-filtering-results","title":"Step 5: Filtering Results","text":"<p>Wrap results in <code>JoinedResultSet</code> for filtering utilities:</p> <pre><code>from hybi.compose.intersections import JoinedResultSet\n\nresult_set = JoinedResultSet(\n    results=joined_results,\n    intersection=intersection,\n    source_count=len(employees),\n    target_count=len(expertise),\n)\n\n# Get only matched results\nmatched = result_set.filter_matched()\nprint(f\"Matched: {len(matched)} of {len(result_set)}\")\n\n# Statistics\nprint(f\"Matched count: {result_set.matched_count}\")\nprint(f\"Null count: {result_set.null_count}\")\nprint(f\"No match count: {result_set.no_match_count}\")\nprint(f\"Expansion ratio: {result_set.expansion_ratio:.2f}x\")\n</code></pre> <p>Output: <pre><code>Matched: 4 of 5\nMatched count: 4\nNull count: 0\nNo match count: 1\nExpansion ratio: 1.67x\n</code></pre></p> <p>The expansion ratio shows fan-out: 3 employees became 5 results (some matched multiple expertise rows).</p>"},{"location":"examples/intersections-tutorial/#step-6-output-formats","title":"Step 6: Output Formats","text":"<p>JoinedResult supports multiple access patterns:</p>"},{"location":"examples/intersections-tutorial/#direct-access-recommended","title":"Direct Access (Recommended)","text":"<pre><code>result.source['name']     # \u2192 \"Alice\"\nresult.target['skill']    # \u2192 \"Python\"\n</code></pre>"},{"location":"examples/intersections-tutorial/#flat-dictionary","title":"Flat Dictionary","text":"<p>Keys are prefixed with collection names:</p> <pre><code>result.to_flat()\n# {\n#   'employees.employee_id': 'EMP001',\n#   'employees.name': 'Alice',\n#   'employees.dept': 'Engineering',\n#   'expertise.subject': 'EMP001',\n#   'expertise.skill': 'Python',\n#   'expertise.level': 'Expert',\n#   '_score': 1.0,\n#   '_status': 'MATCHED'\n# }\n</code></pre>"},{"location":"examples/intersections-tutorial/#nested-dictionary","title":"Nested Dictionary","text":"<p>Grouped by collection:</p> <pre><code>result.to_nested()\n# {\n#   'employees': {'employee_id': 'EMP001', 'name': 'Alice', 'dept': 'Engineering'},\n#   'expertise': {'subject': 'EMP001', 'skill': 'Python', 'level': 'Expert'}\n# }\n</code></pre>"},{"location":"examples/intersections-tutorial/#step-7-using-join-in-practice","title":"Step 7: Using .join() in Practice","text":"<p>With the intersection declared, use <code>.join()</code> in queries:</p> <pre><code># Query employees, join to expertise\nresults = (\n    hb.query(\"employees\", schema=employee_schema)\n    .search(\"engineering\")\n    .join(\"expertise\")\n)\n\nfor r in results:\n    if r.is_matched:\n        print(f\"{r.source['name']} knows {r.target['skill']}\")\n</code></pre>"},{"location":"examples/intersections-tutorial/#chaining-joins","title":"Chaining Joins","text":"<p>Join through multiple collections:</p> <pre><code>results = (\n    hb.query(\"employees\")\n    .search(\"senior engineer\")\n    .join(\"expertise\")       # employees \u2192 expertise\n    .join(\"projects\")        # expertise \u2192 projects\n    .join(\"budgets\")         # projects \u2192 budgets\n)\n</code></pre>"},{"location":"examples/intersections-tutorial/#error-handling","title":"Error Handling","text":""},{"location":"examples/intersections-tutorial/#no-intersection-declared","title":"No Intersection Declared","text":"<pre><code>from hybi.compose.intersections import NoIntersectionError\n\ntry:\n    results = hb.query(\"employees\").search(\"...\").join(\"unknown_collection\")\nexcept NoIntersectionError as e:\n    print(f\"No intersection defined between employees and unknown_collection\")\n</code></pre>"},{"location":"examples/intersections-tutorial/#circular-joins","title":"Circular Joins","text":"<pre><code>from hybi.compose.intersections import CircularJoinError\n\ntry:\n    results = query.join(\"A\").join(\"B\").join(\"A\")  # Cycle!\nexcept CircularJoinError as e:\n    print(f\"Detected cycle: {e.path}\")\n</code></pre>"},{"location":"examples/intersections-tutorial/#complete-example","title":"Complete Example","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"Intersections Tutorial: Complete Example\"\"\"\n\nfrom hybi import HyperBinder\nfrom hybi.compose import Triple, Field, Encoding\n\n# Connect\nhb = HyperBinder(\"http://localhost:8000\")\n\n# Define schemas\nemployee_schema = Triple(\n    subject=Field(\"employee_id\", encoding=Encoding.EXACT),\n    predicate=Field(\"role\"),\n    object=Field(\"department\"),\n)\n\nexpertise_schema = Triple(\n    subject=Field(\"employee_id\", encoding=Encoding.EXACT),\n    predicate=Field(\"skill\"),\n    object=Field(\"level\"),\n)\n\n# Ingest data\nhb.ingest(employees_df, collection=\"employees\", schema=employee_schema)\nhb.ingest(expertise_df, collection=\"expertise\", schema=expertise_schema)\n\n# Declare intersection\nhb.intersect(\"employees.employee_id\", \"expertise.employee_id\")\n\n# Query with join\nresults = (\n    hb.query(\"employees\", schema=employee_schema)\n    .find(department=\"Engineering\")\n    .join(\"expertise\")\n)\n\n# Process results\nfor r in results.filter_matched():\n    print(f\"{r.source['employee_id']}: {r.target['skill']} ({r.target['level']})\")\n</code></pre>"},{"location":"examples/intersections-tutorial/#step-8-cross-encoding-joins-flexible-mode","title":"Step 8: Cross-Encoding Joins (Flexible Mode)","text":"<p>What if your fields have different encoding types? For example:</p> <ul> <li><code>employees.employee_id</code> uses EXACT encoding</li> <li><code>expertise.topic</code> uses SEMANTIC encoding</li> </ul> <p>By default, these can't intersect\u2014their encodings are incompatible. Flexible mode solves this with explicit link bindings.</p>"},{"location":"examples/intersections-tutorial/#the-problem_1","title":"The Problem","text":"<pre><code># This won't work in strict mode:\n# EXACT (employee_id) \u2194 SEMANTIC (topic) = Encoding mismatch!\nhb.intersect(\"employees.employee_id\", \"expertise.topic\")  # Error!\n</code></pre>"},{"location":"examples/intersections-tutorial/#the-solution-flexible-intersections","title":"The Solution: Flexible Intersections","text":"<pre><code># 1. Declare a FLEXIBLE intersection\nix = hb.intersect_flexible(\"employees.employee_id\", \"expertise.topic\")\n\n# 2. Provide explicit link mappings\nlinks_df = pd.DataFrame({\n    \"emp_id\": [\"EMP001\", \"EMP002\", \"EMP003\"],\n    \"topic\": [\"machine learning\", \"databases\", \"cloud computing\"]\n})\nhb.populate_links(ix, links_df, \"emp_id\", \"topic\")\n\n# 3. Now the join works!\nresults = (\n    hb.query(\"employees\")\n    .filter(employee_id=\"EMP001\")\n    .join(\"expertise\")\n)\n\nfor r in results:\n    if r.is_matched:\n        print(f\"{r.source['employee_id']} \u2192 {r.target['topic']}\")\n        # EMP001 \u2192 machine learning\n</code></pre>"},{"location":"examples/intersections-tutorial/#how-links-work","title":"How Links Work","text":"<p>Links are bidirectional value mappings:</p> Source (employee_id) Target (topic) EMP001 machine learning EMP002 databases EMP003 cloud computing <p>The join uses these mappings instead of encoding-based matching:</p> <ol> <li>Query employees, get source values (<code>EMP001</code>, <code>EMP002</code>)</li> <li>Look up link mappings \u2192 <code>[\"machine learning\", \"databases\"]</code></li> <li>Match against target results</li> <li>Return joined rows</li> </ol>"},{"location":"examples/intersections-tutorial/#one-to-many-links","title":"One-to-Many Links","text":"<p>A single source can link to multiple targets:</p> <pre><code>links_df = pd.DataFrame({\n    \"emp_id\": [\"EMP001\", \"EMP001\", \"EMP002\"],  # EMP001 appears twice!\n    \"topic\": [\"machine learning\", \"AI\", \"databases\"]\n})\nhb.populate_links(ix, links_df, \"emp_id\", \"topic\")\n\n# EMP001 now matches BOTH \"machine learning\" AND \"AI\"\n</code></pre>"},{"location":"examples/intersections-tutorial/#when-to-use-flexible-mode","title":"When to Use Flexible Mode","text":"Use Flexible Mode Use Strict Mode EXACT\u2194SEMANTIC fields Same encoding types Explicit value mappings needed Natural equality works Foreign-key-like relationships Self-joining collections"},{"location":"examples/intersections-tutorial/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>DECLARE: <code>hb.intersect(\"source.field\", \"target.field\")</code></li> <li> <p>Tells HyperBinder how collections relate</p> </li> <li> <p>JOIN: <code>hb.query(\"source\").search(\"...\").join(\"target\")</code></p> </li> <li> <p>Executes the cross-collection query</p> </li> <li> <p>ACCESS: <code>result.source[\"field\"]</code>, <code>result.target[\"field\"]</code></p> </li> <li> <p>Direct access to matched data</p> </li> <li> <p>CHECK: <code>result.is_matched</code>, <code>result.is_null</code>, <code>result.is_no_match</code></p> </li> <li> <p>Know the quality of each match</p> </li> <li> <p>FILTER: <code>result_set.filter_matched()</code></p> </li> <li> <p>Get only confident matches</p> </li> <li> <p>FLEXIBLE MODE: <code>hb.intersect_flexible()</code> + <code>hb.populate_links()</code></p> </li> <li>Enable cross-encoding joins with explicit mappings</li> </ol>"},{"location":"examples/intersections-tutorial/#next-steps","title":"Next Steps","text":"<ul> <li>Intersections API Reference - Full API documentation</li> <li>Enterprise Knowledge Example - Complex multi-collection queries</li> <li>The Compose System - Understanding the full architecture</li> </ul>"},{"location":"examples/unified-intelligence/","title":"Unified Intelligence Demo","text":"<p>This demo showcases HyperBinder's unique ability to seamlessly traverse between semantic (fuzzy) and symbolic (exact) data in a single query chain\u2014something that traditionally requires complex multi-system orchestration.</p>"},{"location":"examples/unified-intelligence/#the-knowledge-design-layer","title":"The Knowledge Design Layer","text":"<p>Modern AI stacks have a gap. LLMs need structured knowledge, but data lives in fragmented systems. HyperBinder fills this gap with a Knowledge Design Layer:</p> <pre><code>flowchart TB\n    A[\"LLMs \u00b7 Agents \u00b7 RAG\"]\n    K[\"&lt;b&gt;KNOWLEDGE DESIGN LAYER&lt;/b&gt;&lt;br/&gt;&lt;i&gt;Compounds \u00b7 Intersections \u00b7 Queries&lt;/i&gt;\"]\n    D[\"Your Data Sources\"]\n\n    A &lt;--&gt;|\"Declarative queries\"| K\n    K &lt;--&gt;|\"Ingestion\"| D\n\n    style K fill:#3182ce,stroke:#63b3ed,stroke-width:2px,color:#fff</code></pre> <p>Without HyperBinder: 200+ lines of orchestration across 3+ systems per query type.</p> <p>With HyperBinder: ~10 lines, one system, declarative.</p>"},{"location":"examples/unified-intelligence/#the-scenario","title":"The Scenario","text":"<p>A product manager asks:</p> <p>\"Who are our ML experts in Engineering, what projects are they on, and what's the budget allocation?\"</p> <p>This simple question requires traversing:</p> <ol> <li>Semantic search on employee bios</li> <li>Exact filtering on department</li> <li>Cross-encoding join from employee IDs to expertise topics</li> <li>Semantic join from topics to projects</li> <li>Exact join from projects to budgets</li> </ol>"},{"location":"examples/unified-intelligence/#traditional-approach","title":"Traditional Approach","text":"<p>Without HyperBinder, you'd need to orchestrate multiple systems:</p> <pre><code>flowchart TB\n    ES[\"Elasticsearch\"]\n    APP1[\"App Code\"]\n    PG1[\"PostgreSQL\"]\n    APP2[\"App Code\"]\n    NEO[\"Neo4j\"]\n    APP3[\"App Code\"]\n    PG2[\"PostgreSQL\"]\n    APP4[\"App Code\"]\n\n    ES --&gt; APP1 --&gt; PG1 --&gt; APP2 --&gt; NEO --&gt; APP3 --&gt; PG2 --&gt; APP4\n\n    style ES fill:#c05621,stroke:#ed8936,color:#fff\n    style PG1 fill:#276749,stroke:#48bb78,color:#fff\n    style PG2 fill:#276749,stroke:#48bb78,color:#fff\n    style NEO fill:#553c9a,stroke:#9f7aea,color:#fff\n    style APP1 fill:#9b2c2c,stroke:#fc8181,color:#fff\n    style APP2 fill:#9b2c2c,stroke:#fc8181,color:#fff\n    style APP3 fill:#9b2c2c,stroke:#fc8181,color:#fff\n    style APP4 fill:#9b2c2c,stroke:#fc8181,color:#fff</code></pre> <p>Problems with this approach:</p> <ul> <li>Multiple systems to maintain (Elasticsearch, PostgreSQL, Neo4j)</li> <li>Complex orchestration code for each query type</li> <li>No type safety across system boundaries</li> <li>Difficult to modify query logic</li> <li>Performance overhead from multiple round-trips</li> </ul>"},{"location":"examples/unified-intelligence/#hyperbinder-approach","title":"HyperBinder Approach","text":"<pre><code>from hybi import HyperBinder\nimport pandas as pd\n\nhb = HyperBinder()\n\n# === DATA SETUP ===\n\n# Employees (semantic search on bios)\nemployees = pd.DataFrame([\n    {\"employee_id\": \"EMP001\", \"name\": \"Alice Chen\",\n     \"bio\": \"Senior ML engineer specializing in NLP\", \"department\": \"Engineering\"},\n    {\"employee_id\": \"EMP002\", \"name\": \"Bob Smith\",\n     \"bio\": \"Backend developer with distributed systems expertise\", \"department\": \"Engineering\"},\n    {\"employee_id\": \"EMP003\", \"name\": \"Carol White\",\n     \"bio\": \"ML researcher focusing on computer vision\", \"department\": \"Research\"},\n    {\"employee_id\": \"EMP004\", \"name\": \"David Lee\",\n     \"bio\": \"Data scientist with machine learning background\", \"department\": \"Engineering\"},\n])\n\n# Expertise topics (semantic encoding)\nexpertise = pd.DataFrame([\n    {\"topic\": \"natural language processing\", \"domain\": \"AI\", \"maturity\": \"Production\"},\n    {\"topic\": \"computer vision models\", \"domain\": \"AI\", \"maturity\": \"Research\"},\n    {\"topic\": \"distributed systems design\", \"domain\": \"Infrastructure\", \"maturity\": \"Production\"},\n    {\"topic\": \"deep learning frameworks\", \"domain\": \"AI\", \"maturity\": \"Production\"},\n])\n\n# Projects (joined via expertise)\nprojects = pd.DataFrame([\n    {\"project_id\": \"PROJ001\", \"name\": \"ChatBot v2\", \"focus_area\": \"natural language processing\"},\n    {\"project_id\": \"PROJ002\", \"name\": \"Visual Search\", \"focus_area\": \"computer vision models\"},\n    {\"project_id\": \"PROJ003\", \"name\": \"Model Training Platform\", \"focus_area\": \"deep learning frameworks\"},\n])\n\n# Budgets (exact lookups)\nbudgets = pd.DataFrame([\n    {\"project_id\": \"PROJ001\", \"allocated\": 500000, \"spent\": 320000},\n    {\"project_id\": \"PROJ002\", \"allocated\": 750000, \"spent\": 180000},\n    {\"project_id\": \"PROJ003\", \"allocated\": 1000000, \"spent\": 50000},\n])\n\n# Link mappings (employee IDs \u2192 expertise topics)\nemployee_expertise = pd.DataFrame([\n    {\"employee_id\": \"EMP001\", \"topic\": \"natural language processing\"},\n    {\"employee_id\": \"EMP001\", \"topic\": \"deep learning frameworks\"},\n    {\"employee_id\": \"EMP003\", \"topic\": \"computer vision models\"},\n    {\"employee_id\": \"EMP004\", \"topic\": \"deep learning frameworks\"},\n    {\"employee_id\": \"EMP004\", \"topic\": \"natural language processing\"},\n])\n\n# Ingest data\nhb.ingest(employees, \"employees\")\nhb.ingest(expertise, \"expertise\")\nhb.ingest(projects, \"projects\")\nhb.ingest(budgets, \"budgets\")\n\n# === DECLARE INTERSECTIONS ===\n\n# Cross-encoding: EXACT employee_id \u2192 SEMANTIC topic\nix = hb.intersect_flexible(\"employees.employee_id\", \"expertise.topic\")\nhb.populate_links(ix, employee_expertise, \"employee_id\", \"topic\")\n\n# Same-encoding joins\nhb.intersect(\"expertise.topic\", \"projects.focus_area\")\nhb.intersect(\"projects.project_id\", \"budgets.project_id\")\n\n# === THE POWER QUERY ===\n\nresults = (\n    hb.query(\"employees\")\n    .search(\"machine learning\")           # SEMANTIC: fuzzy bio search\n    .filter(department=\"Engineering\")     # EXACT: department filter\n    .join(\"expertise\")                    # CROSS-ENCODING: via links!\n    .join(\"projects\")                     # SEMANTIC: topic \u2192 focus area\n    .join(\"budgets\")                      # EXACT: project_id match\n)\n\n# That's it. ~10 lines instead of 200+.\n\nfor r in results:\n    emp = r[\"employees\"]\n    exp = r[\"expertise\"]\n    proj = r[\"projects\"]\n    budget = r[\"budgets\"]\n\n    print(f\"{emp['name']} \u2192 {exp['topic']} \u2192 {proj['name']} (${budget['allocated']:,})\")\n</code></pre> <p>Output: <pre><code>Alice Chen \u2192 natural language processing \u2192 ChatBot v2 ($500,000)\nAlice Chen \u2192 deep learning frameworks \u2192 Model Training Platform ($1,000,000)\nDavid Lee \u2192 natural language processing \u2192 ChatBot v2 ($500,000)\nDavid Lee \u2192 deep learning frameworks \u2192 Model Training Platform ($1,000,000)\n</code></pre></p>"},{"location":"examples/unified-intelligence/#what-makes-this-unique","title":"What Makes This Unique","text":""},{"location":"examples/unified-intelligence/#1-unified-query-language","title":"1. Unified Query Language","text":"<p>One syntax for semantic, exact, and graph operations:</p> <pre><code>.search(\"query\")           # Semantic similarity\n.filter(field=\"value\")     # Exact equality\n.join(\"collection\")        # Graph traversal\n</code></pre>"},{"location":"examples/unified-intelligence/#2-cross-encoding-joins","title":"2. Cross-Encoding Joins","text":"<p>Connect fields with different encoding types via explicit links:</p> <pre><code># EXACT employee IDs \u2194 SEMANTIC topic descriptions\nix = hb.intersect_flexible(\"employees.employee_id\", \"expertise.topic\")\nhb.populate_links(ix, links_df, \"employee_id\", \"topic\")\n</code></pre>"},{"location":"examples/unified-intelligence/#3-declarative-not-procedural","title":"3. Declarative, Not Procedural","text":"<p>Describe what you want, not how to orchestrate it:</p> <pre><code># What: ML experts in Engineering with their projects and budgets\n# How: HyperBinder figures it out\n</code></pre>"},{"location":"examples/unified-intelligence/#4-type-safe","title":"4. Type-Safe","text":"<p>Schema validation catches errors at definition time, not runtime.</p>"},{"location":"examples/unified-intelligence/#5-composable","title":"5. Composable","text":"<p>Each operation builds on the previous, creating a fluent chain.</p>"},{"location":"examples/unified-intelligence/#additional-capabilities","title":"Additional Capabilities","text":""},{"location":"examples/unified-intelligence/#analogical-reasoning","title":"Analogical Reasoning","text":"<pre><code># \"Alice is our NLP expert. Who plays a similar role for computer vision?\"\nresults = hb.analogy(\"Alice Chen\", \"NLP\", \"computer vision\",\n                     field=\"name\", collection=\"employees\")\n</code></pre>"},{"location":"examples/unified-intelligence/#bidirectional-traversal","title":"Bidirectional Traversal","text":"<pre><code># Start from budgets, trace back to employees\nresults = (\n    hb.query(\"budgets\")\n    .filter(allocated__gt=500000)\n    .join(\"projects\")\n    .join(\"expertise\")\n    .join(\"employees\")\n)\n</code></pre>"},{"location":"examples/unified-intelligence/#prototype-search","title":"Prototype Search","text":"<pre><code># Find employees similar to ANY of these examples\nresults = hb.search_prototype(\n    examples=[\"Alice Chen\", \"David Lee\"],\n    field=\"name\",\n    collection=\"employees\"\n)\n</code></pre>"},{"location":"examples/unified-intelligence/#running-the-demo","title":"Running the Demo","text":"<pre><code>python examples/compose/unified_intelligence_demo.py\n</code></pre>"},{"location":"examples/unified-intelligence/#compound-combinations-model-any-domain","title":"Compound Combinations: Model Any Domain","text":"<p>The real power is combining compounds to model any domain. Each compound is optimized for a specific pattern, and intersections wire them together.</p> Compound Optimized For Catalog Searchable records with weighted fields RelationalTable CRUD operations with primary keys KnowledgeGraph Entity-relation-entity facts Hierarchy Parent-child trees (org charts, taxonomies) Document Text chunks with metadata Network Graph relationships (social, citations) TimeSeries Time-ordered sequences"},{"location":"examples/unified-intelligence/#example-healthcare-system","title":"Example: Healthcare System","text":"<pre><code>flowchart LR\n    subgraph row1 [\" \"]\n        direction LR\n        P[\"Patients&lt;br/&gt;&lt;i&gt;Catalog&lt;/i&gt;\"]\n        D[\"Diagnoses&lt;br/&gt;&lt;i&gt;KnowledgeGraph&lt;/i&gt;\"]\n        T[\"Treatments&lt;br/&gt;&lt;i&gt;TimeSeries&lt;/i&gt;\"]\n    end\n    subgraph row2 [\" \"]\n        direction LR\n        R[\"Records&lt;br/&gt;&lt;i&gt;RelationalTable&lt;/i&gt;\"]\n        M[\"Medical Ontology&lt;br/&gt;&lt;i&gt;Hierarchy&lt;/i&gt;\"]\n        DR[\"Drug Database&lt;br/&gt;&lt;i&gt;RelationalTable&lt;/i&gt;\"]\n    end\n    P --&gt; D --&gt; T\n    P --&gt; R\n    D --&gt; M\n    T --&gt; DR</code></pre> <pre><code>results = (\n    hb.query(\"patients\").search(\"diabetes symptoms\")\n    .join(\"diagnoses\")        # Semantic: symptoms \u2192 condition\n    .join(\"treatments\")       # Identity: condition \u2192 treatment plan\n    .join(\"drugs\")            # Identity: drug_id \u2192 drug record\n    .filter(has_contraindications=True)\n)\n</code></pre>"},{"location":"examples/unified-intelligence/#example-legal-research-platform","title":"Example: Legal Research Platform","text":"<pre><code>flowchart LR\n    subgraph row1 [\" \"]\n        direction LR\n        C[\"Cases&lt;br/&gt;&lt;i&gt;Document&lt;/i&gt;\"]\n        CT[\"Citations&lt;br/&gt;&lt;i&gt;Network&lt;/i&gt;\"]\n        S[\"Statutes&lt;br/&gt;&lt;i&gt;Hierarchy&lt;/i&gt;\"]\n    end\n    subgraph row2 [\" \"]\n        direction LR\n        J[\"Judges&lt;br/&gt;&lt;i&gt;Catalog&lt;/i&gt;\"]\n        L[\"Legal Concepts&lt;br/&gt;&lt;i&gt;KnowledgeGraph&lt;/i&gt;\"]\n        JR[\"Jurisdictions&lt;br/&gt;&lt;i&gt;Hierarchy&lt;/i&gt;\"]\n    end\n    C --&gt; CT --&gt; S\n    C --&gt; J\n    CT --&gt; L\n    S --&gt; JR</code></pre> <pre><code>results = (\n    hb.query(\"cases\").search(\"digital privacy\")\n    .join(\"citations\")        # Network: case \u2192 cited cases\n    .join(\"statutes\")         # Identity: statute_id \u2192 statute\n    .filter(amendment=\"4th\")\n    .join(\"concepts\")         # Semantic: case text \u2192 legal concept\n)\n</code></pre>"},{"location":"examples/unified-intelligence/#example-research-knowledge-base","title":"Example: Research Knowledge Base","text":"<pre><code>flowchart LR\n    subgraph row1 [\" \"]\n        direction LR\n        PA[\"Papers&lt;br/&gt;&lt;i&gt;Document&lt;/i&gt;\"]\n        AU[\"Authors&lt;br/&gt;&lt;i&gt;Network&lt;/i&gt;\"]\n        IN[\"Institutions&lt;br/&gt;&lt;i&gt;Hierarchy&lt;/i&gt;\"]\n    end\n    subgraph row2 [\" \"]\n        direction LR\n        CO[\"Concepts&lt;br/&gt;&lt;i&gt;KnowledgeGraph&lt;/i&gt;\"]\n        GR[\"Grants&lt;br/&gt;&lt;i&gt;RelationalTable&lt;/i&gt;\"]\n        VE[\"Venues&lt;br/&gt;&lt;i&gt;Catalog&lt;/i&gt;\"]\n    end\n    PA --&gt; AU --&gt; IN\n    PA --&gt; CO\n    AU --&gt; GR\n    IN --&gt; VE</code></pre> <pre><code>results = (\n    hb.query(\"papers\").search(\"transformer attention mechanism\")\n    .join(\"concepts\")         # Semantic: abstract \u2192 research concept\n    .join(\"authors\")          # Network: paper \u2192 author collaborations\n    .join(\"institutions\")     # Identity: affiliation_id \u2192 institution\n    .filter(name=\"Stanford\")\n    .join(\"grants\")           # Flexible: author_id \u2192 grant_id\n    .filter(agency=\"NSF\")\n)\n</code></pre>"},{"location":"examples/unified-intelligence/#the-pattern","title":"The Pattern","text":"<ol> <li>Choose compounds that match your data shapes</li> <li>Connect with intersections (strict for same-type, flexible for cross-type)</li> <li>Query declaratively across the entire graph</li> </ol> <p>Each compound handles its specialty. Mix them freely\u2014the intersections handle the glue.</p>"},{"location":"examples/unified-intelligence/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>One System: Replace Elasticsearch + PostgreSQL + Neo4j with one unified interface</li> <li>Cross-Encoding: Connect any field types via explicit link mappings</li> <li>Declarative: Focus on the question, not the plumbing</li> <li>Composable: Build complex queries from simple, chainable operations</li> <li>Type-Safe: Catch errors early with schema validation</li> <li>Domain Flexible: Combine compounds to model any knowledge architecture</li> </ol> <p>This is the power of neurosymbolic computing: the best of semantic and symbolic approaches, seamlessly integrated.</p>"}]}